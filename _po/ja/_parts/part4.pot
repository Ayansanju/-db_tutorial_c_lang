# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-23 11:24+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../_parts/part4.md:1
msgid "---\n"
"title: Part 4 - Our First Tests (and Bugs)\n"
"date: 2017-09-03\n"
"---"
msgstr ""

#: ../../../_parts/part4.md:6
msgid "We've got the ability to insert rows into our database and to print out all rows. Let's take a moment to test what we've got so far."
msgstr ""

#: ../../../_parts/part4.md:8
msgid "I'm going to use [rspec](http://rspec.info/) to write my tests because I'm familiar with it, and the syntax is fairly readable."
msgstr ""

#: ../../../_parts/part4.md:10
msgid "I'll define a short helper to send a list of commands to our database program then make assertions about the output:"
msgstr ""

#: ../../../_parts/part4.md:12
msgid "```ruby\n"
"describe 'database' do\n"
"  def run_script(commands)\n"
"    raw_output = nil\n"
"    IO.popen(\"./db\", \"r+\") do |pipe|\n"
"      commands.each do |command|\n"
"        pipe.puts command\n"
"      end"
msgstr ""

#: ../../../_parts/part4.md:21
msgid "      pipe.close_write"
msgstr ""

#: ../../../_parts/part4.md:23
msgid "      # Read entire output\n"
"      raw_output = pipe.gets(nil)\n"
"    end\n"
"    raw_output.split(\"\\n\")\n"
"  end"
msgstr ""

#: ../../../_parts/part4.md:29
msgid "  it 'inserts and retrieves a row' do\n"
"    result = run_script([\n"
"      \"insert 1 user1 person1@example.com\",\n"
"      \"select\",\n"
"      \".exit\",\n"
"    ])\n"
"    expect(result).to match_array([\n"
"      \"db > Executed.\",\n"
"      \"db > (1, user1, person1@example.com)\",\n"
"      \"Executed.\",\n"
"      \"db > \",\n"
"    ])\n"
"  end\n"
"end\n"
"```"
msgstr ""

#: ../../../_parts/part4.md:45
msgid "This simple test makes sure we get back what we put in. And indeed it passes:\n"
"```command-line\n"
"bundle exec rspec\n"
"."
msgstr ""

#: ../../../_parts/part4.md:50
msgid "Finished in 0.00871 seconds (files took 0.09506 seconds to load)\n"
"1 example, 0 failures\n"
"```"
msgstr ""

#: ../../../_parts/part4.md:54
msgid "Now it's feasible to test inserting a large number of rows into the database:\n"
"```ruby\n"
"it 'prints error message when table is full' do\n"
"  script = (1..1401).map do |i|\n"
"    \"insert #{i} user#{i} person#{i}@example.com\"\n"
"  end\n"
"  script << \".exit\"\n"
"  result = run_script(script)\n"
"  expect(result[-2]).to eq('db > Error: Table full.')\n"
"end\n"
"```"
msgstr ""

#: ../../../_parts/part4.md:66
msgid "Running tests again...\n"
"```command-line\n"
"bundle exec rspec\n"
".."
msgstr ""

#: ../../../_parts/part4.md:71
msgid "Finished in 0.01553 seconds (files took 0.08156 seconds to load)\n"
"2 examples, 0 failures\n"
"```"
msgstr ""

#: ../../../_parts/part4.md:75
msgid "Sweet, it works! Our db can hold 1400 rows right now because we set the maximum number of pages to 100, and 14 rows can fit in a page."
msgstr ""

#: ../../../_parts/part4.md:77
msgid "Reading through the code we have so far, I realized we might not handle storing text fields correctly. Easy to test with this example:\n"
"```ruby\n"
"it 'allows inserting strings that are the maximum length' do\n"
"  long_username = \"a\"*32\n"
"  long_email = \"a\"*255\n"
"  script = [\n"
"    \"insert 1 #{long_username} #{long_email}\",\n"
"    \"select\",\n"
"    \".exit\",\n"
"  ]\n"
"  result = run_script(script)\n"
"  expect(result).to match_array([\n"
"    \"db > Executed.\",\n"
"    \"db > (1, #{long_username}, #{long_email})\",\n"
"    \"Executed.\",\n"
"    \"db > \",\n"
"  ])\n"
"end\n"
"```"
msgstr ""

#: ../../../_parts/part4.md:97
msgid "And the test fails!\n"
"```ruby\n"
"Failures:"
msgstr ""

#: ../../../_parts/part4.md:101
msgid "  1) database allows inserting strings that are the maximum length\n"
"     Failure/Error: raw_output.split(\"\\n\")"
msgstr ""

#: ../../../_parts/part4.md:104
msgid "     ArgumentError:\n"
"       invalid byte sequence in UTF-8\n"
"     # ./spec/main_spec.rb:14:in `split'\n"
"     # ./spec/main_spec.rb:14:in `run_script'\n"
"     # ./spec/main_spec.rb:48:in `block (2 levels) in <top (required)>'\n"
"```"
msgstr ""

#: ../../../_parts/part4.md:111
msgid "If we try it ourselves, we'll see that there's some weird characters when we try to print out the row. (I'm abbreviating the long strings):\n"
"```command-line\n"
"db > insert 1 aaaaa... aaaaa...\n"
"Executed.\n"
"db > select\n"
"(1, aaaaa...aaa\\�, aaaaa...aaa\\�)\n"
"Executed.\n"
"db >\n"
"```"
msgstr ""

#: ../../../_parts/part4.md:121
msgid "What's going on? If you take a look at our definition of a Row, we allocate exactly 32 bytes for username and exactly 255 bytes for email. But [C strings](http://www.cprogramming.com/tutorial/c/lesson9.html) are supposed to end with a null character, which we didn't allocate space for. The solution is to allocate one additional byte:\n"
"```diff\n"
" const uint32_t COLUMN_EMAIL_SIZE = 255;\n"
" typedef struct {\n"
"   uint32_t id;\n"
"-  char username[COLUMN_USERNAME_SIZE];\n"
"-  char email[COLUMN_EMAIL_SIZE];\n"
"+  char username[COLUMN_USERNAME_SIZE + 1];\n"
"+  char email[COLUMN_EMAIL_SIZE + 1];\n"
" } Row;\n"
" ```"
msgstr ""

#: ../../../_parts/part4.md:133
msgid " And indeed that fixes it:\n"
" ```ruby\n"
" bundle exec rspec\n"
"..."
msgstr ""

#: ../../../_parts/part4.md:138
msgid "Finished in 0.0188 seconds (files took 0.08516 seconds to load)\n"
"3 examples, 0 failures\n"
"```"
msgstr ""

#: ../../../_parts/part4.md:142
msgid "We should not allow inserting usernames or emails that are longer than column size. The spec for that looks like this:\n"
"```ruby\n"
"it 'prints error message if strings are too long' do\n"
"  long_username = \"a\"*33\n"
"  long_email = \"a\"*256\n"
"  script = [\n"
"    \"insert 1 #{long_username} #{long_email}\",\n"
"    \"select\",\n"
"    \".exit\",\n"
"  ]\n"
"  result = run_script(script)\n"
"  expect(result).to match_array([\n"
"    \"db > String is too long.\",\n"
"    \"db > Executed.\",\n"
"    \"db > \",\n"
"  ])\n"
"end\n"
"```"
msgstr ""

#: ../../../_parts/part4.md:161
msgid "In order to do this we need to upgrade our parser. As a reminder, we're currently using [scanf()](https://linux.die.net/man/3/scanf):\n"
"```c\n"
"if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n"
"  statement->type = STATEMENT_INSERT;\n"
"  int args_assigned = sscanf(\n"
"      input_buffer->buffer, \"insert %d %s %s\", &(statement->row_to_insert.id),\n"
"      statement->row_to_insert.username, statement->row_to_insert.email);\n"
"  if (args_assigned < 3) {\n"
"    return PREPARE_SYNTAX_ERROR;\n"
"  }\n"
"  return PREPARE_SUCCESS;\n"
"}\n"
"```"
msgstr ""

#: ../../../_parts/part4.md:175
msgid "But [scanf has some disadvantages](https://stackoverflow.com/questions/2430303/disadvantages-of-scanf). If the string it's reading is larger than the buffer it's reading into, it will cause a buffer overflow and start writing into unexpected places. We want to check the length of each string before we copy it into a `Row` structure. And to do that, we need to divide the input by spaces."
msgstr ""

#: ../../../_parts/part4.md:177
msgid "I'm going to use [strtok()](http://www.cplusplus.com/reference/cstring/strtok/) to do that. I think it's easiest to understand if you see it in action:"
msgstr ""

#: ../../../_parts/part4.md:179
msgid "```diff\n"
"+PrepareResult prepare_insert(InputBuffer* input_buffer, Statement* statement) {\n"
"+  statement->type = STATEMENT_INSERT;\n"
"+\n"
"+  char* keyword = strtok(input_buffer->buffer, \" \");\n"
"+  char* id_string = strtok(NULL, \" \");\n"
"+  char* username = strtok(NULL, \" \");\n"
"+  char* email = strtok(NULL, \" \");\n"
"+\n"
"+  if (id_string == NULL || username == NULL || email == NULL) {\n"
"+    return PREPARE_SYNTAX_ERROR;\n"
"+  }\n"
"+\n"
"+  int id = atoi(id_string);\n"
"+  if (strlen(username) > COLUMN_USERNAME_SIZE) {\n"
"+    return PREPARE_STRING_TOO_LONG;\n"
"+  }\n"
"+  if (strlen(email) > COLUMN_EMAIL_SIZE) {\n"
"+    return PREPARE_STRING_TOO_LONG;\n"
"+  }\n"
"+\n"
"+  statement->row_to_insert.id = id;\n"
"+  strcpy(statement->row_to_insert.username, username);\n"
"+  strcpy(statement->row_to_insert.email, email);\n"
"+\n"
"+  return PREPARE_SUCCESS;\n"
"+}\n"
"+\n"
" PrepareResult prepare_statement(InputBuffer* input_buffer,\n"
"                                 Statement* statement) {\n"
"   if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n"
"+    return prepare_insert(input_buffer, statement);\n"
"-    statement->type = STATEMENT_INSERT;\n"
"-    int args_assigned = sscanf(\n"
"-        input_buffer->buffer, \"insert %d %s %s\", &(statement->row_to_insert.id),\n"
"-        statement->row_to_insert.username, statement->row_to_insert.email);\n"
"-    if (args_assigned < 3) {\n"
"-      return PREPARE_SYNTAX_ERROR;\n"
"-    }\n"
"-    return PREPARE_SUCCESS;\n"
"   }\n"
"```"
msgstr ""

#: ../../../_parts/part4.md:222
msgid "Calling `strtok` successively on the input buffer breaks it into substrings by inserting a null character whenever it reaches a delimiter (space, in our case). It returns a pointer to the start of the substring."
msgstr ""

#: ../../../_parts/part4.md:224
msgid "We can call [strlen()](http://www.cplusplus.com/reference/cstring/strlen/) on each text value to see if it's too long."
msgstr ""

#: ../../../_parts/part4.md:226
msgid "We can handle the error like we do any other error code:\n"
"```diff\n"
" enum PrepareResult_t {\n"
"   PREPARE_SUCCESS,\n"
"+  PREPARE_STRING_TOO_LONG,\n"
"   PREPARE_SYNTAX_ERROR,\n"
"   PREPARE_UNRECOGNIZED_STATEMENT\n"
" };\n"
"```\n"
"```diff\n"
" switch (prepare_statement(input_buffer, &statement)) {\n"
"   case (PREPARE_SUCCESS):\n"
"     break;\n"
"+  case (PREPARE_STRING_TOO_LONG):\n"
"+    printf(\"String is too long.\\n\");\n"
"+    continue;\n"
"   case (PREPARE_SYNTAX_ERROR):\n"
"     printf(\"Syntax error. Could not parse statement.\\n\");\n"
"     continue;\n"
"```"
msgstr ""

#: ../../../_parts/part4.md:247
msgid "Which makes our test pass\n"
"```command-line\n"
"bundle exec rspec\n"
"...."
msgstr ""

#: ../../../_parts/part4.md:252
msgid "Finished in 0.02284 seconds (files took 0.116 seconds to load)\n"
"4 examples, 0 failures\n"
"```"
msgstr ""

#: ../../../_parts/part4.md:256
msgid "While we're here, we might as well handle one more error case:\n"
"```ruby\n"
"it 'prints an error message if id is negative' do\n"
"  script = [\n"
"    \"insert -1 cstack foo@bar.com\",\n"
"    \"select\",\n"
"    \".exit\",\n"
"  ]\n"
"  result = run_script(script)\n"
"  expect(result).to match_array([\n"
"    \"db > ID must be positive.\",\n"
"    \"db > Executed.\",\n"
"    \"db > \",\n"
"  ])\n"
"end\n"
"```\n"
"```diff\n"
" enum PrepareResult_t {\n"
"   PREPARE_SUCCESS,\n"
"+  PREPARE_NEGATIVE_ID,\n"
"   PREPARE_STRING_TOO_LONG,\n"
"   PREPARE_SYNTAX_ERROR,\n"
"   PREPARE_UNRECOGNIZED_STATEMENT\n"
"@@ -148,9 +147,6 @@ PrepareResult prepare_insert(InputBuffer* input_buffer, Statement* statement) {\n"
"   }"
msgstr ""

#: ../../../_parts/part4.md:282
msgid "   int id = atoi(id_string);\n"
"+  if (id < 0) {\n"
"+    return PREPARE_NEGATIVE_ID;\n"
"+  }\n"
"   if (strlen(username) > COLUMN_USERNAME_SIZE) {\n"
"     return PREPARE_STRING_TOO_LONG;\n"
"   }\n"
"@@ -230,9 +226,6 @@ int main(int argc, char* argv[]) {\n"
"     switch (prepare_statement(input_buffer, &statement)) {\n"
"       case (PREPARE_SUCCESS):\n"
"         break;\n"
"+      case (PREPARE_NEGATIVE_ID):\n"
"+        printf(\"ID must be positive.\\n\");\n"
"+        continue;\n"
"       case (PREPARE_STRING_TOO_LONG):\n"
"         printf(\"String is too long.\\n\");\n"
"         continue;\n"
"```"
msgstr ""

#: ../../../_parts/part4.md:301
msgid "Alright, that's enough testing for now. Next is a very important feature: persistence! We're going to save our database to a file and read it back out again."
msgstr ""

#: ../../../_parts/part4.md:303
msgid "It's gonna be great."
msgstr ""

#: ../../../_parts/part4.md:305
msgid "Here's the complete diff for this part:\n"
"```diff\n"
"@@ -22,6 +22,8 @@"
msgstr ""

#: ../../../_parts/part4.md:309
msgid " enum PrepareResult_t {\n"
"   PREPARE_SUCCESS,\n"
"+  PREPARE_NEGATIVE_ID,\n"
"+  PREPARE_STRING_TOO_LONG,\n"
"   PREPARE_SYNTAX_ERROR,\n"
"   PREPARE_UNRECOGNIZED_STATEMENT\n"
"  };\n"
"@@ -34,8 +36,8 @@\n"
" #define COLUMN_EMAIL_SIZE 255\n"
" typedef struct {\n"
"   uint32_t id;\n"
"-  char username[COLUMN_USERNAME_SIZE];\n"
"-  char email[COLUMN_EMAIL_SIZE];\n"
"+  char username[COLUMN_USERNAME_SIZE + 1];\n"
"+  char email[COLUMN_EMAIL_SIZE + 1];\n"
" } Row;"
msgstr ""

#: ../../../_parts/part4.md:326
msgid "@@ -150,18 +152,40 @@ MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table *table) {\n"
"   }\n"
" }"
msgstr ""

#: ../../../_parts/part4.md:330
msgid "-PrepareResult prepare_statement(InputBuffer* input_buffer,\n"
"-                                Statement* statement) {\n"
"-  if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n"
"+PrepareResult prepare_insert(InputBuffer* input_buffer, Statement* statement) {\n"
"   statement->type = STATEMENT_INSERT;\n"
"-  int args_assigned = sscanf(\n"
"-     input_buffer->buffer, \"insert %d %s %s\", &(statement->row_to_insert.id),\n"
"-     statement->row_to_insert.username, statement->row_to_insert.email\n"
"-     );\n"
"-  if (args_assigned < 3) {\n"
"+\n"
"+  char* keyword = strtok(input_buffer->buffer, \" \");\n"
"+  char* id_string = strtok(NULL, \" \");\n"
"+  char* username = strtok(NULL, \" \");\n"
"+  char* email = strtok(NULL, \" \");\n"
"+\n"
"+  if (id_string == NULL || username == NULL || email == NULL) {\n"
"      return PREPARE_SYNTAX_ERROR;\n"
"   }\n"
"+\n"
"+  int id = atoi(id_string);\n"
"+  if (id < 0) {\n"
"+     return PREPARE_NEGATIVE_ID;\n"
"+  }\n"
"+  if (strlen(username) > COLUMN_USERNAME_SIZE) {\n"
"+     return PREPARE_STRING_TOO_LONG;\n"
"+  }\n"
"+  if (strlen(email) > COLUMN_EMAIL_SIZE) {\n"
"+     return PREPARE_STRING_TOO_LONG;\n"
"+  }\n"
"+\n"
"+  statement->row_to_insert.id = id;\n"
"+  strcpy(statement->row_to_insert.username, username);\n"
"+  strcpy(statement->row_to_insert.email, email);\n"
"+\n"
"   return PREPARE_SUCCESS;\n"
"+\n"
"+}\n"
"+PrepareResult prepare_statement(InputBuffer* input_buffer,\n"
"+                                Statement* statement) {\n"
"+  if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n"
"+      return prepare_insert(input_buffer, statement);\n"
"   }\n"
"   if (strcmp(input_buffer->buffer, \"select\") == 0) {\n"
"     statement->type = STATEMENT_SELECT;\n"
"@@ -223,6 +247,12 @@ int main(int argc, char* argv[]) {\n"
"     switch (prepare_statement(input_buffer, &statement)) {\n"
"       case (PREPARE_SUCCESS):\n"
"         break;\n"
"+      case (PREPARE_NEGATIVE_ID):\n"
"+	printf(\"ID must be positive.\\n\");\n"
"+	continue;\n"
"+      case (PREPARE_STRING_TOO_LONG):\n"
"+	printf(\"String is too long.\\n\");\n"
"+	continue;\n"
"       case (PREPARE_SYNTAX_ERROR):\n"
" 	printf(\"Syntax error. Could not parse statement.\\n\");\n"
" 	continue;\n"
"```\n"
"And we added tests:\n"
"```diff\n"
"+describe 'database' do\n"
"+  def run_script(commands)\n"
"+    raw_output = nil\n"
"+    IO.popen(\"./db\", \"r+\") do |pipe|\n"
"+      commands.each do |command|\n"
"+        pipe.puts command\n"
"+      end\n"
"+\n"
"+      pipe.close_write\n"
"+\n"
"+      # Read entire output\n"
"+      raw_output = pipe.gets(nil)\n"
"+    end\n"
"+    raw_output.split(\"\\n\")\n"
"+  end\n"
"+\n"
"+  it 'inserts and retrieves a row' do\n"
"+    result = run_script([\n"
"+      \"insert 1 user1 person1@example.com\",\n"
"+      \"select\",\n"
"+      \".exit\",\n"
"+    ])\n"
"+    expect(result).to match_array([\n"
"+      \"db > Executed.\",\n"
"+      \"db > (1, user1, person1@example.com)\",\n"
"+      \"Executed.\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
"+\n"
"+  it 'prints error message when table is full' do\n"
"+    script = (1..1401).map do |i|\n"
"+      \"insert #{i} user#{i} person#{i}@example.com\"\n"
"+    end\n"
"+    script << \".exit\"\n"
"+    result = run_script(script)\n"
"+    expect(result[-2]).to eq('db > Error: Table full.')\n"
"+  end\n"
"+\n"
"+  it 'allows inserting strings that are the maximum length' do\n"
"+    long_username = \"a\"*32\n"
"+    long_email = \"a\"*255\n"
"+    script = [\n"
"+      \"insert 1 #{long_username} #{long_email}\",\n"
"+      \"select\",\n"
"+      \".exit\",\n"
"+    ]\n"
"+    result = run_script(script)\n"
"+    expect(result).to match_array([\n"
"+      \"db > Executed.\",\n"
"+      \"db > (1, #{long_username}, #{long_email})\",\n"
"+      \"Executed.\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
"+\n"
"+  it 'prints error message if strings are too long' do\n"
"+    long_username = \"a\"*33\n"
"+    long_email = \"a\"*256\n"
"+    script = [\n"
"+      \"insert 1 #{long_username} #{long_email}\",\n"
"+      \"select\",\n"
"+      \".exit\",\n"
"+    ]\n"
"+    result = run_script(script)\n"
"+    expect(result).to match_array([\n"
"+      \"db > String is too long.\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
"+\n"
"+  it 'prints an error message if id is negative' do\n"
"+    script = [\n"
"+      \"insert -1 cstack foo@bar.com\",\n"
"+      \"select\",\n"
"+      \".exit\",\n"
"+    ]\n"
"+    result = run_script(script)\n"
"+    expect(result).to match_array([\n"
"+      \"db > ID must be positive.\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
"+end\n"
"```"
msgstr ""

