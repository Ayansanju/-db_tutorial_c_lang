# Japanese translations for PACKAGE package.
# Copyright (C) 2021 THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-23 11:24+0900\n"
"PO-Revision-Date: 2021-11-23 11:24+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=; plural=;\n"

#: ../../../_parts/part10.md:1
msgid ""
"---\n"
"title: Part 10 - Splitting a Leaf Node\n"
"date: 2017-10-09\n"
"---"
msgstr ""

#: ../../../_parts/part10.md:6
msgid "Our B-Tree doesn't feel like much of a tree with only one node. To fix that, we need some code to split a leaf node in twain. And after that, we need to create an internal node to serve as a parent for the two leaf nodes."
msgstr ""

#: ../../../_parts/part10.md:8
msgid "Basically our goal for this article is to go from this:"
msgstr ""

#: ../../../_parts/part10.md:10
msgid "{% include image.html url=\"assets/images/btree2.png\" description=\"one-node btree\" %}"
msgstr ""

#: ../../../_parts/part10.md:12
msgid "to this:"
msgstr ""

#: ../../../_parts/part10.md:14
msgid "{% include image.html url=\"assets/images/btree3.png\" description=\"two-level btree\" %}"
msgstr ""

#: ../../../_parts/part10.md:16
msgid "First things first, let's remove the error handling for a full leaf node:"
msgstr ""

#: ../../../_parts/part10.md:18
msgid ""
"```diff\n"
" void leaf_node_insert(Cursor* cursor, uint32_t key, Row* value) {\n"
"   void* node = get_page(cursor->table->pager, cursor->page_num);"
msgstr ""

#: ../../../_parts/part10.md:22
msgid ""
"   uint32_t num_cells = *leaf_node_num_cells(node);\n"
"   if (num_cells >= LEAF_NODE_MAX_CELLS) {\n"
"     // Node full\n"
"-    printf(\"Need to implement splitting a leaf node.\n"
"\");\n"
"-    exit(EXIT_FAILURE);\n"
"+    leaf_node_split_and_insert(cursor, key, value);\n"
"+    return;\n"
"   }\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:32
msgid ""
"```diff\n"
"ExecuteResult execute_insert(Statement* statement, Table* table) {\n"
"   void* node = get_page(table->pager, table->root_page_num);\n"
"   uint32_t num_cells = (*leaf_node_num_cells(node));\n"
"-  if (num_cells >= LEAF_NODE_MAX_CELLS) {\n"
"-    return EXECUTE_TABLE_FULL;\n"
"-  }"
msgstr ""

#: ../../../_parts/part10.md:40
msgid ""
"   Row* row_to_insert = &(statement->row_to_insert);\n"
"   uint32_t key_to_insert = row_to_insert->id;\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:44
msgid "## Splitting Algorithm"
msgstr ""

#: ../../../_parts/part10.md:46
msgid "Easy part's over. Here's a description of what we need to do from [SQLite Database System: Design and Implementation](https://play.google.com/store/books/details/Sibsankar_Haldar_SQLite_Database_System_Design_and?id=9Z6IQQnX1JEC&hl=en)"
msgstr ""

#: ../../../_parts/part10.md:48
msgid "> If there is no space on the leaf node, we would split the existing entries residing there and the new one (being inserted) into two equal halves: lower and upper halves. (Keys on the upper half are strictly greater than those on the lower half.) We allocate a new leaf node, and move the upper half into the new node."
msgstr ""

#: ../../../_parts/part10.md:51
msgid "Let's get a handle to the old node and create the new node:"
msgstr ""

#: ../../../_parts/part10.md:53
msgid ""
"```diff\n"
"+void leaf_node_split_and_insert(Cursor* cursor, uint32_t key, Row* value) {\n"
"+  /*\n"
"+  Create a new node and move half the cells over.\n"
"+  Insert the new value in one of the two nodes.\n"
"+  Update parent or create a new parent.\n"
"+  */\n"
"+\n"
"+  void* old_node = get_page(cursor->table->pager, cursor->page_num);\n"
"+  uint32_t new_page_num = get_unused_page_num(cursor->table->pager);\n"
"+  void* new_node = get_page(cursor->table->pager, new_page_num);\n"
"+  initialize_leaf_node(new_node);\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:67
msgid "Next, copy every cell into its new location:"
msgstr ""

#: ../../../_parts/part10.md:69
msgid ""
"```diff\n"
"+  /*\n"
"+  All existing keys plus new key should be divided\n"
"+  evenly between old (left) and new (right) nodes.\n"
"+  Starting from the right, move each key to correct position.\n"
"+  */\n"
"+  for (int32_t i = LEAF_NODE_MAX_CELLS; i >= 0; i--) {\n"
"+    void* destination_node;\n"
"+    if (i >= LEAF_NODE_LEFT_SPLIT_COUNT) {\n"
"+      destination_node = new_node;\n"
"+    } else {\n"
"+      destination_node = old_node;\n"
"+    }\n"
"+    uint32_t index_within_node = i % LEAF_NODE_LEFT_SPLIT_COUNT;\n"
"+    void* destination = leaf_node_cell(destination_node, index_within_node);\n"
"+\n"
"+    if (i == cursor->cell_num) {\n"
"+      serialize_row(value, destination);\n"
"+    } else if (i > cursor->cell_num) {\n"
"+      memcpy(destination, leaf_node_cell(old_node, i - 1), LEAF_NODE_CELL_SIZE);\n"
"+    } else {\n"
"+      memcpy(destination, leaf_node_cell(old_node, i), LEAF_NODE_CELL_SIZE);\n"
"+    }\n"
"+  }\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:95
msgid "Update cell counts in each node's header:"
msgstr ""

#: ../../../_parts/part10.md:97
msgid ""
"```diff\n"
"+  /* Update cell count on both leaf nodes */\n"
"+  *(leaf_node_num_cells(old_node)) = LEAF_NODE_LEFT_SPLIT_COUNT;\n"
"+  *(leaf_node_num_cells(new_node)) = LEAF_NODE_RIGHT_SPLIT_COUNT;\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:103
msgid "Then we need to update the nodes' parent. If the original node was the root, it had no parent. In that case, create a new root node to act as the parent. I'll stub out the other branch for now:"
msgstr ""

#: ../../../_parts/part10.md:105
msgid ""
"```diff\n"
"+  if (is_node_root(old_node)) {\n"
"+    return create_new_root(cursor->table, new_page_num);\n"
"+  } else {\n"
"+    printf(\"Need to implement updating parent after split\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+}\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:115
msgid "## Allocating New Pages"
msgstr ""

#: ../../../_parts/part10.md:117
msgid "Let's go back and define a few new functions and constants. When we created a new leaf node, we put it in a page decided by `get_unused_page_num()`:"
msgstr ""

#: ../../../_parts/part10.md:119
msgid ""
"```diff\n"
"+/*\n"
"+Until we start recycling free pages, new pages will always\n"
"+go onto the end of the database file\n"
"+*/\n"
"+uint32_t get_unused_page_num(Pager* pager) { return pager->num_pages; }\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:127
msgid "For now, we're assuming that in a database with N pages, page numbers 0 through N-1 are allocated. Therefore we can always allocate page number N for new pages. Eventually after we implement deletion, some pages may become empty and their page numbers unused. To be more efficient, we could re-allocate those free pages."
msgstr ""

#: ../../../_parts/part10.md:129
msgid "## Leaf Node Sizes"
msgstr ""

#: ../../../_parts/part10.md:131
msgid "To keep the tree balanced, we evenly distribute cells between the two new nodes. If a leaf node can hold N cells, then during a split we need to distribute N+1 cells between two nodes (N original cells plus one new one). I'm arbitrarily choosing the left node to get one more cell if N+1 is odd."
msgstr ""

#: ../../../_parts/part10.md:133
msgid ""
"```diff\n"
"+const uint32_t LEAF_NODE_RIGHT_SPLIT_COUNT = (LEAF_NODE_MAX_CELLS + 1) / 2;\n"
"+const uint32_t LEAF_NODE_LEFT_SPLIT_COUNT =\n"
"+    (LEAF_NODE_MAX_CELLS + 1) - LEAF_NODE_RIGHT_SPLIT_COUNT;\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:139
msgid "## Creating a New Root"
msgstr ""

#: ../../../_parts/part10.md:141
msgid "Here's how [SQLite Database System](https://play.google.com/store/books/details/Sibsankar_Haldar_SQLite_Database_System_Design_and?id=9Z6IQQnX1JEC&hl=en) explains the process of creating a new root node:"
msgstr ""

#: ../../../_parts/part10.md:143
msgid "> Let N be the root node. First allocate two nodes, say L and R. Move lower half of N into L and the upper half into R. Now N is empty. Add 〈L, K,R〉 in N, where K is the max key in L. Page N remains the root. Note that the depth of the tree has increased by one, but the new tree remains height balanced without violating any B+-tree property."
msgstr ""

#: ../../../_parts/part10.md:145
msgid "At this point, we've already allocated the right child and moved the upper half into it. Our function takes the right child as input and allocates a new page to store the left child."
msgstr ""

#: ../../../_parts/part10.md:147
msgid ""
"```diff\n"
"+void create_new_root(Table* table, uint32_t right_child_page_num) {\n"
"+  /*\n"
"+  Handle splitting the root.\n"
"+  Old root copied to new page, becomes left child.\n"
"+  Address of right child passed in.\n"
"+  Re-initialize root page to contain the new root node.\n"
"+  New root node points to two children.\n"
"+  */\n"
"+\n"
"+  void* root = get_page(table->pager, table->root_page_num);\n"
"+  void* right_child = get_page(table->pager, right_child_page_num);\n"
"+  uint32_t left_child_page_num = get_unused_page_num(table->pager);\n"
"+  void* left_child = get_page(table->pager, left_child_page_num);\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:163
msgid "The old root is copied to the left child so we can reuse the root page:"
msgstr ""

#: ../../../_parts/part10.md:165
msgid ""
"```diff\n"
"+  /* Left child has data copied from old root */\n"
"+  memcpy(left_child, root, PAGE_SIZE);\n"
"+  set_node_root(left_child, false);\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:171
msgid "Finally we initialize the root page as a new internal node with two children."
msgstr ""

#: ../../../_parts/part10.md:173
msgid ""
"```diff\n"
"+  /* Root node is a new internal node with one key and two children */\n"
"+  initialize_internal_node(root);\n"
"+  set_node_root(root, true);\n"
"+  *internal_node_num_keys(root) = 1;\n"
"+  *internal_node_child(root, 0) = left_child_page_num;\n"
"+  uint32_t left_child_max_key = get_node_max_key(left_child);\n"
"+  *internal_node_key(root, 0) = left_child_max_key;\n"
"+  *internal_node_right_child(root) = right_child_page_num;\n"
"+}\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:185
msgid "## Internal Node Format"
msgstr ""

#: ../../../_parts/part10.md:187
msgid "Now that we're finally creating an internal node, we have to define its layout. It starts with the common header, then the number of keys it contains, then the page number of its rightmost child. Internal nodes always have one more child pointer than they have keys. That extra child pointer is stored in the header."
msgstr ""

#: ../../../_parts/part10.md:189
msgid ""
"```diff\n"
"+/*\n"
"+ * Internal Node Header Layout\n"
"+ */\n"
"+const uint32_t INTERNAL_NODE_NUM_KEYS_SIZE = sizeof(uint32_t);\n"
"+const uint32_t INTERNAL_NODE_NUM_KEYS_OFFSET = COMMON_NODE_HEADER_SIZE;\n"
"+const uint32_t INTERNAL_NODE_RIGHT_CHILD_SIZE = sizeof(uint32_t);\n"
"+const uint32_t INTERNAL_NODE_RIGHT_CHILD_OFFSET =\n"
"+    INTERNAL_NODE_NUM_KEYS_OFFSET + INTERNAL_NODE_NUM_KEYS_SIZE;\n"
"+const uint32_t INTERNAL_NODE_HEADER_SIZE = COMMON_NODE_HEADER_SIZE +\n"
"+                                           INTERNAL_NODE_NUM_KEYS_SIZE +\n"
"+                                           INTERNAL_NODE_RIGHT_CHILD_SIZE;\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:203
msgid "The body is an array of cells where each cell contains a child pointer and a key. Every key should be the maximum key contained in the child to its left."
msgstr ""

#: ../../../_parts/part10.md:205
msgid ""
"```diff\n"
"+/*\n"
"+ * Internal Node Body Layout\n"
"+ */\n"
"+const uint32_t INTERNAL_NODE_KEY_SIZE = sizeof(uint32_t);\n"
"+const uint32_t INTERNAL_NODE_CHILD_SIZE = sizeof(uint32_t);\n"
"+const uint32_t INTERNAL_NODE_CELL_SIZE =\n"
"+    INTERNAL_NODE_CHILD_SIZE + INTERNAL_NODE_KEY_SIZE;\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:215
msgid "Based on these constants, here's how the layout of an internal node will look:"
msgstr ""

#: ../../../_parts/part10.md:217
msgid "{% include image.html url=\"assets/images/internal-node-format.png\" description=\"Our internal node format\" %}"
msgstr ""

#: ../../../_parts/part10.md:219
msgid "Notice our huge branching factor. Because each child pointer / key pair is so small, we can fit 510 keys and 511 child pointers in each internal node. That means we'll never have to traverse many layers of the tree to find a given key!"
msgstr ""

#: ../../../_parts/part10.md:221
msgid ""
"| # internal node layers | max # leaf nodes    | Size of all leaf nodes |\n"
"|------------------------|---------------------|------------------------|\n"
"| 0                      | 511^0 = 1           | 4 KB                   |\n"
"| 1                      | 511^1 = 512         | ~2 MB                   |\n"
"| 2                      | 511^2 = 261,121     | ~1 GB                   |\n"
"| 3                      | 511^3 = 133,432,831 | ~550 GB                 |"
msgstr ""

#: ../../../_parts/part10.md:228
msgid "In actuality, we can't store a full 4 KB of data per leaf node due to the overhead of the header, keys, and wasted space. But we can search through something like 500 GB of data by loading only 4 pages from disk. This is why the B-Tree is a useful data structure for databases."
msgstr ""

#: ../../../_parts/part10.md:230
msgid "Here are the methods for reading and writing to an internal node:"
msgstr ""

#: ../../../_parts/part10.md:232
msgid ""
"```diff\n"
"+uint32_t* internal_node_num_keys(void* node) {\n"
"+  return node + INTERNAL_NODE_NUM_KEYS_OFFSET;\n"
"+}\n"
"+\n"
"+uint32_t* internal_node_right_child(void* node) {\n"
"+  return node + INTERNAL_NODE_RIGHT_CHILD_OFFSET;\n"
"+}\n"
"+\n"
"+uint32_t* internal_node_cell(void* node, uint32_t cell_num) {\n"
"+  return node + INTERNAL_NODE_HEADER_SIZE + cell_num * INTERNAL_NODE_CELL_SIZE;\n"
"+}\n"
"+\n"
"+uint32_t* internal_node_child(void* node, uint32_t child_num) {\n"
"+  uint32_t num_keys = *internal_node_num_keys(node);\n"
"+  if (child_num > num_keys) {\n"
"+    printf(\"Tried to access child_num %d > num_keys %d\n"
"\", child_num, num_keys);\n"
"+    exit(EXIT_FAILURE);\n"
"+  } else if (child_num == num_keys) {\n"
"+    return internal_node_right_child(node);\n"
"+  } else {\n"
"+    return internal_node_cell(node, child_num);\n"
"+  }\n"
"+}\n"
"+\n"
"+uint32_t* internal_node_key(void* node, uint32_t key_num) {\n"
"+  return internal_node_cell(node, key_num) + INTERNAL_NODE_CHILD_SIZE;\n"
"+}\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:262
msgid "For an internal node, the maximum key is always its right key. For a leaf node, it's the key at the maximum index:"
msgstr ""

#: ../../../_parts/part10.md:264
msgid ""
"```diff\n"
"+uint32_t get_node_max_key(void* node) {\n"
"+  switch (get_node_type(node)) {\n"
"+    case NODE_INTERNAL:\n"
"+      return *internal_node_key(node, *internal_node_num_keys(node) - 1);\n"
"+    case NODE_LEAF:\n"
"+      return *leaf_node_key(node, *leaf_node_num_cells(node) - 1);\n"
"+  }\n"
"+}\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:275
msgid "## Keeping Track of the Root"
msgstr ""

#: ../../../_parts/part10.md:277
msgid "We're finally using the `is_root` field in the common node header. Recall that we use it to decide how to split a leaf node:"
msgstr ""

#: ../../../_parts/part10.md:279
msgid ""
"```c\n"
"  if (is_node_root(old_node)) {\n"
"    return create_new_root(cursor->table, new_page_num);\n"
"  } else {\n"
"    printf(\"Need to implement updating parent after split\n"
"\");\n"
"    exit(EXIT_FAILURE);\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:289
msgid "Here are the getter and setter:"
msgstr ""

#: ../../../_parts/part10.md:291
msgid ""
"```diff\n"
"+bool is_node_root(void* node) {\n"
"+  uint8_t value = *((uint8_t*)(node + IS_ROOT_OFFSET));\n"
"+  return (bool)value;\n"
"+}\n"
"+\n"
"+void set_node_root(void* node, bool is_root) {\n"
"+  uint8_t value = is_root;\n"
"+  *((uint8_t*)(node + IS_ROOT_OFFSET)) = value;\n"
"+}\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:304
msgid "Initializing both types of nodes should default to setting `is_root` to false:"
msgstr ""

#: ../../../_parts/part10.md:306
msgid ""
"```diff\n"
" void initialize_leaf_node(void* node) {\n"
"   set_node_type(node, NODE_LEAF);\n"
"+  set_node_root(node, false);\n"
"   *leaf_node_num_cells(node) = 0;\n"
" }"
msgstr ""

#: ../../../_parts/part10.md:313
msgid ""
"+void initialize_internal_node(void* node) {\n"
"+  set_node_type(node, NODE_INTERNAL);\n"
"+  set_node_root(node, false);\n"
"+  *internal_node_num_keys(node) = 0;\n"
"+}\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:320
msgid "We should set `is_root` to true when creating the first node of the table:"
msgstr ""

#: ../../../_parts/part10.md:322
msgid ""
"```diff\n"
"     // New database file. Initialize page 0 as leaf node.\n"
"     void* root_node = get_page(pager, 0);\n"
"     initialize_leaf_node(root_node);\n"
"+    set_node_root(root_node, true);\n"
"   }"
msgstr ""

#: ../../../_parts/part10.md:329
msgid ""
"   return table;\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:332
msgid "## Printing the Tree"
msgstr ""

#: ../../../_parts/part10.md:334
msgid "To help us visualize the state of the database, we should update our `.btree` metacommand to print a multi-level tree."
msgstr ""

#: ../../../_parts/part10.md:336
msgid "I'm going to replace the current `print_leaf_node()` function"
msgstr ""

#: ../../../_parts/part10.md:338
msgid ""
"```diff\n"
"-void print_leaf_node(void* node) {\n"
"-  uint32_t num_cells = *leaf_node_num_cells(node);\n"
"-  printf(\"leaf (size %d)\n"
"\", num_cells);\n"
"-  for (uint32_t i = 0; i < num_cells; i++) {\n"
"-    uint32_t key = *leaf_node_key(node, i);\n"
"-    printf(\"  - %d : %d\n"
"\", i, key);\n"
"-  }\n"
"-}\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:349
msgid "with a new recursive function that takes any node, then prints it and its children. It takes an indentation level as a parameter, which increases with each recursive call. I'm also adding a tiny helper function to indent."
msgstr ""

#: ../../../_parts/part10.md:351
msgid ""
"```diff\n"
"+void indent(uint32_t level) {\n"
"+  for (uint32_t i = 0; i < level; i++) {\n"
"+    printf(\"  \");\n"
"+  }\n"
"+}\n"
"+\n"
"+void print_tree(Pager* pager, uint32_t page_num, uint32_t indentation_level) {\n"
"+  void* node = get_page(pager, page_num);\n"
"+  uint32_t num_keys, child;\n"
"+\n"
"+  switch (get_node_type(node)) {\n"
"+    case (NODE_LEAF):\n"
"+      num_keys = *leaf_node_num_cells(node);\n"
"+      indent(indentation_level);\n"
"+      printf(\"- leaf (size %d)\n"
"\", num_keys);\n"
"+      for (uint32_t i = 0; i < num_keys; i++) {\n"
"+        indent(indentation_level + 1);\n"
"+        printf(\"- %d\n"
"\", *leaf_node_key(node, i));\n"
"+      }\n"
"+      break;\n"
"+    case (NODE_INTERNAL):\n"
"+      num_keys = *internal_node_num_keys(node);\n"
"+      indent(indentation_level);\n"
"+      printf(\"- internal (size %d)\n"
"\", num_keys);\n"
"+      for (uint32_t i = 0; i < num_keys; i++) {\n"
"+        child = *internal_node_child(node, i);\n"
"+        print_tree(pager, child, indentation_level + 1);\n"
"+\n"
"+        indent(indentation_level + 1);\n"
"+        printf(\"- key %d\n"
"\", *internal_node_key(node, i));\n"
"+      }\n"
"+      child = *internal_node_right_child(node);\n"
"+      print_tree(pager, child, indentation_level + 1);\n"
"+      break;\n"
"+  }\n"
"+}\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:390
msgid "And update the call to the print function, passing an indentation level of zero."
msgstr ""

#: ../../../_parts/part10.md:392
msgid ""
"```diff\n"
"   } else if (strcmp(input_buffer->buffer, \".btree\") == 0) {\n"
"     printf(\"Tree:\n"
"\");\n"
"-    print_leaf_node(get_page(table->pager, 0));\n"
"+    print_tree(table->pager, 0, 0);\n"
"     return META_COMMAND_SUCCESS;\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:400
msgid "Here's a test case for the new printing functionality!"
msgstr ""

#: ../../../_parts/part10.md:402
msgid ""
"```diff\n"
"+  it 'allows printing out the structure of a 3-leaf-node btree' do\n"
"+    script = (1..14).map do |i|\n"
"+      \"insert #{i} user#{i} person#{i}@example.com\"\n"
"+    end\n"
"+    script << \".btree\"\n"
"+    script << \"insert 15 user15 person15@example.com\"\n"
"+    script << \".exit\"\n"
"+    result = run_script(script)\n"
"+\n"
"+    expect(result[14...(result.length)]).to match_array([\n"
"+      \"db > Tree:\",\n"
"+      \"- internal (size 1)\",\n"
"+      \"  - leaf (size 7)\",\n"
"+      \"    - 1\",\n"
"+      \"    - 2\",\n"
"+      \"    - 3\",\n"
"+      \"    - 4\",\n"
"+      \"    - 5\",\n"
"+      \"    - 6\",\n"
"+      \"    - 7\",\n"
"+      \"  - key 7\",\n"
"+      \"  - leaf (size 7)\",\n"
"+      \"    - 8\",\n"
"+      \"    - 9\",\n"
"+      \"    - 10\",\n"
"+      \"    - 11\",\n"
"+      \"    - 12\",\n"
"+      \"    - 13\",\n"
"+      \"    - 14\",\n"
"+      \"db > Need to implement searching an internal node\",\n"
"+    ])\n"
"+  end\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:437
msgid "The new format is a little simplified, so we need to update the existing `.btree` test:"
msgstr ""

#: ../../../_parts/part10.md:439
msgid ""
"```diff\n"
"       \"db > Executed.\",\n"
"       \"db > Executed.\",\n"
"       \"db > Tree:\",\n"
"-      \"leaf (size 3)\",\n"
"-      \"  - 0 : 1\",\n"
"-      \"  - 1 : 2\",\n"
"-      \"  - 2 : 3\",\n"
"+      \"- leaf (size 3)\",\n"
"+      \"  - 1\",\n"
"+      \"  - 2\",\n"
"+      \"  - 3\",\n"
"       \"db > \"\n"
"     ])\n"
"   end\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:456
msgid "Here's the `.btree` output of the new test on its own:"
msgstr ""

#: ../../../_parts/part10.md:458
msgid ""
"```\n"
"Tree:\n"
"- internal (size 1)\n"
"  - leaf (size 7)\n"
"    - 1\n"
"    - 2\n"
"    - 3\n"
"    - 4\n"
"    - 5\n"
"    - 6\n"
"    - 7\n"
"  - key 7\n"
"  - leaf (size 7)\n"
"    - 8\n"
"    - 9\n"
"    - 10\n"
"    - 11\n"
"    - 12\n"
"    - 13\n"
"    - 14\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:480
msgid "On the least indented level, we see the root node (an internal node). It says `size 1` because it has one key. Indented one level, we see a leaf node, a key, and another leaf node. The key in the root node (7) is is the maximum key in the first leaf node. Every key greater than 7 is in the second leaf node."
msgstr ""

#: ../../../_parts/part10.md:482
msgid "## A Major Problem"
msgstr ""

#: ../../../_parts/part10.md:484
msgid "If you've been following along closely you may notice we've missed something big. Look what happens if we try to insert one additional row:"
msgstr ""

#: ../../../_parts/part10.md:486
msgid ""
"```\n"
"db > insert 15 user15 person15@example.com\n"
"Need to implement searching an internal node\n"
"```"
msgstr ""

#: ../../../_parts/part10.md:491
msgid "Whoops! Who wrote that TODO message? :P"
msgstr ""

#: ../../../_parts/part10.md:493
msgid "Next time we'll continue the epic B-tree saga by implementing search on a multi-level tree."
msgstr ""
