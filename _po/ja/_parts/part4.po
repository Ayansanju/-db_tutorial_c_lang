msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=; plural=;\n"

msgid ""
"---\n"
"title: Part 4 - Our First Tests (and Bugs)\n"
"date: 2017-09-03\n"
"---"
msgstr ""

msgid ""
"We've got the ability to insert rows into our database and to print out all ro"
"ws. Let's take a moment to test what we've got so far."
msgstr ""

msgid ""
"I'm going to use [rspec](http://rspec.info/) to write my tests because I'm fam"
"iliar with it, and the syntax is fairly readable."
msgstr ""

msgid ""
"I'll define a short helper to send a list of commands to our database program "
"then make assertions about the output:"
msgstr ""

msgid ""
"```ruby\n"
"describe 'database' do\n"
"  def run_script(commands)\n"
"    raw_output = nil\n"
"    IO.popen(\"./db\", \"r+\") do |pipe|\n"
"      commands.each do |command|\n"
"        pipe.puts command\n"
"      end"
msgstr ""

msgid "      pipe.close_write"
msgstr ""

msgid ""
"      # Read entire output\n"
"      raw_output = pipe.gets(nil)\n"
"    end\n"
"    raw_output.split(\"\n"
"\")\n"
"  end"
msgstr ""

msgid ""
"  it 'inserts and retrieves a row' do\n"
"    result = run_script([\n"
"      \"insert 1 user1 person1@example.com\",\n"
"      \"select\",\n"
"      \".exit\",\n"
"    ])\n"
"    expect(result).to match_array([\n"
"      \"db > Executed.\",\n"
"      \"db > (1, user1, person1@example.com)\",\n"
"      \"Executed.\",\n"
"      \"db > \",\n"
"    ])\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"This simple test makes sure we get back what we put in. And indeed it passes:\n"
"```command-line\n"
"bundle exec rspec\n"
"."
msgstr ""

msgid ""
"Finished in 0.00871 seconds (files took 0.09506 seconds to load)\n"
"1 example, 0 failures\n"
"```"
msgstr ""

msgid ""
"Now it's feasible to test inserting a large number of rows into the database:\n"
"```ruby\n"
"it 'prints error message when table is full' do\n"
"  script = (1..1401).map do |i|\n"
"    \"insert #{i} user#{i} person#{i}@example.com\"\n"
"  end\n"
"  script << \".exit\"\n"
"  result = run_script(script)\n"
"  expect(result[-2]).to eq('db > Error: Table full.')\n"
"end\n"
"```"
msgstr ""

msgid ""
"Running tests again...\n"
"```command-line\n"
"bundle exec rspec\n"
".."
msgstr ""

msgid ""
"Finished in 0.01553 seconds (files took 0.08156 seconds to load)\n"
"2 examples, 0 failures\n"
"```"
msgstr ""

msgid ""
"Sweet, it works! Our db can hold 1400 rows right now because we set the maximu"
"m number of pages to 100, and 14 rows can fit in a page."
msgstr ""

msgid ""
"Reading through the code we have so far, I realized we might not handle storin"
"g text fields correctly. Easy to test with this example:\n"
"```ruby\n"
"it 'allows inserting strings that are the maximum length' do\n"
"  long_username = \"a\"*32\n"
"  long_email = \"a\"*255\n"
"  script = [\n"
"    \"insert 1 #{long_username} #{long_email}\",\n"
"    \"select\",\n"
"    \".exit\",\n"
"  ]\n"
"  result = run_script(script)\n"
"  expect(result).to match_array([\n"
"    \"db > Executed.\",\n"
"    \"db > (1, #{long_username}, #{long_email})\",\n"
"    \"Executed.\",\n"
"    \"db > \",\n"
"  ])\n"
"end\n"
"```"
msgstr ""

msgid ""
"And the test fails!\n"
"```ruby\n"
"Failures:"
msgstr ""

msgid ""
"  1) database allows inserting strings that are the maximum length\n"
"     Failure/Error: raw_output.split(\"\n"
"\")"
msgstr ""

msgid ""
"     ArgumentError:\n"
"       invalid byte sequence in UTF-8\n"
"     # ./spec/main_spec.rb:14:in `split'\n"
"     # ./spec/main_spec.rb:14:in `run_script'\n"
"     # ./spec/main_spec.rb:48:in `block (2 levels) in <top (required)>'\n"
"```"
msgstr ""

msgid ""
"If we try it ourselves, we'll see that there's some weird characters when we t"
"ry to print out the row. (I'm abbreviating the long strings):\n"
"```command-line\n"
"db > insert 1 aaaaa... aaaaa...\n"
"Executed.\n"
"db > select\n"
"(1, aaaaa...aaa\\�, aaaaa...aaa\\�)\n"
"Executed.\n"
"db >\n"
"```"
msgstr ""

msgid ""
"What's going on? If you take a look at our definition of a Row, we allocate ex"
"actly 32 bytes for username and exactly 255 bytes for email. But [C strings](h"
"ttp://www.cprogramming.com/tutorial/c/lesson9.html) are supposed to end with a"
" null character, which we didn't allocate space for. The solution is to alloca"
"te one additional byte:\n"
"```diff\n"
" const uint32_t COLUMN_EMAIL_SIZE = 255;\n"
" typedef struct {\n"
"   uint32_t id;\n"
"-  char username[COLUMN_USERNAME_SIZE];\n"
"-  char email[COLUMN_EMAIL_SIZE];\n"
"+  char username[COLUMN_USERNAME_SIZE + 1];\n"
"+  char email[COLUMN_EMAIL_SIZE + 1];\n"
" } Row;\n"
" ```"
msgstr ""

msgid ""
" And indeed that fixes it:\n"
" ```ruby\n"
" bundle exec rspec\n"
"..."
msgstr ""

msgid ""
"Finished in 0.0188 seconds (files took 0.08516 seconds to load)\n"
"3 examples, 0 failures\n"
"```"
msgstr ""

msgid ""
"We should not allow inserting usernames or emails that are longer than column "
"size. The spec for that looks like this:\n"
"```ruby\n"
"it 'prints error message if strings are too long' do\n"
"  long_username = \"a\"*33\n"
"  long_email = \"a\"*256\n"
"  script = [\n"
"    \"insert 1 #{long_username} #{long_email}\",\n"
"    \"select\",\n"
"    \".exit\",\n"
"  ]\n"
"  result = run_script(script)\n"
"  expect(result).to match_array([\n"
"    \"db > String is too long.\",\n"
"    \"db > Executed.\",\n"
"    \"db > \",\n"
"  ])\n"
"end\n"
"```"
msgstr ""

msgid ""
"In order to do this we need to upgrade our parser. As a reminder, we're curren"
"tly using [scanf()](https://linux.die.net/man/3/scanf):\n"
"```c\n"
"if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n"
"  statement->type = STATEMENT_INSERT;\n"
"  int args_assigned = sscanf(\n"
"      input_buffer->buffer, \"insert %d %s %s\", &(statement->row_to_insert.id),"
"\n"
"      statement->row_to_insert.username, statement->row_to_insert.email);\n"
"  if (args_assigned < 3) {\n"
"    return PREPARE_SYNTAX_ERROR;\n"
"  }\n"
"  return PREPARE_SUCCESS;\n"
"}\n"
"```"
msgstr ""

msgid ""
"But [scanf has some disadvantages](https://stackoverflow.com/questions/2430303"
"/disadvantages-of-scanf). If the string it's reading is larger than the buffer"
" it's reading into, it will cause a buffer overflow and start writing into une"
"xpected places. We want to check the length of each string before we copy it i"
"nto a `Row` structure. And to do that, we need to divide the input by spaces."
msgstr ""

msgid ""
"I'm going to use [strtok()](http://www.cplusplus.com/reference/cstring/strtok/"
") to do that. I think it's easiest to understand if you see it in action:"
msgstr ""

msgid ""
"```diff\n"
"+PrepareResult prepare_insert(InputBuffer* input_buffer, Statement* statement)"
" {\n"
"+  statement->type = STATEMENT_INSERT;\n"
"+\n"
"+  char* keyword = strtok(input_buffer->buffer, \" \");\n"
"+  char* id_string = strtok(NULL, \" \");\n"
"+  char* username = strtok(NULL, \" \");\n"
"+  char* email = strtok(NULL, \" \");\n"
"+\n"
"+  if (id_string == NULL || username == NULL || email == NULL) {\n"
"+    return PREPARE_SYNTAX_ERROR;\n"
"+  }\n"
"+\n"
"+  int id = atoi(id_string);\n"
"+  if (strlen(username) > COLUMN_USERNAME_SIZE) {\n"
"+    return PREPARE_STRING_TOO_LONG;\n"
"+  }\n"
"+  if (strlen(email) > COLUMN_EMAIL_SIZE) {\n"
"+    return PREPARE_STRING_TOO_LONG;\n"
"+  }\n"
"+\n"
"+  statement->row_to_insert.id = id;\n"
"+  strcpy(statement->row_to_insert.username, username);\n"
"+  strcpy(statement->row_to_insert.email, email);\n"
"+\n"
"+  return PREPARE_SUCCESS;\n"
"+}\n"
"+\n"
" PrepareResult prepare_statement(InputBuffer* input_buffer,\n"
"                                 Statement* statement) {\n"
"   if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n"
"+    return prepare_insert(input_buffer, statement);\n"
"-    statement->type = STATEMENT_INSERT;\n"
"-    int args_assigned = sscanf(\n"
"-        input_buffer->buffer, \"insert %d %s %s\", &(statement->row_to_insert.i"
"d),\n"
"-        statement->row_to_insert.username, statement->row_to_insert.email);\n"
"-    if (args_assigned < 3) {\n"
"-      return PREPARE_SYNTAX_ERROR;\n"
"-    }\n"
"-    return PREPARE_SUCCESS;\n"
"   }\n"
"```"
msgstr ""

msgid ""
"Calling `strtok` successively on the input buffer breaks it into substrings by"
" inserting a null character whenever it reaches a delimiter (space, in our cas"
"e). It returns a pointer to the start of the substring."
msgstr ""

msgid ""
"We can call [strlen()](http://www.cplusplus.com/reference/cstring/strlen/) on "
"each text value to see if it's too long."
msgstr ""

msgid ""
"We can handle the error like we do any other error code:\n"
"```diff\n"
" enum PrepareResult_t {\n"
"   PREPARE_SUCCESS,\n"
"+  PREPARE_STRING_TOO_LONG,\n"
"   PREPARE_SYNTAX_ERROR,\n"
"   PREPARE_UNRECOGNIZED_STATEMENT\n"
" };\n"
"```\n"
"```diff\n"
" switch (prepare_statement(input_buffer, &statement)) {\n"
"   case (PREPARE_SUCCESS):\n"
"     break;\n"
"+  case (PREPARE_STRING_TOO_LONG):\n"
"+    printf(\"String is too long.\n"
"\");\n"
"+    continue;\n"
"   case (PREPARE_SYNTAX_ERROR):\n"
"     printf(\"Syntax error. Could not parse statement.\n"
"\");\n"
"     continue;\n"
"```"
msgstr ""

msgid ""
"Which makes our test pass\n"
"```command-line\n"
"bundle exec rspec\n"
"...."
msgstr ""

msgid ""
"Finished in 0.02284 seconds (files took 0.116 seconds to load)\n"
"4 examples, 0 failures\n"
"```"
msgstr ""

msgid ""
"While we're here, we might as well handle one more error case:\n"
"```ruby\n"
"it 'prints an error message if id is negative' do\n"
"  script = [\n"
"    \"insert -1 cstack foo@bar.com\",\n"
"    \"select\",\n"
"    \".exit\",\n"
"  ]\n"
"  result = run_script(script)\n"
"  expect(result).to match_array([\n"
"    \"db > ID must be positive.\",\n"
"    \"db > Executed.\",\n"
"    \"db > \",\n"
"  ])\n"
"end\n"
"```\n"
"```diff\n"
" enum PrepareResult_t {\n"
"   PREPARE_SUCCESS,\n"
"+  PREPARE_NEGATIVE_ID,\n"
"   PREPARE_STRING_TOO_LONG,\n"
"   PREPARE_SYNTAX_ERROR,\n"
"   PREPARE_UNRECOGNIZED_STATEMENT\n"
"@@ -148,9 +147,6 @@ PrepareResult prepare_insert(InputBuffer* input_buffer, St"
"atement* statement) {\n"
"   }"
msgstr ""

msgid ""
"   int id = atoi(id_string);\n"
"+  if (id < 0) {\n"
"+    return PREPARE_NEGATIVE_ID;\n"
"+  }\n"
"   if (strlen(username) > COLUMN_USERNAME_SIZE) {\n"
"     return PREPARE_STRING_TOO_LONG;\n"
"   }\n"
"@@ -230,9 +226,6 @@ int main(int argc, char* argv[]) {\n"
"     switch (prepare_statement(input_buffer, &statement)) {\n"
"       case (PREPARE_SUCCESS):\n"
"         break;\n"
"+      case (PREPARE_NEGATIVE_ID):\n"
"+        printf(\"ID must be positive.\n"
"\");\n"
"+        continue;\n"
"       case (PREPARE_STRING_TOO_LONG):\n"
"         printf(\"String is too long.\n"
"\");\n"
"         continue;\n"
"```"
msgstr ""

msgid ""
"Alright, that's enough testing for now. Next is a very important feature: pers"
"istence! We're going to save our database to a file and read it back out again"
"."
msgstr ""

msgid "It's gonna be great."
msgstr ""

msgid ""
"Here's the complete diff for this part:\n"
"```diff\n"
"@@ -22,6 +22,8 @@"
msgstr ""

msgid ""
" enum PrepareResult_t {\n"
"   PREPARE_SUCCESS,\n"
"+  PREPARE_NEGATIVE_ID,\n"
"+  PREPARE_STRING_TOO_LONG,\n"
"   PREPARE_SYNTAX_ERROR,\n"
"   PREPARE_UNRECOGNIZED_STATEMENT\n"
"  };\n"
"@@ -34,8 +36,8 @@\n"
" #define COLUMN_EMAIL_SIZE 255\n"
" typedef struct {\n"
"   uint32_t id;\n"
"-  char username[COLUMN_USERNAME_SIZE];\n"
"-  char email[COLUMN_EMAIL_SIZE];\n"
"+  char username[COLUMN_USERNAME_SIZE + 1];\n"
"+  char email[COLUMN_EMAIL_SIZE + 1];\n"
" } Row;"
msgstr ""

msgid ""
"@@ -150,18 +152,40 @@ MetaCommandResult do_meta_command(InputBuffer* input_buf"
"fer, Table *table) {\n"
"   }\n"
" }"
msgstr ""

msgid ""
"-PrepareResult prepare_statement(InputBuffer* input_buffer,\n"
"-                                Statement* statement) {\n"
"-  if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n"
"+PrepareResult prepare_insert(InputBuffer* input_buffer, Statement* statement)"
" {\n"
"   statement->type = STATEMENT_INSERT;\n"
"-  int args_assigned = sscanf(\n"
"-     input_buffer->buffer, \"insert %d %s %s\", &(statement->row_to_insert.id),"
"\n"
"-     statement->row_to_insert.username, statement->row_to_insert.email\n"
"-     );\n"
"-  if (args_assigned < 3) {\n"
"+\n"
"+  char* keyword = strtok(input_buffer->buffer, \" \");\n"
"+  char* id_string = strtok(NULL, \" \");\n"
"+  char* username = strtok(NULL, \" \");\n"
"+  char* email = strtok(NULL, \" \");\n"
"+\n"
"+  if (id_string == NULL || username == NULL || email == NULL) {\n"
"      return PREPARE_SYNTAX_ERROR;\n"
"   }\n"
"+\n"
"+  int id = atoi(id_string);\n"
"+  if (id < 0) {\n"
"+     return PREPARE_NEGATIVE_ID;\n"
"+  }\n"
"+  if (strlen(username) > COLUMN_USERNAME_SIZE) {\n"
"+     return PREPARE_STRING_TOO_LONG;\n"
"+  }\n"
"+  if (strlen(email) > COLUMN_EMAIL_SIZE) {\n"
"+     return PREPARE_STRING_TOO_LONG;\n"
"+  }\n"
"+\n"
"+  statement->row_to_insert.id = id;\n"
"+  strcpy(statement->row_to_insert.username, username);\n"
"+  strcpy(statement->row_to_insert.email, email);\n"
"+\n"
"   return PREPARE_SUCCESS;\n"
"+\n"
"+}\n"
"+PrepareResult prepare_statement(InputBuffer* input_buffer,\n"
"+                                Statement* statement) {\n"
"+  if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n"
"+      return prepare_insert(input_buffer, statement);\n"
"   }\n"
"   if (strcmp(input_buffer->buffer, \"select\") == 0) {\n"
"     statement->type = STATEMENT_SELECT;\n"
"@@ -223,6 +247,12 @@ int main(int argc, char* argv[]) {\n"
"     switch (prepare_statement(input_buffer, &statement)) {\n"
"       case (PREPARE_SUCCESS):\n"
"         break;\n"
"+      case (PREPARE_NEGATIVE_ID):\n"
"+\tprintf(\"ID must be positive.\n"
"\");\n"
"+\tcontinue;\n"
"+      case (PREPARE_STRING_TOO_LONG):\n"
"+\tprintf(\"String is too long.\n"
"\");\n"
"+\tcontinue;\n"
"       case (PREPARE_SYNTAX_ERROR):\n"
" \tprintf(\"Syntax error. Could not parse statement.\n"
"\");\n"
" \tcontinue;\n"
"```\n"
"And we added tests:\n"
"```diff\n"
"+describe 'database' do\n"
"+  def run_script(commands)\n"
"+    raw_output = nil\n"
"+    IO.popen(\"./db\", \"r+\") do |pipe|\n"
"+      commands.each do |command|\n"
"+        pipe.puts command\n"
"+      end\n"
"+\n"
"+      pipe.close_write\n"
"+\n"
"+      # Read entire output\n"
"+      raw_output = pipe.gets(nil)\n"
"+    end\n"
"+    raw_output.split(\"\n"
"\")\n"
"+  end\n"
"+\n"
"+  it 'inserts and retrieves a row' do\n"
"+    result = run_script([\n"
"+      \"insert 1 user1 person1@example.com\",\n"
"+      \"select\",\n"
"+      \".exit\",\n"
"+    ])\n"
"+    expect(result).to match_array([\n"
"+      \"db > Executed.\",\n"
"+      \"db > (1, user1, person1@example.com)\",\n"
"+      \"Executed.\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
"+\n"
"+  it 'prints error message when table is full' do\n"
"+    script = (1..1401).map do |i|\n"
"+      \"insert #{i} user#{i} person#{i}@example.com\"\n"
"+    end\n"
"+    script << \".exit\"\n"
"+    result = run_script(script)\n"
"+    expect(result[-2]).to eq('db > Error: Table full.')\n"
"+  end\n"
"+\n"
"+  it 'allows inserting strings that are the maximum length' do\n"
"+    long_username = \"a\"*32\n"
"+    long_email = \"a\"*255\n"
"+    script = [\n"
"+      \"insert 1 #{long_username} #{long_email}\",\n"
"+      \"select\",\n"
"+      \".exit\",\n"
"+    ]\n"
"+    result = run_script(script)\n"
"+    expect(result).to match_array([\n"
"+      \"db > Executed.\",\n"
"+      \"db > (1, #{long_username}, #{long_email})\",\n"
"+      \"Executed.\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
"+\n"
"+  it 'prints error message if strings are too long' do\n"
"+    long_username = \"a\"*33\n"
"+    long_email = \"a\"*256\n"
"+    script = [\n"
"+      \"insert 1 #{long_username} #{long_email}\",\n"
"+      \"select\",\n"
"+      \".exit\",\n"
"+    ]\n"
"+    result = run_script(script)\n"
"+    expect(result).to match_array([\n"
"+      \"db > String is too long.\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
"+\n"
"+  it 'prints an error message if id is negative' do\n"
"+    script = [\n"
"+      \"insert -1 cstack foo@bar.com\",\n"
"+      \"select\",\n"
"+      \".exit\",\n"
"+    ]\n"
"+    result = run_script(script)\n"
"+    expect(result).to match_array([\n"
"+      \"db > ID must be positive.\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
"+end\n"
"```"
msgstr ""
