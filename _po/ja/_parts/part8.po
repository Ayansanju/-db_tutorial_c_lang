msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=; plural=;\n"

msgid ""
"---\n"
"title: Part 8 - B-Tree Leaf Node Format\n"
"date: 2017-09-25\n"
"---"
msgstr ""

msgid ""
"We're changing the format of our table from an unsorted array of rows to a B-T"
"ree. This is a pretty big change that is going to take multiple articles to im"
"plement. By the end of this article, we'll define the layout of a leaf node an"
"d support inserting key/value pairs into a single-node tree. But first, let's "
"recap the reasons for switching to a tree structure."
msgstr ""

msgid "## Alternative Table Formats"
msgstr ""

msgid ""
"With the current format, each page stores only rows (no metadata) so it is pre"
"tty space efficient. Insertion is also fast because we just append to the end."
" However, finding a particular row can only be done by scanning the entire tab"
"le. And if we want to delete a row, we have to fill in the hole by moving ever"
"y row that comes after it."
msgstr ""

msgid ""
"If we stored the table as an array, but kept rows sorted by id, we could use b"
"inary search to find a particular id. However, insertion would be slow because"
" we would have to move a lot of rows to make space."
msgstr ""

msgid ""
"Instead, we're going with a tree structure. Each node in the tree can contain "
"a variable number of rows, so we have to store some information in each node t"
"o keep track of how many rows it contains. Plus there is the storage overhead "
"of all the internal nodes which don't store any rows. In exchange for a larger"
" database file, we get fast insertion, deletion and lookup."
msgstr ""

msgid ""
"|               | Unsorted Array of rows | Sorted Array of rows | Tree of node"
"s |\n"
"|---------------|------------------------|----------------------|-------------"
"--|\n"
"| Pages contain | only data              | only data            | metadata, pr"
"imary keys, and data              |\n"
"| Rows per page | more                   | more                 | fewer       "
"  |\n"
"| Insertion     | O(1)                   | O(n)                 | O(log(n))   "
"  |\n"
"| Deletion      | O(n)                   | O(n)                 | O(log(n))   "
"  |\n"
"| Lookup by id  | O(n)                   | O(log(n))            | O(log(n))   "
"  |"
msgstr ""

msgid "## Node Header Format"
msgstr ""

msgid ""
"Leaf nodes and internal nodes have different layouts. Let's make an enum to ke"
"ep track of node type:"
msgstr ""

msgid ""
"```diff\n"
"+typedef enum { NODE_INTERNAL, NODE_LEAF } NodeType;\n"
"```"
msgstr ""

msgid ""
"Each node will correspond to one page. Internal nodes will point to their chil"
"dren by storing the page number that stores the child. The btree asks the page"
"r for a particular page number and gets back a pointer into the page cache. Pa"
"ges are stored in the database file one after the other in order of page numbe"
"r."
msgstr ""

msgid ""
"Nodes need to store some metadata in a header at the beginning of the page. Ev"
"ery node will store what type of node it is, whether or not it is the root nod"
"e, and a pointer to its parent (to allow finding a node's siblings). I define "
"constants for the size and offset of every header field:"
msgstr ""

msgid ""
"```diff\n"
"+/*\n"
"+ * Common Node Header Layout\n"
"+ */\n"
"+const uint32_t NODE_TYPE_SIZE = sizeof(uint8_t);\n"
"+const uint32_t NODE_TYPE_OFFSET = 0;\n"
"+const uint32_t IS_ROOT_SIZE = sizeof(uint8_t);\n"
"+const uint32_t IS_ROOT_OFFSET = NODE_TYPE_SIZE;\n"
"+const uint32_t PARENT_POINTER_SIZE = sizeof(uint32_t);\n"
"+const uint32_t PARENT_POINTER_OFFSET = IS_ROOT_OFFSET + IS_ROOT_SIZE;\n"
"+const uint8_t COMMON_NODE_HEADER_SIZE =\n"
"+    NODE_TYPE_SIZE + IS_ROOT_SIZE + PARENT_POINTER_SIZE;\n"
"```"
msgstr ""

msgid "## Leaf Node Format"
msgstr ""

msgid ""
"In addition to these common header fields, leaf nodes need to store how many \""
"cells\" they contain. A cell is a key/value pair."
msgstr ""

msgid ""
"```diff\n"
"+/*\n"
"+ * Leaf Node Header Layout\n"
"+ */\n"
"+const uint32_t LEAF_NODE_NUM_CELLS_SIZE = sizeof(uint32_t);\n"
"+const uint32_t LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;\n"
"+const uint32_t LEAF_NODE_HEADER_SIZE =\n"
"+    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;\n"
"```"
msgstr ""

msgid ""
"The body of a leaf node is an array of cells. Each cell is a key followed by a"
" value (a serialized row)."
msgstr ""

msgid ""
"```diff\n"
"+/*\n"
"+ * Leaf Node Body Layout\n"
"+ */\n"
"+const uint32_t LEAF_NODE_KEY_SIZE = sizeof(uint32_t);\n"
"+const uint32_t LEAF_NODE_KEY_OFFSET = 0;\n"
"+const uint32_t LEAF_NODE_VALUE_SIZE = ROW_SIZE;\n"
"+const uint32_t LEAF_NODE_VALUE_OFFSET =\n"
"+    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;\n"
"+const uint32_t LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZ"
"E;\n"
"+const uint32_t LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;"
"\n"
"+const uint32_t LEAF_NODE_MAX_CELLS =\n"
"+    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;\n"
"```"
msgstr ""

msgid ""
"Based on these constants, here's what the layout of a leaf node looks like cur"
"rently:"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/leaf-node-format.png\" description=\"Ou"
"r leaf node format\" %}"
msgstr ""

msgid ""
"It's a little space inefficient to use an entire byte per boolean value in the"
" header, but this makes it easier to write code to access those values."
msgstr ""

msgid ""
"Also notice that there's some wasted space at the end. We store as many cells "
"as we can after the header, but the leftover space can't hold an entire cell. "
"We leave it empty to avoid splitting cells between nodes."
msgstr ""

msgid "## Accessing Leaf Node Fields"
msgstr ""

msgid ""
"The code to access keys, values and metadata all involve pointer arithmetic us"
"ing the constants we just defined."
msgstr ""

msgid ""
"```diff\n"
"+uint32_t* leaf_node_num_cells(void* node) {\n"
"+  return node + LEAF_NODE_NUM_CELLS_OFFSET;\n"
"+}\n"
"+\n"
"+void* leaf_node_cell(void* node, uint32_t cell_num) {\n"
"+  return node + LEAF_NODE_HEADER_SIZE + cell_num * LEAF_NODE_CELL_SIZE;\n"
"+}\n"
"+\n"
"+uint32_t* leaf_node_key(void* node, uint32_t cell_num) {\n"
"+  return leaf_node_cell(node, cell_num);\n"
"+}\n"
"+\n"
"+void* leaf_node_value(void* node, uint32_t cell_num) {\n"
"+  return leaf_node_cell(node, cell_num) + LEAF_NODE_KEY_SIZE;\n"
"+}\n"
"+\n"
"+void initialize_leaf_node(void* node) { *leaf_node_num_cells(node) = 0; }\n"
"+\n"
"```"
msgstr ""

msgid ""
"These methods return a pointer to the value in question, so they can be used b"
"oth as a getter and a setter."
msgstr ""

msgid "## Changes to Pager and Table Objects"
msgstr ""

msgid ""
"Every node is going to take up exactly one page, even if it's not full. That m"
"eans our pager no longer needs to support reading/writing partial pages.\n"
"```diff\n"
"-void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {\n"
"+void pager_flush(Pager* pager, uint32_t page_num) {\n"
"   if (pager->pages[page_num] == NULL) {\n"
"     printf(\"Tried to flush null page\n"
"\");\n"
"     exit(EXIT_FAILURE);\n"
"@@ -242,7 +337,7 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32_t"
" size) {\n"
"   }"
msgstr ""

msgid ""
"   ssize_t bytes_written =\n"
"-      write(pager->file_descriptor, pager->pages[page_num], size);\n"
"+      write(pager->file_descriptor, pager->pages[page_num], PAGE_SIZE);"
msgstr ""

msgid ""
"   if (bytes_written == -1) {\n"
"     printf(\"Error writing: %d\n"
"\", errno);\n"
"```"
msgstr ""

msgid ""
"```diff\n"
" void db_close(Table* table) {\n"
"   Pager* pager = table->pager;\n"
"-  uint32_t num_full_pages = table->num_rows / ROWS_PER_PAGE;"
msgstr ""

msgid ""
"-  for (uint32_t i = 0; i < num_full_pages; i++) {\n"
"+  for (uint32_t i = 0; i < pager->num_pages; i++) {\n"
"     if (pager->pages[i] == NULL) {\n"
"       continue;\n"
"     }\n"
"-    pager_flush(pager, i, PAGE_SIZE);\n"
"+    pager_flush(pager, i);\n"
"     free(pager->pages[i]);\n"
"     pager->pages[i] = NULL;\n"
"   }"
msgstr ""

msgid ""
"-  // There may be a partial page to write to the end of the file\n"
"-  // This should not be needed after we switch to a B-tree\n"
"-  uint32_t num_additional_rows = table->num_rows % ROWS_PER_PAGE;\n"
"-  if (num_additional_rows > 0) {\n"
"-    uint32_t page_num = num_full_pages;\n"
"-    if (pager->pages[page_num] != NULL) {\n"
"-      pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);\n"
"-      free(pager->pages[page_num]);\n"
"-      pager->pages[page_num] = NULL;\n"
"-    }\n"
"-  }\n"
"-\n"
"   int result = close(pager->file_descriptor);\n"
"   if (result == -1) {\n"
"     printf(\"Error closing db file.\n"
"\");\n"
"```"
msgstr ""

msgid ""
"Now it makes more sense to store the number of pages in our database rather th"
"an the number of rows. The number of pages should be associated with the pager"
" object, not the table, since it's the number of pages used by the database, n"
"ot a particular table. A btree is identified by its root node page number, so "
"the table object needs to keep track of that."
msgstr ""

msgid ""
"```diff\n"
" const uint32_t PAGE_SIZE = 4096;\n"
" const uint32_t TABLE_MAX_PAGES = 100;\n"
"-const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;\n"
"-const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;"
msgstr ""

msgid ""
" typedef struct {\n"
"   int file_descriptor;\n"
"   uint32_t file_length;\n"
"+  uint32_t num_pages;\n"
"   void* pages[TABLE_MAX_PAGES];\n"
" } Pager;"
msgstr ""

msgid ""
" typedef struct {\n"
"   Pager* pager;\n"
"-  uint32_t num_rows;\n"
"+  uint32_t root_page_num;\n"
" } Table;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"@@ -127,6 +200,10 @@ void* get_page(Pager* pager, uint32_t page_num) {\n"
"     }"
msgstr ""

msgid ""
"     pager->pages[page_num] = page;\n"
"+\n"
"+    if (page_num >= pager->num_pages) {\n"
"+      pager->num_pages = page_num + 1;\n"
"+    }\n"
"   }"
msgstr ""

msgid ""
"   return pager->pages[page_num];\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"@@ -184,6 +269,12 @@ Pager* pager_open(const char* filename) {\n"
"   Pager* pager = malloc(sizeof(Pager));\n"
"   pager->file_descriptor = fd;\n"
"   pager->file_length = file_length;\n"
"+  pager->num_pages = (file_length / PAGE_SIZE);\n"
"+\n"
"+  if (file_length % PAGE_SIZE != 0) {\n"
"+    printf(\"Db file is not a whole number of pages. Corrupt file.\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }"
msgstr ""

msgid ""
"   for (uint32_t i = 0; i < TABLE_MAX_PAGES; i++) {\n"
"     pager->pages[i] = NULL;\n"
"```"
msgstr ""

msgid "## Changes to the Cursor Object"
msgstr ""

msgid ""
"A cursor represents a position in the table. When our table was a simple array"
" of rows, we could access a row given just the row number. Now that it's a tre"
"e, we identify a position by the page number of the node, and the cell number "
"within that node."
msgstr ""

msgid ""
"```diff\n"
" typedef struct {\n"
"   Table* table;\n"
"-  uint32_t row_num;\n"
"+  uint32_t page_num;\n"
"+  uint32_t cell_num;\n"
"   bool end_of_table;  // Indicates a position one past the last element\n"
" } Cursor;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
" Cursor* table_start(Table* table) {\n"
"   Cursor* cursor = malloc(sizeof(Cursor));\n"
"   cursor->table = table;\n"
"-  cursor->row_num = 0;\n"
"-  cursor->end_of_table = (table->num_rows == 0);\n"
"+  cursor->page_num = table->root_page_num;\n"
"+  cursor->cell_num = 0;\n"
"+\n"
"+  void* root_node = get_page(table->pager, table->root_page_num);\n"
"+  uint32_t num_cells = *leaf_node_num_cells(root_node);\n"
"+  cursor->end_of_table = (num_cells == 0);"
msgstr ""

msgid ""
"   return cursor;\n"
" }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
" Cursor* table_end(Table* table) {\n"
"   Cursor* cursor = malloc(sizeof(Cursor));\n"
"   cursor->table = table;\n"
"-  cursor->row_num = table->num_rows;\n"
"+  cursor->page_num = table->root_page_num;\n"
"+\n"
"+  void* root_node = get_page(table->pager, table->root_page_num);\n"
"+  uint32_t num_cells = *leaf_node_num_cells(root_node);\n"
"+  cursor->cell_num = num_cells;\n"
"   cursor->end_of_table = true;"
msgstr ""

msgid ""
"```diff\n"
" void* cursor_value(Cursor* cursor) {\n"
"-  uint32_t row_num = cursor->row_num;\n"
"-  uint32_t page_num = row_num / ROWS_PER_PAGE;\n"
"+  uint32_t page_num = cursor->page_num;\n"
"   void* page = get_page(cursor->table->pager, page_num);\n"
"-  uint32_t row_offset = row_num % ROWS_PER_PAGE;\n"
"-  uint32_t byte_offset = row_offset * ROW_SIZE;\n"
"-  return page + byte_offset;\n"
"+  return leaf_node_value(page, cursor->cell_num);\n"
" }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
" void cursor_advance(Cursor* cursor) {\n"
"-  cursor->row_num += 1;\n"
"-  if (cursor->row_num >= cursor->table->num_rows) {\n"
"+  uint32_t page_num = cursor->page_num;\n"
"+  void* node = get_page(cursor->table->pager, page_num);\n"
"+\n"
"+  cursor->cell_num += 1;\n"
"+  if (cursor->cell_num >= (*leaf_node_num_cells(node))) {\n"
"     cursor->end_of_table = true;\n"
"   }\n"
" }\n"
"```"
msgstr ""

msgid "## Insertion Into a Leaf Node"
msgstr ""

msgid ""
"In this article we're only going to implement enough to get a single-node tree"
". Recall from last article that a tree starts out as an empty leaf node:"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/btree1.png\" description=\"empty btree\""
" %}"
msgstr ""

msgid "Key/value pairs can be added until the leaf node is full:"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/btree2.png\" description=\"one-node btr"
"ee\" %}"
msgstr ""

msgid ""
"When we open the database for the first time, the database file will be empty,"
" so we initialize page 0 to be an empty leaf node (the root node):"
msgstr ""

msgid ""
"```diff\n"
" Table* db_open(const char* filename) {\n"
"   Pager* pager = pager_open(filename);\n"
"-  uint32_t num_rows = pager->file_length / ROW_SIZE;"
msgstr ""

msgid ""
"   Table* table = malloc(sizeof(Table));\n"
"   table->pager = pager;\n"
"-  table->num_rows = num_rows;\n"
"+  table->root_page_num = 0;\n"
"+\n"
"+  if (pager->num_pages == 0) {\n"
"+    // New database file. Initialize page 0 as leaf node.\n"
"+    void* root_node = get_page(pager, 0);\n"
"+    initialize_leaf_node(root_node);\n"
"+  }"
msgstr ""

msgid ""
"   return table;\n"
" }\n"
"```"
msgstr ""

msgid ""
"Next we'll make a function for inserting a key/value pair into a leaf node. It"
" will take a cursor as input to represent the position where the pair should b"
"e inserted."
msgstr ""

msgid ""
"```diff\n"
"+void leaf_node_insert(Cursor* cursor, uint32_t key, Row* value) {\n"
"+  void* node = get_page(cursor->table->pager, cursor->page_num);\n"
"+\n"
"+  uint32_t num_cells = *leaf_node_num_cells(node);\n"
"+  if (num_cells >= LEAF_NODE_MAX_CELLS) {\n"
"+    // Node full\n"
"+    printf(\"Need to implement splitting a leaf node.\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  if (cursor->cell_num < num_cells) {\n"
"+    // Make room for new cell\n"
"+    for (uint32_t i = num_cells; i > cursor->cell_num; i--) {\n"
"+      memcpy(leaf_node_cell(node, i), leaf_node_cell(node, i - 1),\n"
"+             LEAF_NODE_CELL_SIZE);\n"
"+    }\n"
"+  }\n"
"+\n"
"+  *(leaf_node_num_cells(node)) += 1;\n"
"+  *(leaf_node_key(node, cursor->cell_num)) = key;\n"
"+  serialize_row(value, leaf_node_value(node, cursor->cell_num));\n"
"+}\n"
"+\n"
"```"
msgstr ""

msgid ""
"We haven't implemented splitting yet, so we error if the node is full. Next we"
" shift cells one space to the right to make room for the new cell. Then we wri"
"te the new key/value into the empty space."
msgstr ""

msgid ""
"Since we assume the tree only has one node, our `execute_insert()` function si"
"mply needs to call this helper method:"
msgstr ""

msgid ""
"```diff\n"
" ExecuteResult execute_insert(Statement* statement, Table* table) {\n"
"-  if (table->num_rows >= TABLE_MAX_ROWS) {\n"
"+  void* node = get_page(table->pager, table->root_page_num);\n"
"+  if ((*leaf_node_num_cells(node) >= LEAF_NODE_MAX_CELLS)) {\n"
"     return EXECUTE_TABLE_FULL;\n"
"   }"
msgstr ""

msgid ""
"   Row* row_to_insert = &(statement->row_to_insert);\n"
"   Cursor* cursor = table_end(table);"
msgstr ""

msgid ""
"-  serialize_row(row_to_insert, cursor_value(cursor));\n"
"-  table->num_rows += 1;\n"
"+  leaf_node_insert(cursor, row_to_insert->id, row_to_insert);"
msgstr ""

msgid ""
"   free(cursor);\n"
"```"
msgstr ""

msgid ""
"With those changes, our database should work as before! Except now it returns "
"a \"Table Full\" error much sooner, since we can't split the root node yet."
msgstr ""

msgid "How many rows can the leaf node hold?"
msgstr ""

msgid "## Command to Print Constants"
msgstr ""

msgid "I'm adding a new meta command to print out a few constants of interest."
msgstr ""

msgid ""
"```diff\n"
"+void print_constants() {\n"
"+  printf(\"ROW_SIZE: %d\n"
"\", ROW_SIZE);\n"
"+  printf(\"COMMON_NODE_HEADER_SIZE: %d\n"
"\", COMMON_NODE_HEADER_SIZE);\n"
"+  printf(\"LEAF_NODE_HEADER_SIZE: %d\n"
"\", LEAF_NODE_HEADER_SIZE);\n"
"+  printf(\"LEAF_NODE_CELL_SIZE: %d\n"
"\", LEAF_NODE_CELL_SIZE);\n"
"+  printf(\"LEAF_NODE_SPACE_FOR_CELLS: %d\n"
"\", LEAF_NODE_SPACE_FOR_CELLS);\n"
"+  printf(\"LEAF_NODE_MAX_CELLS: %d\n"
"\", LEAF_NODE_MAX_CELLS);\n"
"+}\n"
"+\n"
"@@ -294,6 +376,14 @@ MetaCommandResult do_meta_command(InputBuffer* input_buff"
"er, Table* table) {\n"
"   if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"     db_close(table);\n"
"     exit(EXIT_SUCCESS);\n"
"+  } else if (strcmp(input_buffer->buffer, \".constants\") == 0) {\n"
"+    printf(\"Constants:\n"
"\");\n"
"+    print_constants();\n"
"+    return META_COMMAND_SUCCESS;\n"
"   } else {\n"
"     return META_COMMAND_UNRECOGNIZED_COMMAND;\n"
"   }\n"
"```"
msgstr ""

msgid ""
"I'm also adding a test so we get alerted when those constants change:\n"
"```diff\n"
"+  it 'prints constants' do\n"
"+    script = [\n"
"+      \".constants\",\n"
"+      \".exit\",\n"
"+    ]\n"
"+    result = run_script(script)\n"
"+\n"
"+    expect(result).to match_array([\n"
"+      \"db > Constants:\",\n"
"+      \"ROW_SIZE: 293\",\n"
"+      \"COMMON_NODE_HEADER_SIZE: 6\",\n"
"+      \"LEAF_NODE_HEADER_SIZE: 10\",\n"
"+      \"LEAF_NODE_CELL_SIZE: 297\",\n"
"+      \"LEAF_NODE_SPACE_FOR_CELLS: 4086\",\n"
"+      \"LEAF_NODE_MAX_CELLS: 13\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
"```"
msgstr ""

msgid "So our table can hold 13 rows right now!"
msgstr ""

msgid "## Tree Visualization"
msgstr ""

msgid ""
"To help with debugging and visualization, I'm also adding a meta command to pr"
"int out a representation of the btree."
msgstr ""

msgid ""
"```diff\n"
"+void print_leaf_node(void* node) {\n"
"+  uint32_t num_cells = *leaf_node_num_cells(node);\n"
"+  printf(\"leaf (size %d)\n"
"\", num_cells);\n"
"+  for (uint32_t i = 0; i < num_cells; i++) {\n"
"+    uint32_t key = *leaf_node_key(node, i);\n"
"+    printf(\"  - %d : %d\n"
"\", i, key);\n"
"+  }\n"
"+}\n"
"+\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"@@ -294,6 +376,14 @@ MetaCommandResult do_meta_command(InputBuffer* input_buff"
"er, Table* table) {\n"
"   if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"     db_close(table);\n"
"     exit(EXIT_SUCCESS);\n"
"+  } else if (strcmp(input_buffer->buffer, \".btree\") == 0) {\n"
"+    printf(\"Tree:\n"
"\");\n"
"+    print_leaf_node(get_page(table->pager, 0));\n"
"+    return META_COMMAND_SUCCESS;\n"
"   } else if (strcmp(input_buffer->buffer, \".constants\") == 0) {\n"
"     printf(\"Constants:\n"
"\");\n"
"     print_constants();\n"
"     return META_COMMAND_SUCCESS;\n"
"   } else {\n"
"     return META_COMMAND_UNRECOGNIZED_COMMAND;\n"
"   }\n"
"```"
msgstr ""

msgid "And a test"
msgstr ""

msgid ""
"```diff\n"
"+  it 'allows printing out the structure of a one-node btree' do\n"
"+    script = [3, 1, 2].map do |i|\n"
"+      \"insert #{i} user#{i} person#{i}@example.com\"\n"
"+    end\n"
"+    script << \".btree\"\n"
"+    script << \".exit\"\n"
"+    result = run_script(script)\n"
"+\n"
"+    expect(result).to match_array([\n"
"+      \"db > Executed.\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > Tree:\",\n"
"+      \"leaf (size 3)\",\n"
"+      \"  - 0 : 3\",\n"
"+      \"  - 1 : 1\",\n"
"+      \"  - 2 : 2\",\n"
"+      \"db > \"\n"
"+    ])\n"
"+  end\n"
"```"
msgstr ""

msgid ""
"Uh oh, we're still not storing rows in sorted order. You'll notice that `execu"
"te_insert()` inserts into the leaf node at the position returned by `table_end"
"()`. So rows are stored in the order they were inserted, just like before."
msgstr ""

msgid "## Next Time"
msgstr ""

msgid ""
"This all might seem like a step backwards. Our database now stores fewer rows "
"than it did before, and we're still storing rows in unsorted order. But like I"
" said at the beginning, this is a big change and it's important to break it up"
" into manageable steps."
msgstr ""

msgid ""
"Next time, we'll implement finding a record by primary key, and start storing "
"rows in sorted order."
msgstr ""

msgid "## Complete Diff"
msgstr ""

msgid ""
"```diff\n"
"@@ -62,29 +62,101 @@ const uint32_t ROW_SIZE = ID_SIZE + USERNAME_SIZE + EMAIL"
"_SIZE;"
msgstr ""

msgid ""
" const uint32_t PAGE_SIZE = 4096;\n"
" #define TABLE_MAX_PAGES 100\n"
"-const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;\n"
"-const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;"
msgstr ""

msgid ""
" typedef struct {\n"
"   Pager* pager;\n"
"-  uint32_t num_rows;\n"
"+  uint32_t root_page_num;\n"
" } Table;"
msgstr ""

msgid ""
" typedef struct {\n"
"   Table* table;\n"
"-  uint32_t row_num;\n"
"+  uint32_t page_num;\n"
"+  uint32_t cell_num;\n"
"   bool end_of_table;  // Indicates a position one past the last element\n"
" } Cursor;"
msgstr ""

msgid ""
"+typedef enum { NODE_INTERNAL, NODE_LEAF } NodeType;\n"
"+\n"
"+/*\n"
"+ * Common Node Header Layout\n"
"+ */\n"
"+const uint32_t NODE_TYPE_SIZE = sizeof(uint8_t);\n"
"+const uint32_t NODE_TYPE_OFFSET = 0;\n"
"+const uint32_t IS_ROOT_SIZE = sizeof(uint8_t);\n"
"+const uint32_t IS_ROOT_OFFSET = NODE_TYPE_SIZE;\n"
"+const uint32_t PARENT_POINTER_SIZE = sizeof(uint32_t);\n"
"+const uint32_t PARENT_POINTER_OFFSET = IS_ROOT_OFFSET + IS_ROOT_SIZE;\n"
"+const uint8_t COMMON_NODE_HEADER_SIZE =\n"
"+    NODE_TYPE_SIZE + IS_ROOT_SIZE + PARENT_POINTER_SIZE;\n"
"+\n"
"+/*\n"
"+ * Leaf Node Header Layout\n"
"+ */\n"
"+const uint32_t LEAF_NODE_NUM_CELLS_SIZE = sizeof(uint32_t);\n"
"+const uint32_t LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;\n"
"+const uint32_t LEAF_NODE_HEADER_SIZE =\n"
"+    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;\n"
"+\n"
"+/*\n"
"+ * Leaf Node Body Layout\n"
"+ */\n"
"+const uint32_t LEAF_NODE_KEY_SIZE = sizeof(uint32_t);\n"
"+const uint32_t LEAF_NODE_KEY_OFFSET = 0;\n"
"+const uint32_t LEAF_NODE_VALUE_SIZE = ROW_SIZE;\n"
"+const uint32_t LEAF_NODE_VALUE_OFFSET =\n"
"+    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;\n"
"+const uint32_t LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZ"
"E;\n"
"+const uint32_t LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;"
"\n"
"+const uint32_t LEAF_NODE_MAX_CELLS =\n"
"+    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;\n"
"+\n"
"+uint32_t* leaf_node_num_cells(void* node) {\n"
"+  return node + LEAF_NODE_NUM_CELLS_OFFSET;\n"
"+}\n"
"+\n"
"+void* leaf_node_cell(void* node, uint32_t cell_num) {\n"
"+  return node + LEAF_NODE_HEADER_SIZE + cell_num * LEAF_NODE_CELL_SIZE;\n"
"+}\n"
"+\n"
"+uint32_t* leaf_node_key(void* node, uint32_t cell_num) {\n"
"+  return leaf_node_cell(node, cell_num);\n"
"+}\n"
"+\n"
"+void* leaf_node_value(void* node, uint32_t cell_num) {\n"
"+  return leaf_node_cell(node, cell_num) + LEAF_NODE_KEY_SIZE;\n"
"+}\n"
"+\n"
"+void print_constants() {\n"
"+  printf(\"ROW_SIZE: %d\n"
"\", ROW_SIZE);\n"
"+  printf(\"COMMON_NODE_HEADER_SIZE: %d\n"
"\", COMMON_NODE_HEADER_SIZE);\n"
"+  printf(\"LEAF_NODE_HEADER_SIZE: %d\n"
"\", LEAF_NODE_HEADER_SIZE);\n"
"+  printf(\"LEAF_NODE_CELL_SIZE: %d\n"
"\", LEAF_NODE_CELL_SIZE);\n"
"+  printf(\"LEAF_NODE_SPACE_FOR_CELLS: %d\n"
"\", LEAF_NODE_SPACE_FOR_CELLS);\n"
"+  printf(\"LEAF_NODE_MAX_CELLS: %d\n"
"\", LEAF_NODE_MAX_CELLS);\n"
"+}\n"
"+\n"
"+void print_leaf_node(void* node) {\n"
"+  uint32_t num_cells = *leaf_node_num_cells(node);\n"
"+  printf(\"leaf (size %d)\n"
"\", num_cells);\n"
"+  for (uint32_t i = 0; i < num_cells; i++) {\n"
"+    uint32_t key = *leaf_node_key(node, i);\n"
"+    printf(\"  - %d : %d\n"
"\", i, key);\n"
"+  }\n"
"+}\n"
"+\n"
" void print_row(Row* row) {\n"
"     printf(\"(%d, %s, %s)\n"
"\", row->id, row->username, row->email);\n"
" }\n"
"@@ -101,6 +173,8 @@ void deserialize_row(void *source, Row* destination) {\n"
"     memcpy(&(destination->email), source + EMAIL_OFFSET, EMAIL_SIZE);\n"
" }"
msgstr ""

msgid ""
"+void initialize_leaf_node(void* node) { *leaf_node_num_cells(node) = 0; }\n"
"+\n"
" void* get_page(Pager* pager, uint32_t page_num) {\n"
"   if (page_num > TABLE_MAX_PAGES) {\n"
"     printf(\"Tried to fetch page number out of bounds. %d > %d\n"
"\", page_num,\n"
"@@ -128,6 +202,10 @@ void* get_page(Pager* pager, uint32_t page_num) {\n"
"     }"
msgstr ""

msgid ""
"   return pager->pages[page_num];\n"
"@@ -136,8 +214,12 @@ void* get_page(Pager* pager, uint32_t page_num) {\n"
" Cursor* table_start(Table* table) {\n"
"   Cursor* cursor = malloc(sizeof(Cursor));\n"
"   cursor->table = table;\n"
"-  cursor->row_num = 0;\n"
"-  cursor->end_of_table = (table->num_rows == 0);\n"
"+  cursor->page_num = table->root_page_num;\n"
"+  cursor->cell_num = 0;\n"
"+\n"
"+  void* root_node = get_page(table->pager, table->root_page_num);\n"
"+  uint32_t num_cells = *leaf_node_num_cells(root_node);\n"
"+  cursor->end_of_table = (num_cells == 0);"
msgstr ""

msgid ""
"   return cursor;\n"
" }\n"
"@@ -145,24 +227,28 @@ Cursor* table_start(Table* table) {\n"
" Cursor* table_end(Table* table) {\n"
"   Cursor* cursor = malloc(sizeof(Cursor));\n"
"   cursor->table = table;\n"
"-  cursor->row_num = table->num_rows;\n"
"+  cursor->page_num = table->root_page_num;\n"
"+\n"
"+  void* root_node = get_page(table->pager, table->root_page_num);\n"
"+  uint32_t num_cells = *leaf_node_num_cells(root_node);\n"
"+  cursor->cell_num = num_cells;\n"
"   cursor->end_of_table = true;"
msgstr ""

msgid ""
"   return cursor;\n"
" }"
msgstr ""

msgid ""
" void* cursor_value(Cursor* cursor) {\n"
"-  uint32_t row_num = cursor->row_num;\n"
"-  uint32_t page_num = row_num / ROWS_PER_PAGE;\n"
"+  uint32_t page_num = cursor->page_num;\n"
"   void* page = get_page(cursor->table->pager, page_num);\n"
"-  uint32_t row_offset = row_num % ROWS_PER_PAGE;\n"
"-  uint32_t byte_offset = row_offset * ROW_SIZE;\n"
"-  return page + byte_offset;\n"
"+  return leaf_node_value(page, cursor->cell_num);\n"
" }"
msgstr ""

msgid ""
" void cursor_advance(Cursor* cursor) {\n"
"-  cursor->row_num += 1;\n"
"-  if (cursor->row_num >= cursor->table->num_rows) {\n"
"+  uint32_t page_num = cursor->page_num;\n"
"+  void* node = get_page(cursor->table->pager, page_num);\n"
"+\n"
"+  cursor->cell_num += 1;\n"
"+  if (cursor->cell_num >= (*leaf_node_num_cells(node))) {\n"
"     cursor->end_of_table = true;\n"
"   }\n"
" }\n"
"@@ -185,6 +271,12 @@ Pager* pager_open(const char* filename) {\n"
"   Pager* pager = malloc(sizeof(Pager));\n"
"   pager->file_descriptor = fd;\n"
"   pager->file_length = file_length;\n"
"+  pager->num_pages = (file_length / PAGE_SIZE);\n"
"+\n"
"+  if (file_length % PAGE_SIZE != 0) {\n"
"+    printf(\"Db file is not a whole number of pages. Corrupt file.\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }"
msgstr ""

msgid ""
"   for (uint32_t i = 0; i < TABLE_MAX_PAGES; i++) {\n"
"     pager->pages[i] = NULL;\n"
"@@ -194,11 +285,15 @@ Pager* pager_open(const char* filename) {\n"
"@@ -195,11 +287,16 @@ Pager* pager_open(const char* filename) {"
msgstr ""

msgid ""
" Table* db_open(const char* filename) {\n"
"   Pager* pager = pager_open(filename);\n"
"-  uint32_t num_rows = pager->file_length / ROW_SIZE;"
msgstr ""

msgid ""
"   return table;\n"
" }\n"
"@@ -234,7 +331,7 @@ void close_input_buffer(InputBuffer* input_buffer) {\n"
"     free(input_buffer);\n"
" }"
msgstr ""

msgid ""
"-void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {\n"
"+void pager_flush(Pager* pager, uint32_t page_num) {\n"
"   if (pager->pages[page_num] == NULL) {\n"
"     printf(\"Tried to flush null page\n"
"\");\n"
"     exit(EXIT_FAILURE);\n"
"@@ -242,7 +337,7 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32_t"
" size) {\n"
"@@ -249,7 +346,7 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32_t"
" size) {\n"
"   }"
msgstr ""

msgid ""
"   if (bytes_written == -1) {\n"
"     printf(\"Error writing: %d\n"
"\", errno);\n"
"@@ -252,29 +347,16 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32"
"_t size) {\n"
"@@ -260,29 +357,16 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32"
"_t size) {"
msgstr ""

msgid ""
" void db_close(Table* table) {\n"
"   Pager* pager = table->pager;\n"
"-  uint32_t num_full_pages = table->num_rows / ROWS_PER_PAGE;"
msgstr ""

msgid ""
"-  // There may be a partial page to write to the end of the file\n"
"-  // This should not be needed after we switch to a B-tree\n"
"-  uint32_t num_additional_rows = table->num_rows % ROWS_PER_PAGE;\n"
"-  if (num_additional_rows > 0) {\n"
"-    uint32_t page_num = num_full_pages;\n"
"-    if (pager->pages[page_num] != NULL) {\n"
"-      pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);\n"
"-      free(pager->pages[page_num]);\n"
"-      pager->pages[page_num] = NULL;\n"
"-    }\n"
"-  }\n"
"-\n"
"   int result = close(pager->file_descriptor);\n"
"   if (result == -1) {\n"
"     printf(\"Error closing db file.\n"
"\");\n"
"@@ -305,6 +389,14 @@ MetaCommandResult do_meta_command(InputBuffer* input_buff"
"er, Table *table) {\n"
"   if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"     db_close(table);\n"
"     exit(EXIT_SUCCESS);\n"
"+  } else if (strcmp(input_buffer->buffer, \".btree\") == 0) {\n"
"+    printf(\"Tree:\n"
"\");\n"
"+    print_leaf_node(get_page(table->pager, 0));\n"
"+    return META_COMMAND_SUCCESS;\n"
"+  } else if (strcmp(input_buffer->buffer, \".constants\") == 0) {\n"
"+    printf(\"Constants:\n"
"\");\n"
"+    print_constants();\n"
"+    return META_COMMAND_SUCCESS;\n"
"   } else {\n"
"     return META_COMMAND_UNRECOGNIZED_COMMAND;\n"
"   }\n"
"@@ -354,16 +446,39 @@ PrepareResult prepare_statement(InputBuffer* input_buffe"
"r,\n"
"   return PREPARE_UNRECOGNIZED_STATEMENT;\n"
" }"
msgstr ""

msgid ""
"+void leaf_node_insert(Cursor* cursor, uint32_t key, Row* value) {\n"
"+  void* node = get_page(cursor->table->pager, cursor->page_num);\n"
"+\n"
"+  uint32_t num_cells = *leaf_node_num_cells(node);\n"
"+  if (num_cells >= LEAF_NODE_MAX_CELLS) {\n"
"+    // Node full\n"
"+    printf(\"Need to implement splitting a leaf node.\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  if (cursor->cell_num < num_cells) {\n"
"+    // Make room for new cell\n"
"+    for (uint32_t i = num_cells; i > cursor->cell_num; i--) {\n"
"+      memcpy(leaf_node_cell(node, i), leaf_node_cell(node, i - 1),\n"
"+             LEAF_NODE_CELL_SIZE);\n"
"+    }\n"
"+  }\n"
"+\n"
"+  *(leaf_node_num_cells(node)) += 1;\n"
"+  *(leaf_node_key(node, cursor->cell_num)) = key;\n"
"+  serialize_row(value, leaf_node_value(node, cursor->cell_num));\n"
"+}\n"
"+\n"
" ExecuteResult execute_insert(Statement* statement, Table* table) {\n"
"-  if (table->num_rows >= TABLE_MAX_ROWS) {\n"
"+  void* node = get_page(table->pager, table->root_page_num);\n"
"+  if ((*leaf_node_num_cells(node) >= LEAF_NODE_MAX_CELLS)) {\n"
"     return EXECUTE_TABLE_FULL;\n"
"   }"
msgstr ""

msgid ""
"And the specs:\n"
"```diff\n"
"+  it 'allows printing out the structure of a one-node btree' do\n"
"+    script = [3, 1, 2].map do |i|\n"
"+      \"insert #{i} user#{i} person#{i}@example.com\"\n"
"+    end\n"
"+    script << \".btree\"\n"
"+    script << \".exit\"\n"
"+    result = run_script(script)\n"
"+\n"
"+    expect(result).to match_array([\n"
"+      \"db > Executed.\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > Tree:\",\n"
"+      \"leaf (size 3)\",\n"
"+      \"  - 0 : 3\",\n"
"+      \"  - 1 : 1\",\n"
"+      \"  - 2 : 2\",\n"
"+      \"db > \"\n"
"+    ])\n"
"+  end\n"
"+\n"
"+  it 'prints constants' do\n"
"+    script = [\n"
"+      \".constants\",\n"
"+      \".exit\",\n"
"+    ]\n"
"+    result = run_script(script)\n"
"+\n"
"+    expect(result).to match_array([\n"
"+      \"db > Constants:\",\n"
"+      \"ROW_SIZE: 293\",\n"
"+      \"COMMON_NODE_HEADER_SIZE: 6\",\n"
"+      \"LEAF_NODE_HEADER_SIZE: 10\",\n"
"+      \"LEAF_NODE_CELL_SIZE: 297\",\n"
"+      \"LEAF_NODE_SPACE_FOR_CELLS: 4086\",\n"
"+      \"LEAF_NODE_MAX_CELLS: 13\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
" end\n"
"```"
msgstr ""
