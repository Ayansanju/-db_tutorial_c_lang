# Japanese translations for PACKAGE package.
# Copyright (C) 2021 THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-23 11:24+0900\n"
"PO-Revision-Date: 2021-11-23 11:24+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=; plural=;\n"

#: ../../../_parts/part5.md:1
msgid ""
"---\n"
"title: Part 5 - Persistence to Disk\n"
"date: 2017-09-08\n"
"---"
msgstr ""

#: ../../../_parts/part5.md:6
msgid "> \"Nothing in the world can take the place of persistence.\" -- [Calvin Coolidge](https://en.wikiquote.org/wiki/Calvin_Coolidge)"
msgstr ""

#: ../../../_parts/part5.md:8
msgid "Our database lets you insert records and read them back out, but only as long as you keep the program running. If you kill the program and start it back up, all your records are gone. Here's a spec for the behavior we want:"
msgstr ""

#: ../../../_parts/part5.md:10
msgid ""
"```ruby\n"
"it 'keeps data after closing connection' do\n"
"  result1 = run_script([\n"
"    \"insert 1 user1 person1@example.com\",\n"
"    \".exit\",\n"
"  ])\n"
"  expect(result1).to match_array([\n"
"    \"db > Executed.\",\n"
"    \"db > \",\n"
"  ])\n"
"  result2 = run_script([\n"
"    \"select\",\n"
"    \".exit\",\n"
"  ])\n"
"  expect(result2).to match_array([\n"
"    \"db > (1, user1, person1@example.com)\",\n"
"    \"Executed.\",\n"
"    \"db > \",\n"
"  ])\n"
"end\n"
"```"
msgstr ""

#: ../../../_parts/part5.md:32
msgid "Like sqlite, we're going to persist records by saving the entire database to a file."
msgstr ""

#: ../../../_parts/part5.md:34
msgid "We already set ourselves up to do that by serializing rows into page-sized memory blocks. To add persistence, we can simply write those blocks of memory to a file, and read them back into memory the next time the program starts up."
msgstr ""

#: ../../../_parts/part5.md:36
msgid "To make this easier, we're going to make an abstraction called the pager. We ask the pager for page number `x`, and the pager gives us back a block of memory. It first looks in its cache. On a cache miss, it copies data from disk into memory (by reading the database file)."
msgstr ""

#: ../../../_parts/part5.md:38
msgid "{% include image.html url=\"assets/images/arch-part5.gif\" description=\"How our program matches up with SQLite architecture\" %}"
msgstr ""

#: ../../../_parts/part5.md:40
msgid "The Pager accesses the page cache and the file. The Table object makes requests for pages through the pager:"
msgstr ""

#: ../../../_parts/part5.md:42
msgid ""
"```diff\n"
"+typedef struct {\n"
"+  int file_descriptor;\n"
"+  uint32_t file_length;\n"
"+  void* pages[TABLE_MAX_PAGES];\n"
"+} Pager;\n"
"+\n"
" typedef struct {\n"
"-  void* pages[TABLE_MAX_PAGES];\n"
"+  Pager* pager;\n"
"   uint32_t num_rows;\n"
" } Table;\n"
"```"
msgstr ""

#: ../../../_parts/part5.md:56
msgid "I'm renaming `new_table()` to `db_open()` because it now has the effect of opening a connection to the database. By opening a connection, I mean:"
msgstr ""

#: ../../../_parts/part5.md:58
msgid ""
"- opening the database file\n"
"- initializing a pager data structure\n"
"- initializing a table data structure"
msgstr ""

#: ../../../_parts/part5.md:62
msgid ""
"```diff\n"
"-Table* new_table() {\n"
"+Table* db_open(const char* filename) {\n"
"+  Pager* pager = pager_open(filename);\n"
"+  uint32_t num_rows = pager->file_length / ROW_SIZE;\n"
"+\n"
"   Table* table = malloc(sizeof(Table));\n"
"-  table->num_rows = 0;\n"
"+  table->pager = pager;\n"
"+  table->num_rows = num_rows;"
msgstr ""

#: ../../../_parts/part5.md:73
msgid ""
"   return table;\n"
" }\n"
"```"
msgstr ""

#: ../../../_parts/part5.md:77
msgid "`db_open()` in turn calls `pager_open()`, which opens the database file and keeps track of its size. It also initializes the page cache to all `NULL`s."
msgstr ""

#: ../../../_parts/part5.md:79
msgid ""
"```diff\n"
"+Pager* pager_open(const char* filename) {\n"
"+  int fd = open(filename,\n"
"+                O_RDWR |      // Read/Write mode\n"
"+                    O_CREAT,  // Create file if it does not exist\n"
"+                S_IWUSR |     // User write permission\n"
"+                    S_IRUSR   // User read permission\n"
"+                );\n"
"+\n"
"+  if (fd == -1) {\n"
"+    printf(\"Unable to open file\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  off_t file_length = lseek(fd, 0, SEEK_END);\n"
"+\n"
"+  Pager* pager = malloc(sizeof(Pager));\n"
"+  pager->file_descriptor = fd;\n"
"+  pager->file_length = file_length;\n"
"+\n"
"+  for (uint32_t i = 0; i < TABLE_MAX_PAGES; i++) {\n"
"+    pager->pages[i] = NULL;\n"
"+  }\n"
"+\n"
"+  return pager;\n"
"+}\n"
"```"
msgstr ""

#: ../../../_parts/part5.md:107
msgid "Following our new abstraction, we move the logic for fetching a page into its own method:"
msgstr ""

#: ../../../_parts/part5.md:109
msgid ""
"```diff\n"
" void* row_slot(Table* table, uint32_t row_num) {\n"
"   uint32_t page_num = row_num / ROWS_PER_PAGE;\n"
"-  void* page = table->pages[page_num];\n"
"-  if (page == NULL) {\n"
"-    // Allocate memory only when we try to access page\n"
"-    page = table->pages[page_num] = malloc(PAGE_SIZE);\n"
"-  }\n"
"+  void* page = get_page(table->pager, page_num);\n"
"   uint32_t row_offset = row_num % ROWS_PER_PAGE;\n"
"   uint32_t byte_offset = row_offset * ROW_SIZE;\n"
"   return page + byte_offset;\n"
" }\n"
"```"
msgstr ""

#: ../../../_parts/part5.md:124
msgid "The `get_page()` method has the logic for handling a cache miss. We assume pages are saved one after the other in the database file: Page 0 at offset 0, page 1 at offset 4096, page 2 at offset 8192, etc. If the requested page lies outside the bounds of the file, we know it should be blank, so we just allocate some memory and return it. The page will be added to the file when we flush the cache to disk later."
msgstr ""

#: ../../../_parts/part5.md:127
msgid ""
"```diff\n"
"+void* get_page(Pager* pager, uint32_t page_num) {\n"
"+  if (page_num > TABLE_MAX_PAGES) {\n"
"+    printf(\"Tried to fetch page number out of bounds. %d > %d\n"
"\", page_num,\n"
"+           TABLE_MAX_PAGES);\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  if (pager->pages[page_num] == NULL) {\n"
"+    // Cache miss. Allocate memory and load from file.\n"
"+    void* page = malloc(PAGE_SIZE);\n"
"+    uint32_t num_pages = pager->file_length / PAGE_SIZE;\n"
"+\n"
"+    // We might save a partial page at the end of the file\n"
"+    if (pager->file_length % PAGE_SIZE) {\n"
"+      num_pages += 1;\n"
"+    }\n"
"+\n"
"+    if (page_num <= num_pages) {\n"
"+      lseek(pager->file_descriptor, page_num * PAGE_SIZE, SEEK_SET);\n"
"+      ssize_t bytes_read = read(pager->file_descriptor, page, PAGE_SIZE);\n"
"+      if (bytes_read == -1) {\n"
"+        printf(\"Error reading file: %d\n"
"\", errno);\n"
"+        exit(EXIT_FAILURE);\n"
"+      }\n"
"+    }\n"
"+\n"
"+    pager->pages[page_num] = page;\n"
"+  }\n"
"+\n"
"+  return pager->pages[page_num];\n"
"+}\n"
"```"
msgstr ""

#: ../../../_parts/part5.md:161
msgid "For now, we'll wait to flush the cache to disk until the user closes the connection to the database. When the user exits, we'll call a new method called `db_close()`, which"
msgstr ""

#: ../../../_parts/part5.md:163
msgid ""
"- flushes the page cache to disk\n"
"- closes the database file\n"
"- frees the memory for the Pager and Table data structures"
msgstr ""

#: ../../../_parts/part5.md:167
msgid ""
"```diff\n"
"+void db_close(Table* table) {\n"
"+  Pager* pager = table->pager;\n"
"+  uint32_t num_full_pages = table->num_rows / ROWS_PER_PAGE;\n"
"+\n"
"+  for (uint32_t i = 0; i < num_full_pages; i++) {\n"
"+    if (pager->pages[i] == NULL) {\n"
"+      continue;\n"
"+    }\n"
"+    pager_flush(pager, i, PAGE_SIZE);\n"
"+    free(pager->pages[i]);\n"
"+    pager->pages[i] = NULL;\n"
"+  }\n"
"+\n"
"+  // There may be a partial page to write to the end of the file\n"
"+  // This should not be needed after we switch to a B-tree\n"
"+  uint32_t num_additional_rows = table->num_rows % ROWS_PER_PAGE;\n"
"+  if (num_additional_rows > 0) {\n"
"+    uint32_t page_num = num_full_pages;\n"
"+    if (pager->pages[page_num] != NULL) {\n"
"+      pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);\n"
"+      free(pager->pages[page_num]);\n"
"+      pager->pages[page_num] = NULL;\n"
"+    }\n"
"+  }\n"
"+\n"
"+  int result = close(pager->file_descriptor);\n"
"+  if (result == -1) {\n"
"+    printf(\"Error closing db file.\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+  for (uint32_t i = 0; i < TABLE_MAX_PAGES; i++) {\n"
"+    void* page = pager->pages[i];\n"
"+    if (page) {\n"
"+      free(page);\n"
"+      pager->pages[i] = NULL;\n"
"+    }\n"
"+  }\n"
"+  free(pager);\n"
"+  free(table);\n"
"+}\n"
"+\n"
"-MetaCommandResult do_meta_command(InputBuffer* input_buffer) {\n"
"+MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table* table) {\n"
"   if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"+    db_close(table);\n"
"     exit(EXIT_SUCCESS);\n"
"   } else {\n"
"     return META_COMMAND_UNRECOGNIZED_COMMAND;\n"
"```"
msgstr ""

#: ../../../_parts/part5.md:218
msgid "In our current design, the length of the file encodes how many rows are in the database, so we need to write a partial page at the end of the file. That's why `pager_flush()` takes both a page number and a size. It's not the greatest design, but it will go away pretty quickly when we start implementing the B-tree."
msgstr ""

#: ../../../_parts/part5.md:220
msgid ""
"```diff\n"
"+void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {\n"
"+  if (pager->pages[page_num] == NULL) {\n"
"+    printf(\"Tried to flush null page\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  off_t offset = lseek(pager->file_descriptor, page_num * PAGE_SIZE, SEEK_SET);\n"
"+\n"
"+  if (offset == -1) {\n"
"+    printf(\"Error seeking: %d\n"
"\", errno);\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  ssize_t bytes_written =\n"
"+      write(pager->file_descriptor, pager->pages[page_num], size);\n"
"+\n"
"+  if (bytes_written == -1) {\n"
"+    printf(\"Error writing: %d\n"
"\", errno);\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+}\n"
"```"
msgstr ""

#: ../../../_parts/part5.md:244
msgid "Lastly, we need to accept the filename as a command-line argument. Don't forget to also add the extra argument to `do_meta_command`:"
msgstr ""

#: ../../../_parts/part5.md:246
msgid ""
"```diff\n"
" int main(int argc, char* argv[]) {\n"
"-  Table* table = new_table();\n"
"+  if (argc < 2) {\n"
"+    printf(\"Must supply a database filename.\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  char* filename = argv[1];\n"
"+  Table* table = db_open(filename);\n"
"+\n"
"   InputBuffer* input_buffer = new_input_buffer();\n"
"   while (true) {\n"
"     print_prompt();\n"
"     read_input(input_buffer);"
msgstr ""

#: ../../../_parts/part5.md:262
msgid ""
"     if (input_buffer->buffer[0] == '.') {\n"
"-      switch (do_meta_command(input_buffer)) {\n"
"+      switch (do_meta_command(input_buffer, table)) {\n"
"```\n"
"With these changes, we're able to close then reopen the database, and our records are still there!"
msgstr ""

#: ../../../_parts/part5.md:268
msgid ""
"```\n"
"~ ./db mydb.db\n"
"db > insert 1 cstack foo@bar.com\n"
"Executed.\n"
"db > insert 2 voltorb volty@example.com\n"
"Executed.\n"
"db > .exit\n"
"~\n"
"~ ./db mydb.db\n"
"db > select\n"
"(1, cstack, foo@bar.com)\n"
"(2, voltorb, volty@example.com)\n"
"Executed.\n"
"db > .exit\n"
"~\n"
"```"
msgstr ""

#: ../../../_parts/part5.md:285
msgid "For extra fun, let's take a look at `mydb.db` to see how our data is being stored. I'll use vim as a hex editor to look at the memory layout of the file:"
msgstr ""

#: ../../../_parts/part5.md:287
msgid ""
"```\n"
"vim mydb.db\n"
":%!xxd\n"
"```\n"
"{% include image.html url=\"assets/images/file-format.png\" description=\"Current File Format\" %}"
msgstr ""

#: ../../../_parts/part5.md:293
msgid "The first four bytes are the id of the first row (4 bytes because we store a `uint32_t`). It's stored in little-endian byte order, so the least significant byte comes first (01), followed by the higher-order bytes (00 00 00). We used `memcpy()` to copy bytes from our `Row` struct into the page cache, so that means the struct was laid out in memory in little-endian byte order. That's an attribute of the machine I compiled the program for. If we wanted to write a database file on my machine, then read it on a big-endian machine, we'd have to change our `serialize_row()` and `deserialize_row()` methods to always store and read bytes in the same order."
msgstr ""

#: ../../../_parts/part5.md:295
msgid "The next 33 bytes store the username as a null-terminated string. Apparently \"cstack\" in ASCII hexadecimal is `63 73 74 61 63 6b`, followed by a null character (`00`). The rest of the 33 bytes are unused."
msgstr ""

#: ../../../_parts/part5.md:297
msgid "The next 256 bytes store the email in the same way. Here we can see some random junk after the terminating null character. This is most likely due to uninitialized memory in our `Row` struct. We copy the entire 256-byte email buffer into the file, including any bytes after the end of the string. Whatever was in memory when we allocated that struct is still there. But since we use a terminating null character, it has no effect on behavior."
msgstr ""

#: ../../../_parts/part5.md:299
msgid ""
"**NOTE**: If we wanted to ensure that all bytes are initialized, it would\n"
"suffice to use `strncpy` instead of `memcpy` while copying the `username`\n"
"and `email` fields of rows in `serialize_row`, like so:"
msgstr ""

#: ../../../_parts/part5.md:303
msgid ""
"```diff\n"
" void serialize_row(Row* source, void* destination) {\n"
"     memcpy(destination + ID_OFFSET, &(source->id), ID_SIZE);\n"
"-    memcpy(destination + USERNAME_OFFSET, &(source->username), USERNAME_SIZE);\n"
"-    memcpy(destination + EMAIL_OFFSET, &(source->email), EMAIL_SIZE);\n"
"+    strncpy(destination + USERNAME_OFFSET, source->username, USERNAME_SIZE);\n"
"+    strncpy(destination + EMAIL_OFFSET, source->email, EMAIL_SIZE);\n"
" }\n"
"```"
msgstr ""

#: ../../../_parts/part5.md:313
msgid "## Conclusion"
msgstr ""

#: ../../../_parts/part5.md:315
msgid "Alright! We've got persistence. It's not the greatest. For example if you kill the program without typing `.exit`, you lose your changes. Additionally, we're writing all pages back to disk, even pages that haven't changed since we read them from disk. These are issues we can address later."
msgstr ""

#: ../../../_parts/part5.md:317
msgid "Next time we'll introduce cursors, which should make it easier to implement the B-tree."
msgstr ""

#: ../../../_parts/part5.md:319
msgid "Until then!"
msgstr ""

#: ../../../_parts/part5.md:321
msgid ""
"## Complete Diff\n"
"```diff\n"
"+#include <errno.h>\n"
"+#include <fcntl.h>\n"
" #include <stdbool.h>\n"
" #include <stdio.h>\n"
" #include <stdlib.h>\n"
" #include <string.h>\n"
" #include <stdint.h>\n"
"+#include <unistd.h>"
msgstr ""

#: ../../../_parts/part5.md:332
msgid ""
" struct InputBuffer_t {\n"
"   char* buffer;\n"
"@@ -62,9 +65,16 @@ const uint32_t PAGE_SIZE = 4096;\n"
" const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;\n"
" const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;"
msgstr ""

#: ../../../_parts/part5.md:338
msgid ""
"+typedef struct {\n"
"+  int file_descriptor;\n"
"+  uint32_t file_length;\n"
"+  void* pages[TABLE_MAX_PAGES];\n"
"+} Pager;\n"
"+\n"
" typedef struct {\n"
"   uint32_t num_rows;\n"
"-  void* pages[TABLE_MAX_PAGES];\n"
"+  Pager* pager;\n"
" } Table;"
msgstr ""

#: ../../../_parts/part5.md:350
msgid ""
"@@ -84,32 +94,81 @@ void deserialize_row(void *source, Row* destination) {\n"
"   memcpy(&(destination->email), source + EMAIL_OFFSET, EMAIL_SIZE);\n"
" }"
msgstr ""

#: ../../../_parts/part5.md:354
msgid ""
"+void* get_page(Pager* pager, uint32_t page_num) {\n"
"+  if (page_num > TABLE_MAX_PAGES) {\n"
"+     printf(\"Tried to fetch page number out of bounds. %d > %d\n"
"\", page_num,\n"
"+     \tTABLE_MAX_PAGES);\n"
"+     exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  if (pager->pages[page_num] == NULL) {\n"
"+     // Cache miss. Allocate memory and load from file.\n"
"+     void* page = malloc(PAGE_SIZE);\n"
"+     uint32_t num_pages = pager->file_length / PAGE_SIZE;\n"
"+\n"
"+     // We might save a partial page at the end of the file\n"
"+     if (pager->file_length % PAGE_SIZE) {\n"
"+         num_pages += 1;\n"
"+     }\n"
"+\n"
"+     if (page_num <= num_pages) {\n"
"+         lseek(pager->file_descriptor, page_num * PAGE_SIZE, SEEK_SET);\n"
"+         ssize_t bytes_read = read(pager->file_descriptor, page, PAGE_SIZE);\n"
"+         if (bytes_read == -1) {\n"
"+     \tprintf(\"Error reading file: %d\n"
"\", errno);\n"
"+     \texit(EXIT_FAILURE);\n"
"+         }\n"
"+     }\n"
"+\n"
"+     pager->pages[page_num] = page;\n"
"+  }\n"
"+\n"
"+  return pager->pages[page_num];\n"
"+}\n"
"+\n"
" void* row_slot(Table* table, uint32_t row_num) {\n"
"   uint32_t page_num = row_num / ROWS_PER_PAGE;\n"
"-  void *page = table->pages[page_num];\n"
"-  if (page == NULL) {\n"
"-     // Allocate memory only when we try to access page\n"
"-     page = table->pages[page_num] = malloc(PAGE_SIZE);\n"
"-  }\n"
"+  void *page = get_page(table->pager, page_num);\n"
"   uint32_t row_offset = row_num % ROWS_PER_PAGE;\n"
"   uint32_t byte_offset = row_offset * ROW_SIZE;\n"
"   return page + byte_offset;\n"
" }"
msgstr ""

#: ../../../_parts/part5.md:399
msgid ""
"-Table* new_table() {\n"
"-  Table* table = malloc(sizeof(Table));\n"
"-  table->num_rows = 0;\n"
"+Pager* pager_open(const char* filename) {\n"
"+  int fd = open(filename,\n"
"+     \t  O_RDWR | \t// Read/Write mode\n"
"+     \t      O_CREAT,\t// Create file if it does not exist\n"
"+     \t  S_IWUSR |\t// User write permission\n"
"+     \t      S_IRUSR\t// User read permission\n"
"+     \t  );\n"
"+\n"
"+  if (fd == -1) {\n"
"+     printf(\"Unable to open file\n"
"\");\n"
"+     exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  off_t file_length = lseek(fd, 0, SEEK_END);\n"
"+\n"
"+  Pager* pager = malloc(sizeof(Pager));\n"
"+  pager->file_descriptor = fd;\n"
"+  pager->file_length = file_length;\n"
"+\n"
"   for (uint32_t i = 0; i < TABLE_MAX_PAGES; i++) {\n"
"-     table->pages[i] = NULL;\n"
"+     pager->pages[i] = NULL;\n"
"   }\n"
"-  return table;\n"
"+\n"
"+  return pager;\n"
" }"
msgstr ""

#: ../../../_parts/part5.md:430
msgid ""
"-void free_table(Table* table) {\n"
"-  for (int i = 0; table->pages[i]; i++) {\n"
"-     free(table->pages[i]);\n"
"-  }\n"
"-  free(table);\n"
"+Table* db_open(const char* filename) {\n"
"+  Pager* pager = pager_open(filename);\n"
"+  uint32_t num_rows = pager->file_length / ROW_SIZE;\n"
"+\n"
"+  Table* table = malloc(sizeof(Table));\n"
"+  table->pager = pager;\n"
"+  table->num_rows = num_rows;\n"
"+\n"
"+  return table;\n"
" }"
msgstr ""

#: ../../../_parts/part5.md:446
msgid ""
" InputBuffer* new_input_buffer() {\n"
"@@ -142,10 +201,76 @@ void close_input_buffer(InputBuffer* input_buffer) {\n"
"   free(input_buffer);\n"
" }"
msgstr ""

#: ../../../_parts/part5.md:451
msgid ""
"+void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {\n"
"+  if (pager->pages[page_num] == NULL) {\n"
"+     printf(\"Tried to flush null page\n"
"\");\n"
"+     exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  off_t offset = lseek(pager->file_descriptor, page_num * PAGE_SIZE,\n"
"+     \t\t SEEK_SET);\n"
"+\n"
"+  if (offset == -1) {\n"
"+     printf(\"Error seeking: %d\n"
"\", errno);\n"
"+     exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  ssize_t bytes_written = write(\n"
"+     pager->file_descriptor, pager->pages[page_num], size\n"
"+     );\n"
"+\n"
"+  if (bytes_written == -1) {\n"
"+     printf(\"Error writing: %d\n"
"\", errno);\n"
"+     exit(EXIT_FAILURE);\n"
"+  }\n"
"+}\n"
"+\n"
"+void db_close(Table* table) {\n"
"+  Pager* pager = table->pager;\n"
"+  uint32_t num_full_pages = table->num_rows / ROWS_PER_PAGE;\n"
"+\n"
"+  for (uint32_t i = 0; i < num_full_pages; i++) {\n"
"+     if (pager->pages[i] == NULL) {\n"
"+         continue;\n"
"+     }\n"
"+     pager_flush(pager, i, PAGE_SIZE);\n"
"+     free(pager->pages[i]);\n"
"+     pager->pages[i] = NULL;\n"
"+  }\n"
"+\n"
"+  // There may be a partial page to write to the end of the file\n"
"+  // This should not be needed after we switch to a B-tree\n"
"+  uint32_t num_additional_rows = table->num_rows % ROWS_PER_PAGE;\n"
"+  if (num_additional_rows > 0) {\n"
"+     uint32_t page_num = num_full_pages;\n"
"+     if (pager->pages[page_num] != NULL) {\n"
"+         pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);\n"
"+         free(pager->pages[page_num]);\n"
"+         pager->pages[page_num] = NULL;\n"
"+     }\n"
"+  }\n"
"+\n"
"+  int result = close(pager->file_descriptor);\n"
"+  if (result == -1) {\n"
"+     printf(\"Error closing db file.\n"
"\");\n"
"+     exit(EXIT_FAILURE);\n"
"+  }\n"
"+  for (uint32_t i = 0; i < TABLE_MAX_PAGES; i++) {\n"
"+     void* page = pager->pages[i];\n"
"+     if (page) {\n"
"+         free(page);\n"
"+         pager->pages[i] = NULL;\n"
"+     }\n"
"+  }\n"
"+\n"
"+  free(pager);\n"
"+  free(table);\n"
"+}\n"
"+\n"
" MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table *table) {\n"
"   if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"     close_input_buffer(input_buffer);\n"
"-    free_table(table);\n"
"+    db_close(table);\n"
"     exit(EXIT_SUCCESS);\n"
"   } else {\n"
"     return META_COMMAND_UNRECOGNIZED_COMMAND;\n"
"@@ -182,6 +308,7 @@ PrepareResult prepare_insert(InputBuffer* input_buffer, Statement* statement) {\n"
"     return PREPARE_SUCCESS;"
msgstr ""

#: ../../../_parts/part5.md:528
msgid ""
" }\n"
"+\n"
" PrepareResult prepare_statement(InputBuffer* input_buffer,\n"
"                                 Statement* statement) {\n"
"   if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n"
"@@ -227,7 +354,14 @@ ExecuteResult execute_statement(Statement* statement, Table *table) {\n"
" }"
msgstr ""

#: ../../../_parts/part5.md:536
msgid ""
" int main(int argc, char* argv[]) {\n"
"-  Table* table = new_table();\n"
"+  if (argc < 2) {\n"
"+      printf(\"Must supply a database filename.\n"
"\");\n"
"+      exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  char* filename = argv[1];\n"
"+  Table* table = db_open(filename);\n"
"+\n"
"   InputBuffer* input_buffer = new_input_buffer();\n"
"   while (true) {\n"
"     print_prompt();\n"
"```"
msgstr ""

#: ../../../_parts/part5.md:551
msgid ""
"And the diff to our tests:\n"
"```diff\n"
" describe 'database' do\n"
"+  before do\n"
"+    `rm -rf test.db`\n"
"+  end\n"
"+\n"
"   def run_script(commands)\n"
"     raw_output = nil\n"
"-    IO.popen(\"./db\", \"r+\") do |pipe|\n"
"+    IO.popen(\"./db test.db\", \"r+\") do |pipe|\n"
"       commands.each do |command|\n"
"         pipe.puts command\n"
"       end\n"
"@@ -28,6 +32,27 @@ describe 'database' do\n"
"     ])\n"
"   end"
msgstr ""

#: ../../../_parts/part5.md:569
msgid ""
"+  it 'keeps data after closing connection' do\n"
"+    result1 = run_script([\n"
"+      \"insert 1 user1 person1@example.com\",\n"
"+      \".exit\",\n"
"+    ])\n"
"+    expect(result1).to match_array([\n"
"+      \"db > Executed.\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+\n"
"+    result2 = run_script([\n"
"+      \"select\",\n"
"+      \".exit\",\n"
"+    ])\n"
"+    expect(result2).to match_array([\n"
"+      \"db > (1, user1, person1@example.com)\",\n"
"+      \"Executed.\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
"+\n"
"   it 'prints error message when table is full' do\n"
"     script = (1..1401).map do |i|\n"
"       \"insert #{i} user#{i} person#{i}@example.com\"\n"
"```"
msgstr ""
