msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=; plural=;\n"

msgid ""
"---\n"
"title: Part 1 - Introduction and Setting up the REPL\n"
"date: 2017-08-30\n"
"---"
msgstr ""
"---\n"
"title: パート1 - イントロダクションとREPLのセットアップ\n"
"date: 2017-08-30\n"
"---"

msgid ""
"As a web developer, I use relational databases every day at my job, but they'r"
"e a black box to me. Some questions I have:\n"
"- What format is data saved in? (in memory and on disk)\n"
"- When does it move from memory to disk?\n"
"- Why can there only be one primary key per table?\n"
"- How does rolling back a transaction work?\n"
"- How are indexes formatted?\n"
"- When and how does a full table scan happen?\n"
"- What format is a prepared statement saved in?"
msgstr ""
"web開発者として、[私](https://github.com/cstack)はデータベースを毎日使います。しかしデータベースの中身がブラックボックスのよ"
"うに感じます。いくつか不思議に思っていることがあります。:\n"
"- データは(メモリと外部記憶装置などにおいて)どのようにして保存されるのでしょうか?\n"
"- いつデータはメモリから外部記憶装置に移されるのでしょうか?\n"
"- なぜテーブルごとのキーは一意なのでしょうか?\n"
"- トランザクションのローリングバックの仕組みはどのようなものなのでしょうか?\n"
"- インデックスのフォーマットの仕組みはどのようなものでしょうか?\n"
"- いつ、どんな感じで、テーブルが満タンになったとき何が起きるのでしょうか?\n"
"- プリペアドステートメントはどのようなフォーマットで保存されるのでしょうか?"

msgid "In other words, how does a database **work**?"
msgstr "手短に言うと、どのようにしてデータベースは**動くのでしょうか?**"

msgid ""
"To figure things out, I'm writing a database from scratch. It's modeled off sq"
"lite because it is designed to be small with fewer features than MySQL or Post"
"greSQL, so I have a better hope of understanding it. The entire database is st"
"ored in a single file!"
msgstr ""
"これらの謎を解くために、私はデータベースをフルスクラッチで作っています。MySQLやPostgreSQLといったものよりも軽量で、機能も少ないためsqlit"
"eをモデルにしました。なので、データベースをより理解しやすくなったと思っています。実はデータベースは一つのファイルに、保存されているのです!"

msgid "# Sqlite"
msgstr "# Sqlite"

msgid ""
"There's lots of [documentation of sqlite internals](https://www.sqlite.org/arc"
"h.html) on their website, plus I've got a copy of [SQLite Database System: Des"
"ign and Implementation](https://play.google.com/store/books/details?id=9Z6IQQn"
"X1JEC)."
msgstr ""
"[sqliteの仕組み](https://www.sqlite.org/arch.html)がsqliteのサイトにあり, そして私は[SQLite Dat"
"abase System: Design and Implementation](https://play.google.com/store/books/d"
"etails?id=9Z6IQQnX1JEC)という電子書籍を持っています。"

msgid ""
"{% include image.html url=\"assets/images/arch1.gif\" description=\"sqlite archit"
"ecture (https://www.sqlite.org/zipvfs/doc/trunk/www/howitworks.wiki)\" %}"
msgstr ""
"{% include image.html url=\"assets/images/arch1.gif\" description=\"sqliteの構造(htt"
"ps://www.sqlite.org/zipvfs/doc/trunk/www/howitworks.wiki)\" %}"

msgid ""
"A query goes through a chain of components in order to retrieve or modify data"
". The **front-end** consists of the:\n"
"- tokenizer\n"
"- parser\n"
"- code generator"
msgstr ""
"クエリは以下のような手順で、取得や変更したデータを解析しています。**フロントエンド** はこれらの要素から構成されています。:\n"
"- 字句解析(tokenizer)\n"
"- パーサー(parser)\n"
"- コード生成"

msgid ""
"The input to the front-end is a SQL query. the output is sqlite virtual machin"
"e bytecode (essentially a compiled program that can operate on the database)."
msgstr ""
"SQLクエリがフロントエンドに入力された時、出力はsqliteの仮想マシンの中間コードへ変換されます。(データベースを操作するには、コンパイルされたプログラ"
"ムが必要なのです。)"

msgid ""
"The _back-end_ consists of the:\n"
"- virtual machine\n"
"- B-tree\n"
"- pager\n"
"- os interface"
msgstr ""
"_バックエンド_ はこれらの要素から成り立っています:\n"
"- 仮想マシン\n"
"- B木\n"
"- ページャー\n"
"- OSインターフェース"

msgid ""
"The **virtual machine** takes bytecode generated by the front-end as instructi"
"ons. It can then perform operations on one or more tables or indexes, each of "
"which is stored in a data structure called a B-tree. The VM is essentially a b"
"ig switch statement on the type of bytecode instruction."
msgstr ""
"**仮想マシン**はフロントエンドの段階で生成されたバイトコードを使用します。B木と呼ばれるデータ構造にそれぞれのデータは保存され、多数のテーブルやインデッ"
"クスを操作します。仮想マシンはバイトコードの実行を切り替えるのに必要です。"

msgid ""
"Each **B-tree** consists of many nodes. Each node is one page in length. The B"
"-tree can retrieve a page from disk or save it back to disk by issuing command"
"s to the pager."
msgstr ""
"**B木**は多くのノードから成り立っています。それらは一つのページに収められています。B木はページャーにディスクに戻す命令を発行し、ディスクからページを取"
"得したり保存します。"

msgid ""
"The **pager** receives commands to read or write pages of data. It is responsi"
"ble for reading/writing at appropriate offsets in the database file. It also k"
"eeps a cache of recently-accessed pages in memory, and determines when those p"
"ages need to be written back to disk."
msgstr ""
"**ページャー**はデータを読み書きする命令を出します。ページャーはデータベースを適切なオフセットで読み書きします。ページャーはメモリに最近使用したページの"
"キャッシュを保存し、ディスクにページを書き戻す時に使用されます。"

msgid ""
"The **os interface** is the layer that differs depending on which operating sy"
"stem sqlite was compiled for. In this tutorial, I'm not going to support multi"
"ple platforms."
msgstr "**os interface**はsqliteがコンパイルされたOSによって異なります。このチュートリアルは、様々なプラットフォームをサポートします。"

msgid ""
"[A journey of a thousand miles begins with a single step](https://en.wiktionar"
"y.org/wiki/a_journey_of_a_thousand_miles_begins_with_a_single_step), so let's "
"start with something a little more straightforward: the REPL."
msgstr ""
"[千里の道は一歩から!](https://ja.wiktionary.org/wiki/%E5%8D%83%E9%87%8C%E3%81%AE%E9%81%"
"93%E3%82%82%E4%B8%80%E6%AD%A9%E3%81%8B%E3%82%89)、簡単なところから始めましょう!:REPL"

msgid "## Making a Simple REPL"
msgstr "## シンプルなREPLを作ってみよう!"

msgid ""
"Sqlite starts a read-execute-print loop when you start it from the command lin"
"e:"
msgstr "Sqliteはコマンドラインから起動すると、REPLになります。:"

msgid ""
"```shell\n"
"~ sqlite3\n"
"SQLite version 3.16.0 2016-11-04 19:09:39\n"
"Enter \".help\" for usage hints.\n"
"Connected to a transient in-memory database.\n"
"Use \".open FILENAME\" to reopen on a persistent database.\n"
"sqlite> create table users (id int, username varchar(255), email varchar(255))"
";\n"
"sqlite> .tables\n"
"users\n"
"sqlite> .exit\n"
"~\n"
"```"
msgstr ""

msgid ""
"To do that, our main function will have an infinite loop that prints the promp"
"t, gets a line of input, then processes that line of input:"
msgstr "このような処理を行うため、メイン関数は、プロンプトを表示して、入力を読み込み、それを処理する無限ループへ入ります。:"

msgid ""
"```c\n"
"int main(int argc, char* argv[]) {\n"
"  InputBuffer* input_buffer = new_input_buffer();\n"
"  while (true) {\n"
"    print_prompt();\n"
"    read_input(input_buffer);"
msgstr ""
"```c\n"
"int main(int argc, char* argv[]) {\n"
"  InputBuffer* input_buffer = new_input_buffer();\n"
"  while (true) {\n"
"    print_prompt();\n"
"    read_input(input_buffer);"

msgid ""
"    if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"      close_input_buffer(input_buffer);\n"
"      exit(EXIT_SUCCESS);\n"
"    } else {\n"
"      printf(\"Unrecognized command '%s'.\n"
"\", input_buffer->buffer);\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""
"    if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"      close_input_buffer(input_buffer);\n"
"      exit(EXIT_SUCCESS);\n"
"    } else {\n"
"      printf(\"'%s'は認識できないコマンドです。\n"
"\", input_buffer->buffer);\n"
"    }\n"
"  }\n"
"}\n"
"```"

msgid ""
"We'll define `InputBuffer` as a small wrapper around the state we need to stor"
"e to interact with [getline()](http://man7.org/linux/man-pages/man3/getline.3."
"html). (More on that in a minute)\n"
"```c\n"
"typedef struct {\n"
"  char* buffer;\n"
"  size_t buffer_length;\n"
"  ssize_t input_length;\n"
"} InputBuffer;"
msgstr ""
"`InputBuffer`を[getline()](https://manpages.debian.org/unstable/manpages-ja-dev"
"/getline.3.ja.html)関数で、保存するためのラッパー変数として使用します。(このことについて、後程述べたいと思います。)\n"
"```c\n"
"typedef struct {\n"
"  char* buffer;\n"
"  size_t buffer_length;\n"
"  ssize_t input_length;\n"
"} InputBuffer;"

msgid ""
"InputBuffer* new_input_buffer() {\n"
"  InputBuffer* input_buffer = (InputBuffer*)malloc(sizeof(InputBuffer));\n"
"  input_buffer->buffer = NULL;\n"
"  input_buffer->buffer_length = 0;\n"
"  input_buffer->input_length = 0;"
msgstr ""
"InputBuffer* new_input_buffer() {\n"
"  InputBuffer* input_buffer = (InputBuffer*)malloc(sizeof(InputBuffer));\n"
"  input_buffer->buffer = NULL;\n"
"  input_buffer->buffer_length = 0;\n"
"  input_buffer->input_length = 0;"

msgid ""
"  return input_buffer;\n"
"}\n"
"```"
msgstr ""
"  return input_buffer;\n"
"}\n"
"```"

msgid ""
"Next, `print_prompt()` prints a prompt to the user. We do this before reading "
"each line of input."
msgstr "次に、`print_prompt()`はユーザーにプロンプトを表示する関数です。入力を読み取る前にこれを実行します。"

msgid ""
"```c\n"
"void print_prompt() { printf(\"db > \"); }\n"
"```"
msgstr ""
"```c\n"
"void print_prompt() { printf(\"db > \"); }\n"
"```"

msgid ""
"To read a line of input, use [getline()](http://man7.org/linux/man-pages/man3/"
"getline.3.html):\n"
"```c\n"
"ssize_t getline(char **lineptr, size_t *n, FILE *stream);\n"
"```\n"
"`lineptr` : a pointer to the variable we use to point to the buffer containing"
" the read line. If it set to `NULL` it is mallocatted by `getline` and should "
"thus be freed by the user, even if the command fails."
msgstr ""
"入力されたものを読み込むため、[getline()](https://manpages.debian.org/unstable/manpages-ja-de"
"v/getline.3.ja.html)関数を使います。:\n"
"```c\n"
"ssize_t getline(char **lineptr, size_t *n, FILE *stream);\n"
"```\n"
"`lineptr` : は読み込んだものを保存しているバッファを指し示すポインタ変数です。もし`NULL`が設定されていれば、`getline`によって割り"
"当てられた時、コマンドが失敗したとしても、ユーザーは明示的に解放する必要があります。"

msgid "`n` : a pointer to the variable we use to save the size of allocated buffer."
msgstr "`n` : 割り当てられたバッファサイズを保存するポインタ変数です。"

msgid ""
"`stream` : the input stream to read from. We'll be reading from standard input"
"."
msgstr "`stream` : 入力ストリームから読み込んだ変数を表しています。標準入力から読み込まれます。"

msgid ""
"`return value` : the number of bytes read, which may be less than the size of "
"the buffer."
msgstr "`return value` : これの戻り値は読み込んだバイト数を表していて、バッファのサイズより小さいときもあります。"

msgid ""
"We tell `getline` to store the read line in `input_buffer->buffer` and the siz"
"e of the allocated buffer in `input_buffer->buffer_length`. We store the retur"
"n value in `input_buffer->input_length`."
msgstr ""
"`getline`は読み込んだ行を`input_buffer->buffer`保存し、割り当てられたバッファのサイズを`input_buffer->buff"
"er_length`に保存します。戻り値を`input_buffer->input_length`に保存します。"

msgid ""
"`buffer` starts as null, so `getline` allocates enough memory to hold the line"
" of input and makes `buffer` point to it."
msgstr "`buffer`はNULLで始まるため、`getline`は、入力したものを保存するために必要なメモリを割り当てて、`buffer`がそれを指し示します。"

msgid ""
"```c\n"
"void read_input(InputBuffer* input_buffer) {\n"
"  ssize_t bytes_read =\n"
"      getline(&(input_buffer->buffer), &(input_buffer->buffer_length), stdin);"
msgstr ""
"```c\n"
"void read_input(InputBuffer* input_buffer) {\n"
"  ssize_t bytes_read =\n"
"      getline(&(input_buffer->buffer), &(input_buffer->buffer_length), stdin);"

msgid ""
"  if (bytes_read <= 0) {\n"
"    printf(\"Error reading input\n"
"\");\n"
"    exit(EXIT_FAILURE);\n"
"  }"
msgstr ""
"  if (bytes_read <= 0) {\n"
"    printf(\"入力エラー!\n"
"\");\n"
"    exit(EXIT_FAILURE);\n"
"  }"

msgid ""
"  // Ignore trailing newline\n"
"  input_buffer->input_length = bytes_read - 1;\n"
"  input_buffer->buffer[bytes_read - 1] = 0;\n"
"}\n"
"```"
msgstr ""
"  // 最後の行の改行を無視する\n"
"  input_buffer->input_length = bytes_read - 1;\n"
"  input_buffer->buffer[bytes_read - 1] = 0;\n"
"}\n"
"```"

msgid ""
"Now it is proper to define a function that frees the memory allocated for an\n"
"instance of `InputBuffer *` and the `buffer` element of the respective\n"
"structure (`getline` allocates memory for `input_buffer->buffer` in\n"
"`read_input`)."
msgstr ""
"ここで、`InputBuffer *`のインスタンス変数と`buffer`の要素のメモリを\n"
"解放する関数が必要です。\n"
"(`getline`は`read_input`の中の`input_buffer->buffer`へメモリを割り当てます。\n"
")。"

msgid ""
"```c\n"
"void close_input_buffer(InputBuffer* input_buffer) {\n"
"    free(input_buffer->buffer);\n"
"    free(input_buffer);\n"
"}\n"
"```"
msgstr ""
"```c\n"
"void close_input_buffer(InputBuffer* input_buffer) {\n"
"    free(input_buffer->buffer);\n"
"    free(input_buffer);\n"
"}\n"
"```"

msgid ""
"Finally, we parse and execute the command. There is only one recognized comman"
"d right now : `.exit`, which terminates the program. Otherwise we print an err"
"or message and continue the loop."
msgstr ""
"最後に、私たちはパースして、コマンドを実行します。たった一つの今すぐ実行できるコマンドがあります。: `.exit`それはプログラムを終了するというコマンド"
"です。さもなければ、私たちはエラーを出力して、ループを継続します。"

msgid ""
"```c\n"
"if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"  close_input_buffer(input_buffer);\n"
"  exit(EXIT_SUCCESS);\n"
"} else {\n"
"  printf(\"Unrecognized command '%s'.\n"
"\", input_buffer->buffer);\n"
"}\n"
"```"
msgstr ""
"```c\n"
"if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"  close_input_buffer(input_buffer);\n"
"  exit(EXIT_SUCCESS);\n"
"} else {\n"
"  printf(\"'%s'は認識できないコマンドです。\n"
"\", input_buffer->buffer);\n"
"}\n"
"```"

msgid ""
"Let's try it out!\n"
"```shell\n"
"~ ./db\n"
"db > .tables\n"
"Unrecognized command '.tables'.\n"
"db > .exit\n"
"~\n"
"```"
msgstr ""
"試してみましょう!\n"
"```shell\n"
"~ ./db\n"
"db > .tables\n"
"'.tables'は認識できません\n"
"db > .exit\n"
"~\n"
"```"

msgid ""
"Alright, we've got a working REPL. In the next part, we'll start developing ou"
"r command language. Meanwhile, here's the entire program from this part:"
msgstr "さて、動作できるREPLを完成させました!次のパートでは、オリジナルのコマンドライン言語を開発します。さて、今まで作成したプログラムの全体図を示します。:"

msgid ""
"```c\n"
"#include <stdbool.h>\n"
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <string.h>"
msgstr ""
"```c\n"
"#include <stdbool.h>\n"
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <string.h>"

msgid ""
"typedef struct {\n"
"  char* buffer;\n"
"  size_t buffer_length;\n"
"  ssize_t input_length;\n"
"} InputBuffer;"
msgstr ""
"typedef struct {\n"
"  char* buffer;\n"
"  size_t buffer_length;\n"
"  ssize_t input_length;\n"
"} InputBuffer;"

msgid ""
"InputBuffer* new_input_buffer() {\n"
"  InputBuffer* input_buffer = malloc(sizeof(InputBuffer));\n"
"  input_buffer->buffer = NULL;\n"
"  input_buffer->buffer_length = 0;\n"
"  input_buffer->input_length = 0;"
msgstr ""
"InputBuffer* new_input_buffer() {\n"
"  InputBuffer* input_buffer = malloc(sizeof(InputBuffer));\n"
"  input_buffer->buffer = NULL;\n"
"  input_buffer->buffer_length = 0;\n"
"  input_buffer->input_length = 0;"

msgid ""
"  return input_buffer;\n"
"}"
msgstr ""
"  return input_buffer;\n"
"}"

msgid "void print_prompt() { printf(\"db > \"); }"
msgstr "void print_prompt() { printf(\"db > \"); }"

msgid ""
"void read_input(InputBuffer* input_buffer) {\n"
"  ssize_t bytes_read =\n"
"      getline(&(input_buffer->buffer), &(input_buffer->buffer_length), stdin);"
msgstr ""
"void read_input(InputBuffer* input_buffer) {\n"
"  ssize_t bytes_read =\n"
"      getline(&(input_buffer->buffer), &(input_buffer->buffer_length), stdin);"

msgid ""
"  // Ignore trailing newline\n"
"  input_buffer->input_length = bytes_read - 1;\n"
"  input_buffer->buffer[bytes_read - 1] = 0;\n"
"}"
msgstr ""
"  // 最後の行の改行を無視する\n"
"  input_buffer->input_length = bytes_read - 1;\n"
"  input_buffer->buffer[bytes_read - 1] = 0;\n"
"}"

msgid ""
"void close_input_buffer(InputBuffer* input_buffer) {\n"
"    free(input_buffer->buffer);\n"
"    free(input_buffer);\n"
"}"
msgstr ""
"void close_input_buffer(InputBuffer* input_buffer) {\n"
"    free(input_buffer->buffer);\n"
"    free(input_buffer);\n"
"}"

msgid ""
"int main(int argc, char* argv[]) {\n"
"  InputBuffer* input_buffer = new_input_buffer();\n"
"  while (true) {\n"
"    print_prompt();\n"
"    read_input(input_buffer);"
msgstr ""
"int main(int argc, char* argv[]) {\n"
"  InputBuffer* input_buffer = new_input_buffer();\n"
"  while (true) {\n"
"    print_prompt();\n"
"    read_input(input_buffer);"
