msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=; plural=;\n"

msgid ""
"---\n"
"title: Part 7 - Introduction to the B-Tree\n"
"date: 2017-09-23\n"
"---"
msgstr ""

msgid ""
"The B-Tree is the data structure SQLite uses to represent both tables and inde"
"xes, so it's a pretty central idea. This article will just introduce the data "
"structure, so it won't have any code."
msgstr ""

msgid "Why is a tree a good data structure for a database?"
msgstr ""

msgid ""
"- Searching for a particular value is fast (logarithmic time)\n"
"- Inserting / deleting a value you've already found is fast (constant-ish time"
" to rebalance)\n"
"- Traversing a range of values is fast (unlike a hash map)"
msgstr ""

msgid ""
"A B-Tree is different from a binary tree (the \"B\" probably stands for the inve"
"ntor's name, but could also stand for \"balanced\"). Here's an example B-Tree:"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/B-tree.png\" description=\"example B-Tr"
"ee (https://en.wikipedia.org/wiki/File:B-tree.svg)\" %}"
msgstr ""

msgid ""
"Unlike a binary tree, each node in a B-Tree can have more than 2 children. Eac"
"h node can have up to m children, where m is called the tree's \"order\". To kee"
"p the tree mostly balanced, we also say nodes have to have at least m/2 childr"
"en (rounded up)."
msgstr ""

msgid ""
"Exceptions:\n"
"- Leaf nodes have 0 children\n"
"- The root node can have fewer than m children but must have at least 2\n"
"- If the root node is a leaf node (the only node), it still has 0 children"
msgstr ""

msgid ""
"The picture from above is a B-Tree, which SQLite uses to store indexes. To sto"
"re tables, SQLites uses a variation called a B+ tree."
msgstr ""

msgid ""
"|                               | B-tree         | B+ tree             |\n"
"|-------------------------------|----------------|---------------------|\n"
"| Pronounced                    | \"Bee Tree\"     | \"Bee Plus Tree\"     |\n"
"| Used to store                 | Indexes        | Tables              |\n"
"| Internal nodes store keys     | Yes            | Yes                 |\n"
"| Internal nodes store values   | Yes            | No                  |\n"
"| Number of children per node   | Less           | More                |\n"
"| Internal nodes vs. leaf nodes | Same structure | Different structure |"
msgstr ""

msgid ""
"Until we get to implementing indexes, I'm going to talk solely about B+ trees,"
" but I'll just refer to it as a B-tree or a btree."
msgstr ""

msgid ""
"Nodes with children are called \"internal\" nodes. Internal nodes and leaf nodes"
" are structured differently:"
msgstr ""

msgid ""
"| For an order-m tree... | Internal Node                 | Leaf Node          "
" |\n"
"|------------------------|-------------------------------|--------------------"
"-|\n"
"| Stores                 | keys and pointers to children | keys and values    "
" |\n"
"| Number of keys         | up to m-1                     | as many as will fit"
" |\n"
"| Number of pointers     | number of keys + 1            | none               "
" |\n"
"| Number of values       | none                          | number of keys     "
" |\n"
"| Key purpose            | used for routing              | paired with value  "
" |\n"
"| Stores values?         | No                            | Yes                "
" |"
msgstr ""

msgid ""
"Let's work through an example to see how a B-tree grows as you insert elements"
" into it. To keep things simple, the tree will be order 3. That means:"
msgstr ""

msgid ""
"- up to 3 children per internal node\n"
"- up to 2 keys per internal node\n"
"- at least 2 children per internal node\n"
"- at least 1 key per internal node"
msgstr ""

msgid ""
"An empty B-tree has a single node: the root node. The root node starts as a le"
"af node with zero key/value pairs:"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/btree1.png\" description=\"empty btree\""
" %}"
msgstr ""

msgid ""
"If we insert a couple key/value pairs, they are stored in the leaf node in sor"
"ted order."
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/btree2.png\" description=\"one-node btr"
"ee\" %}"
msgstr ""

msgid ""
"Let's say that the capacity of a leaf node is two key/value pairs. When we ins"
"ert another, we have to split the leaf node and put half the pairs in each nod"
"e. Both nodes become children of a new internal node which will now be the roo"
"t node."
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/btree3.png\" description=\"two-level bt"
"ree\" %}"
msgstr ""

msgid ""
"The internal node has 1 key and 2 pointers to child nodes. If we want to look "
"up a key that is less than or equal to 5, we look in the left child. If we wan"
"t to look up a key greater than 5, we look in the right child."
msgstr ""

msgid ""
"Now let's insert the key \"2\". First we look up which leaf node it would be in "
"if it was present, and we arrive at the left leaf node. The node is full, so w"
"e split the leaf node and create a new entry in the parent node."
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/btree4.png\" description=\"four-node bt"
"ree\" %}"
msgstr ""

msgid ""
"Let's keep adding keys. 18 and 21. We get to the point where we have to split "
"again, but there's no room in the parent node for another key/pointer pair."
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/btree5.png\" description=\"no room in i"
"nternal node\" %}"
msgstr ""

msgid ""
"The solution is to split the root node into two internal nodes, then create ne"
"w root node to be their parent."
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/btree6.png\" description=\"three-level "
"btree\" %}"
msgstr ""

msgid ""
"The depth of the tree only increases when we split the root node. Every leaf n"
"ode has the same depth and close to the same number of key/value pairs, so the"
" tree remains balanced and quick to search."
msgstr ""

msgid ""
"I'm going to hold off on discussion of deleting keys from the tree until after"
" we've implemented insertion."
msgstr ""

msgid ""
"When we implement this data structure, each node will correspond to one page. "
"The root node will exist in page 0. Child pointers will simply be the page num"
"ber that contains the child node."
msgstr ""

msgid "Next time, we start implementing the btree!"
msgstr ""
