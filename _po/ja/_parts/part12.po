msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=; plural=;\n"

msgid ""
"---\n"
"title: Part 12 - Scanning a Multi-Level B-Tree\n"
"date: 2017-11-11\n"
"---"
msgstr ""

msgid ""
"We now support constructing a multi-level btree, but we've broken `select` sta"
"tements in the process. Here's a test case that inserts 15 rows and then tries"
" to print them."
msgstr ""

msgid ""
"```diff\n"
"+  it 'prints all rows in a multi-level tree' do\n"
"+    script = []\n"
"+    (1..15).each do |i|\n"
"+      script << \"insert #{i} user#{i} person#{i}@example.com\"\n"
"+    end\n"
"+    script << \"select\"\n"
"+    script << \".exit\"\n"
"+    result = run_script(script)\n"
"+\n"
"+    expect(result[15...result.length]).to match_array([\n"
"+      \"db > (1, user1, person1@example.com)\",\n"
"+      \"(2, user2, person2@example.com)\",\n"
"+      \"(3, user3, person3@example.com)\",\n"
"+      \"(4, user4, person4@example.com)\",\n"
"+      \"(5, user5, person5@example.com)\",\n"
"+      \"(6, user6, person6@example.com)\",\n"
"+      \"(7, user7, person7@example.com)\",\n"
"+      \"(8, user8, person8@example.com)\",\n"
"+      \"(9, user9, person9@example.com)\",\n"
"+      \"(10, user10, person10@example.com)\",\n"
"+      \"(11, user11, person11@example.com)\",\n"
"+      \"(12, user12, person12@example.com)\",\n"
"+      \"(13, user13, person13@example.com)\",\n"
"+      \"(14, user14, person14@example.com)\",\n"
"+      \"(15, user15, person15@example.com)\",\n"
"+      \"Executed.\", \"db > \",\n"
"+    ])\n"
"+  end\n"
"```"
msgstr ""

msgid "But when we run that test case right now, what actually happens is:"
msgstr ""

msgid ""
"```\n"
"db > select\n"
"(2, user1, person1@example.com)\n"
"Executed.\n"
"```"
msgstr ""

msgid ""
"That's weird. It's only printing one row, and that row looks corrupted (notice"
" the id doesn't match the username)."
msgstr ""

msgid ""
"The weirdness is because `execute_select()` begins at the start of the table, "
"and our current implementation of `table_start()` returns cell 0 of the root n"
"ode. But the root of our tree is now an internal node which doesn't contain an"
"y rows. The data that was printed must have been left over from when the root "
"node was a leaf. `execute_select()` should really return cell 0 of the leftmos"
"t leaf node."
msgstr ""

msgid "So get rid of the old implementation:"
msgstr ""

msgid ""
"```diff\n"
"-Cursor* table_start(Table* table) {\n"
"-  Cursor* cursor = malloc(sizeof(Cursor));\n"
"-  cursor->table = table;\n"
"-  cursor->page_num = table->root_page_num;\n"
"-  cursor->cell_num = 0;\n"
"-\n"
"-  void* root_node = get_page(table->pager, table->root_page_num);\n"
"-  uint32_t num_cells = *leaf_node_num_cells(root_node);\n"
"-  cursor->end_of_table = (num_cells == 0);\n"
"-\n"
"-  return cursor;\n"
"-}\n"
"```"
msgstr ""

msgid ""
"And add a new implementation that searches for key 0 (the minimum possible key"
"). Even if key 0 does not exist in the table, this method will return the posi"
"tion of the lowest id (the start of the left-most leaf node)."
msgstr ""

msgid ""
"```diff\n"
"+Cursor* table_start(Table* table) {\n"
"+  Cursor* cursor =  table_find(table, 0);\n"
"+\n"
"+  void* node = get_page(table->pager, cursor->page_num);\n"
"+  uint32_t num_cells = *leaf_node_num_cells(node);\n"
"+  cursor->end_of_table = (num_cells == 0);\n"
"+\n"
"+  return cursor;\n"
"+}\n"
"```"
msgstr ""

msgid "With those changes, it still only prints out one node's worth of rows:"
msgstr ""

msgid ""
"```\n"
"db > select\n"
"(1, user1, person1@example.com)\n"
"(2, user2, person2@example.com)\n"
"(3, user3, person3@example.com)\n"
"(4, user4, person4@example.com)\n"
"(5, user5, person5@example.com)\n"
"(6, user6, person6@example.com)\n"
"(7, user7, person7@example.com)\n"
"Executed.\n"
"db >\n"
"```"
msgstr ""

msgid ""
"With 15 entries, our btree consists of one internal node and two leaf nodes, w"
"hich looks something like this:"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/btree3.png\" description=\"structure of"
" our btree\" %}"
msgstr ""

msgid ""
"To scan the entire table, we need to jump to the second leaf node after we rea"
"ch the end of the first. To do that, we're going to save a new field in the le"
"af node header called \"next_leaf\", which will hold the page number of the leaf"
"'s sibling node on the right. The rightmost leaf node will have a `next_leaf` "
"value of 0 to denote no sibling (page 0 is reserved for the root node of the t"
"able anyway)."
msgstr ""

msgid "Update the leaf node header format to include the new field:"
msgstr ""

msgid ""
"```diff\n"
" const uint32_t LEAF_NODE_NUM_CELLS_SIZE = sizeof(uint32_t);\n"
" const uint32_t LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;\n"
"-const uint32_t LEAF_NODE_HEADER_SIZE =\n"
"-    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;\n"
"+const uint32_t LEAF_NODE_NEXT_LEAF_SIZE = sizeof(uint32_t);\n"
"+const uint32_t LEAF_NODE_NEXT_LEAF_OFFSET =\n"
"+    LEAF_NODE_NUM_CELLS_OFFSET + LEAF_NODE_NUM_CELLS_SIZE;\n"
"+const uint32_t LEAF_NODE_HEADER_SIZE = COMMON_NODE_HEADER_SIZE +\n"
"+                                       LEAF_NODE_NUM_CELLS_SIZE +\n"
"+                                       LEAF_NODE_NEXT_LEAF_SIZE;"
msgstr ""

msgid " ```"
msgstr ""

msgid ""
"Add a method to access the new field:\n"
"```diff\n"
"+uint32_t* leaf_node_next_leaf(void* node) {\n"
"+  return node + LEAF_NODE_NEXT_LEAF_OFFSET;\n"
"+}\n"
"```"
msgstr ""

msgid "Set `next_leaf` to 0 by default when initializing a new leaf node:"
msgstr ""

msgid ""
"```diff\n"
"@@ -322,6 +330,7 @@ void initialize_leaf_node(void* node) {\n"
"   set_node_type(node, NODE_LEAF);\n"
"   set_node_root(node, false);\n"
"   *leaf_node_num_cells(node) = 0;\n"
"+  *leaf_node_next_leaf(node) = 0;  // 0 represents no sibling\n"
" }\n"
"```"
msgstr ""

msgid ""
"Whenever we split a leaf node, update the sibling pointers. The old leaf's sib"
"ling becomes the new leaf, and the new leaf's sibling becomes whatever used to"
" be the old leaf's sibling."
msgstr ""

msgid ""
"```diff\n"
"@@ -659,6 +671,8 @@ void leaf_node_split_and_insert(Cursor* cursor, uint32_t k"
"ey, Row* value) {\n"
"   uint32_t new_page_num = get_unused_page_num(cursor->table->pager);\n"
"   void* new_node = get_page(cursor->table->pager, new_page_num);\n"
"   initialize_leaf_node(new_node);\n"
"+  *leaf_node_next_leaf(new_node) = *leaf_node_next_leaf(old_node);\n"
"+  *leaf_node_next_leaf(old_node) = new_page_num;\n"
"```"
msgstr ""

msgid ""
"Adding a new field changes a few constants:\n"
"```diff\n"
"   it 'prints constants' do\n"
"     script = [\n"
"       \".constants\",\n"
"@@ -199,9 +228,9 @@ describe 'database' do\n"
"       \"db > Constants:\",\n"
"       \"ROW_SIZE: 293\",\n"
"       \"COMMON_NODE_HEADER_SIZE: 6\",\n"
"-      \"LEAF_NODE_HEADER_SIZE: 10\",\n"
"+      \"LEAF_NODE_HEADER_SIZE: 14\",\n"
"       \"LEAF_NODE_CELL_SIZE: 297\",\n"
"-      \"LEAF_NODE_SPACE_FOR_CELLS: 4086\",\n"
"+      \"LEAF_NODE_SPACE_FOR_CELLS: 4082\",\n"
"       \"LEAF_NODE_MAX_CELLS: 13\",\n"
"       \"db > \",\n"
"     ])\n"
"```"
msgstr ""

msgid ""
"Now whenever we want to advance the cursor past the end of a leaf node, we can"
" check if the leaf node has a sibling. If it does, jump to it. Otherwise, we'r"
"e at the end of the table."
msgstr ""

msgid ""
"```diff\n"
"@@ -428,7 +432,15 @@ void cursor_advance(Cursor* cursor) {"
msgstr ""

msgid ""
"   cursor->cell_num += 1;\n"
"   if (cursor->cell_num >= (*leaf_node_num_cells(node))) {\n"
"-    cursor->end_of_table = true;\n"
"+    /* Advance to next leaf node */\n"
"+    uint32_t next_page_num = *leaf_node_next_leaf(node);\n"
"+    if (next_page_num == 0) {\n"
"+      /* This was rightmost leaf */\n"
"+      cursor->end_of_table = true;\n"
"+    } else {\n"
"+      cursor->page_num = next_page_num;\n"
"+      cursor->cell_num = 0;\n"
"+    }\n"
"   }\n"
" }\n"
"```"
msgstr ""

msgid ""
"After those changes, we actually print 15 rows...\n"
"```\n"
"db > select\n"
"(1, user1, person1@example.com)\n"
"(2, user2, person2@example.com)\n"
"(3, user3, person3@example.com)\n"
"(4, user4, person4@example.com)\n"
"(5, user5, person5@example.com)\n"
"(6, user6, person6@example.com)\n"
"(7, user7, person7@example.com)\n"
"(8, user8, person8@example.com)\n"
"(9, user9, person9@example.com)\n"
"(10, user10, person10@example.com)\n"
"(11, user11, person11@example.com)\n"
"(12, user12, person12@example.com)\n"
"(13, user13, person13@example.com)\n"
"(1919251317, 14, on14@example.com)\n"
"(15, user15, person15@example.com)\n"
"Executed.\n"
"db >\n"
"```"
msgstr ""

msgid ""
"...but one of them looks corrupted\n"
"```\n"
"(1919251317, 14, on14@example.com)\n"
"```"
msgstr ""

msgid ""
"After some debugging, I found out it's because of a bug in how we split leaf n"
"odes:"
msgstr ""

msgid ""
"```diff\n"
"@@ -676,7 +690,9 @@ void leaf_node_split_and_insert(Cursor* cursor, uint32_t k"
"ey, Row* value) {\n"
"     void* destination = leaf_node_cell(destination_node, index_within_node);"
msgstr ""

msgid ""
"     if (i == cursor->cell_num) {\n"
"-      serialize_row(value, destination);\n"
"+      serialize_row(value,\n"
"+                    leaf_node_value(destination_node, index_within_node));\n"
"+      *leaf_node_key(destination_node, index_within_node) = key;\n"
"     } else if (i > cursor->cell_num) {\n"
"       memcpy(destination, leaf_node_cell(old_node, i - 1), LEAF_NODE_CELL_SIZ"
"E);\n"
"     } else {\n"
"```"
msgstr ""

msgid "Remember that each cell in a leaf node consists of first a key then a value:"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/leaf-node-format.png\" description=\"Or"
"iginal leaf node format\" %}"
msgstr ""

msgid ""
"We were writing the new row (value) into the start of the cell, where the key "
"should go. That means part of the username was going into the section for id ("
"hence the crazy large id)."
msgstr ""

msgid "After fixing that bug, we finally print out the entire table as expected:"
msgstr ""

msgid ""
"```\n"
"db > select\n"
"(1, user1, person1@example.com)\n"
"(2, user2, person2@example.com)\n"
"(3, user3, person3@example.com)\n"
"(4, user4, person4@example.com)\n"
"(5, user5, person5@example.com)\n"
"(6, user6, person6@example.com)\n"
"(7, user7, person7@example.com)\n"
"(8, user8, person8@example.com)\n"
"(9, user9, person9@example.com)\n"
"(10, user10, person10@example.com)\n"
"(11, user11, person11@example.com)\n"
"(12, user12, person12@example.com)\n"
"(13, user13, person13@example.com)\n"
"(14, user14, person14@example.com)\n"
"(15, user15, person15@example.com)\n"
"Executed.\n"
"db >\n"
"```"
msgstr ""

msgid "Whew! One bug after another, but we're making progress."
msgstr ""

msgid "Until next time."
msgstr ""
