# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-23 11:24+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../_parts/part8.md:1
msgid "---\n"
"title: Part 8 - B-Tree Leaf Node Format\n"
"date: 2017-09-25\n"
"---"
msgstr ""

#: ../../../_parts/part8.md:6
msgid "We're changing the format of our table from an unsorted array of rows to a B-Tree. This is a pretty big change that is going to take multiple articles to implement. By the end of this article, we'll define the layout of a leaf node and support inserting key/value pairs into a single-node tree. But first, let's recap the reasons for switching to a tree structure."
msgstr ""

#: ../../../_parts/part8.md:8
msgid "## Alternative Table Formats"
msgstr ""

#: ../../../_parts/part8.md:10
msgid "With the current format, each page stores only rows (no metadata) so it is pretty space efficient. Insertion is also fast because we just append to the end. However, finding a particular row can only be done by scanning the entire table. And if we want to delete a row, we have to fill in the hole by moving every row that comes after it."
msgstr ""

#: ../../../_parts/part8.md:12
msgid "If we stored the table as an array, but kept rows sorted by id, we could use binary search to find a particular id. However, insertion would be slow because we would have to move a lot of rows to make space."
msgstr ""

#: ../../../_parts/part8.md:14
msgid "Instead, we're going with a tree structure. Each node in the tree can contain a variable number of rows, so we have to store some information in each node to keep track of how many rows it contains. Plus there is the storage overhead of all the internal nodes which don't store any rows. In exchange for a larger database file, we get fast insertion, deletion and lookup."
msgstr ""

#: ../../../_parts/part8.md:16
msgid "|               | Unsorted Array of rows | Sorted Array of rows | Tree of nodes |\n"
"|---------------|------------------------|----------------------|---------------|\n"
"| Pages contain | only data              | only data            | metadata, primary keys, and data              |\n"
"| Rows per page | more                   | more                 | fewer         |\n"
"| Insertion     | O(1)                   | O(n)                 | O(log(n))     |\n"
"| Deletion      | O(n)                   | O(n)                 | O(log(n))     |\n"
"| Lookup by id  | O(n)                   | O(log(n))            | O(log(n))     |"
msgstr ""

#: ../../../_parts/part8.md:24
msgid "## Node Header Format"
msgstr ""

#: ../../../_parts/part8.md:26
msgid "Leaf nodes and internal nodes have different layouts. Let's make an enum to keep track of node type:"
msgstr ""

#: ../../../_parts/part8.md:28
msgid "```diff\n"
"+typedef enum { NODE_INTERNAL, NODE_LEAF } NodeType;\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:32
msgid "Each node will correspond to one page. Internal nodes will point to their children by storing the page number that stores the child. The btree asks the pager for a particular page number and gets back a pointer into the page cache. Pages are stored in the database file one after the other in order of page number."
msgstr ""

#: ../../../_parts/part8.md:34
msgid "Nodes need to store some metadata in a header at the beginning of the page. Every node will store what type of node it is, whether or not it is the root node, and a pointer to its parent (to allow finding a node's siblings). I define constants for the size and offset of every header field:"
msgstr ""

#: ../../../_parts/part8.md:36
msgid "```diff\n"
"+/*\n"
"+ * Common Node Header Layout\n"
"+ */\n"
"+const uint32_t NODE_TYPE_SIZE = sizeof(uint8_t);\n"
"+const uint32_t NODE_TYPE_OFFSET = 0;\n"
"+const uint32_t IS_ROOT_SIZE = sizeof(uint8_t);\n"
"+const uint32_t IS_ROOT_OFFSET = NODE_TYPE_SIZE;\n"
"+const uint32_t PARENT_POINTER_SIZE = sizeof(uint32_t);\n"
"+const uint32_t PARENT_POINTER_OFFSET = IS_ROOT_OFFSET + IS_ROOT_SIZE;\n"
"+const uint8_t COMMON_NODE_HEADER_SIZE =\n"
"+    NODE_TYPE_SIZE + IS_ROOT_SIZE + PARENT_POINTER_SIZE;\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:50
msgid "## Leaf Node Format"
msgstr ""

#: ../../../_parts/part8.md:52
msgid "In addition to these common header fields, leaf nodes need to store how many \"cells\" they contain. A cell is a key/value pair."
msgstr ""

#: ../../../_parts/part8.md:54
msgid "```diff\n"
"+/*\n"
"+ * Leaf Node Header Layout\n"
"+ */\n"
"+const uint32_t LEAF_NODE_NUM_CELLS_SIZE = sizeof(uint32_t);\n"
"+const uint32_t LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;\n"
"+const uint32_t LEAF_NODE_HEADER_SIZE =\n"
"+    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:64
msgid "The body of a leaf node is an array of cells. Each cell is a key followed by a value (a serialized row)."
msgstr ""

#: ../../../_parts/part8.md:66
msgid "```diff\n"
"+/*\n"
"+ * Leaf Node Body Layout\n"
"+ */\n"
"+const uint32_t LEAF_NODE_KEY_SIZE = sizeof(uint32_t);\n"
"+const uint32_t LEAF_NODE_KEY_OFFSET = 0;\n"
"+const uint32_t LEAF_NODE_VALUE_SIZE = ROW_SIZE;\n"
"+const uint32_t LEAF_NODE_VALUE_OFFSET =\n"
"+    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;\n"
"+const uint32_t LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZE;\n"
"+const uint32_t LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;\n"
"+const uint32_t LEAF_NODE_MAX_CELLS =\n"
"+    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:81
msgid "Based on these constants, here's what the layout of a leaf node looks like currently:"
msgstr ""

#: ../../../_parts/part8.md:83
msgid "{% include image.html url=\"assets/images/leaf-node-format.png\" description=\"Our leaf node format\" %}"
msgstr ""

#: ../../../_parts/part8.md:85
msgid "It's a little space inefficient to use an entire byte per boolean value in the header, but this makes it easier to write code to access those values."
msgstr ""

#: ../../../_parts/part8.md:87
msgid "Also notice that there's some wasted space at the end. We store as many cells as we can after the header, but the leftover space can't hold an entire cell. We leave it empty to avoid splitting cells between nodes."
msgstr ""

#: ../../../_parts/part8.md:89
msgid "## Accessing Leaf Node Fields"
msgstr ""

#: ../../../_parts/part8.md:91
msgid "The code to access keys, values and metadata all involve pointer arithmetic using the constants we just defined."
msgstr ""

#: ../../../_parts/part8.md:93
msgid "```diff\n"
"+uint32_t* leaf_node_num_cells(void* node) {\n"
"+  return node + LEAF_NODE_NUM_CELLS_OFFSET;\n"
"+}\n"
"+\n"
"+void* leaf_node_cell(void* node, uint32_t cell_num) {\n"
"+  return node + LEAF_NODE_HEADER_SIZE + cell_num * LEAF_NODE_CELL_SIZE;\n"
"+}\n"
"+\n"
"+uint32_t* leaf_node_key(void* node, uint32_t cell_num) {\n"
"+  return leaf_node_cell(node, cell_num);\n"
"+}\n"
"+\n"
"+void* leaf_node_value(void* node, uint32_t cell_num) {\n"
"+  return leaf_node_cell(node, cell_num) + LEAF_NODE_KEY_SIZE;\n"
"+}\n"
"+\n"
"+void initialize_leaf_node(void* node) { *leaf_node_num_cells(node) = 0; }\n"
"+\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:114
msgid "These methods return a pointer to the value in question, so they can be used both as a getter and a setter."
msgstr ""

#: ../../../_parts/part8.md:116
msgid "## Changes to Pager and Table Objects"
msgstr ""

#: ../../../_parts/part8.md:118
msgid "Every node is going to take up exactly one page, even if it's not full. That means our pager no longer needs to support reading/writing partial pages.\n"
"```diff\n"
"-void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {\n"
"+void pager_flush(Pager* pager, uint32_t page_num) {\n"
"   if (pager->pages[page_num] == NULL) {\n"
"     printf(\"Tried to flush null page\\n\");\n"
"     exit(EXIT_FAILURE);\n"
"@@ -242,7 +337,7 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {\n"
"   }"
msgstr ""

#: ../../../_parts/part8.md:128
#: ../../../_parts/part8.md:720
msgid "   ssize_t bytes_written =\n"
"-      write(pager->file_descriptor, pager->pages[page_num], size);\n"
"+      write(pager->file_descriptor, pager->pages[page_num], PAGE_SIZE);"
msgstr ""

#: ../../../_parts/part8.md:132
msgid "   if (bytes_written == -1) {\n"
"     printf(\"Error writing: %d\\n\", errno);\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:136
msgid "```diff\n"
" void db_close(Table* table) {\n"
"   Pager* pager = table->pager;\n"
"-  uint32_t num_full_pages = table->num_rows / ROWS_PER_PAGE;"
msgstr ""

#: ../../../_parts/part8.md:141
#: ../../../_parts/part8.md:733
msgid "-  for (uint32_t i = 0; i < num_full_pages; i++) {\n"
"+  for (uint32_t i = 0; i < pager->num_pages; i++) {\n"
"     if (pager->pages[i] == NULL) {\n"
"       continue;\n"
"     }\n"
"-    pager_flush(pager, i, PAGE_SIZE);\n"
"+    pager_flush(pager, i);\n"
"     free(pager->pages[i]);\n"
"     pager->pages[i] = NULL;\n"
"   }"
msgstr ""

#: ../../../_parts/part8.md:152
msgid "-  // There may be a partial page to write to the end of the file\n"
"-  // This should not be needed after we switch to a B-tree\n"
"-  uint32_t num_additional_rows = table->num_rows % ROWS_PER_PAGE;\n"
"-  if (num_additional_rows > 0) {\n"
"-    uint32_t page_num = num_full_pages;\n"
"-    if (pager->pages[page_num] != NULL) {\n"
"-      pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);\n"
"-      free(pager->pages[page_num]);\n"
"-      pager->pages[page_num] = NULL;\n"
"-    }\n"
"-  }\n"
"-\n"
"   int result = close(pager->file_descriptor);\n"
"   if (result == -1) {\n"
"     printf(\"Error closing db file.\\n\");\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:169
msgid "Now it makes more sense to store the number of pages in our database rather than the number of rows. The number of pages should be associated with the pager object, not the table, since it's the number of pages used by the database, not a particular table. A btree is identified by its root node page number, so the table object needs to keep track of that."
msgstr ""

#: ../../../_parts/part8.md:171
msgid "```diff\n"
" const uint32_t PAGE_SIZE = 4096;\n"
" const uint32_t TABLE_MAX_PAGES = 100;\n"
"-const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;\n"
"-const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;"
msgstr ""

#: ../../../_parts/part8.md:177
#: ../../../_parts/part8.md:509
msgid " typedef struct {\n"
"   int file_descriptor;\n"
"   uint32_t file_length;\n"
"+  uint32_t num_pages;\n"
"   void* pages[TABLE_MAX_PAGES];\n"
" } Pager;"
msgstr ""

#: ../../../_parts/part8.md:184
msgid " typedef struct {\n"
"   Pager* pager;\n"
"-  uint32_t num_rows;\n"
"+  uint32_t root_page_num;\n"
" } Table;\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:191
msgid "```diff\n"
"@@ -127,6 +200,10 @@ void* get_page(Pager* pager, uint32_t page_num) {\n"
"     }"
msgstr ""

#: ../../../_parts/part8.md:195
#: ../../../_parts/part8.md:614
msgid "     pager->pages[page_num] = page;\n"
"+\n"
"+    if (page_num >= pager->num_pages) {\n"
"+      pager->num_pages = page_num + 1;\n"
"+    }\n"
"   }"
msgstr ""

#: ../../../_parts/part8.md:202
msgid "   return pager->pages[page_num];\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:205
msgid "```diff\n"
"@@ -184,6 +269,12 @@ Pager* pager_open(const char* filename) {\n"
"   Pager* pager = malloc(sizeof(Pager));\n"
"   pager->file_descriptor = fd;\n"
"   pager->file_length = file_length;\n"
"+  pager->num_pages = (file_length / PAGE_SIZE);\n"
"+\n"
"+  if (file_length % PAGE_SIZE != 0) {\n"
"+    printf(\"Db file is not a whole number of pages. Corrupt file.\\n\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }"
msgstr ""

#: ../../../_parts/part8.md:217
msgid "   for (uint32_t i = 0; i < TABLE_MAX_PAGES; i++) {\n"
"     pager->pages[i] = NULL;\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:221
msgid "## Changes to the Cursor Object"
msgstr ""

#: ../../../_parts/part8.md:223
msgid "A cursor represents a position in the table. When our table was a simple array of rows, we could access a row given just the row number. Now that it's a tree, we identify a position by the page number of the node, and the cell number within that node."
msgstr ""

#: ../../../_parts/part8.md:225
msgid "```diff\n"
" typedef struct {\n"
"   Table* table;\n"
"-  uint32_t row_num;\n"
"+  uint32_t page_num;\n"
"+  uint32_t cell_num;\n"
"   bool end_of_table;  // Indicates a position one past the last element\n"
" } Cursor;\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:235
msgid "```diff\n"
" Cursor* table_start(Table* table) {\n"
"   Cursor* cursor = malloc(sizeof(Cursor));\n"
"   cursor->table = table;\n"
"-  cursor->row_num = 0;\n"
"-  cursor->end_of_table = (table->num_rows == 0);\n"
"+  cursor->page_num = table->root_page_num;\n"
"+  cursor->cell_num = 0;\n"
"+\n"
"+  void* root_node = get_page(table->pager, table->root_page_num);\n"
"+  uint32_t num_cells = *leaf_node_num_cells(root_node);\n"
"+  cursor->end_of_table = (num_cells == 0);"
msgstr ""

#: ../../../_parts/part8.md:248
#: ../../../_parts/part8.md:264
msgid "   return cursor;\n"
" }\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:252
msgid "```diff\n"
" Cursor* table_end(Table* table) {\n"
"   Cursor* cursor = malloc(sizeof(Cursor));\n"
"   cursor->table = table;\n"
"-  cursor->row_num = table->num_rows;\n"
"+  cursor->page_num = table->root_page_num;\n"
"+\n"
"+  void* root_node = get_page(table->pager, table->root_page_num);\n"
"+  uint32_t num_cells = *leaf_node_num_cells(root_node);\n"
"+  cursor->cell_num = num_cells;\n"
"   cursor->end_of_table = true;"
msgstr ""

#: ../../../_parts/part8.md:268
msgid "```diff\n"
" void* cursor_value(Cursor* cursor) {\n"
"-  uint32_t row_num = cursor->row_num;\n"
"-  uint32_t page_num = row_num / ROWS_PER_PAGE;\n"
"+  uint32_t page_num = cursor->page_num;\n"
"   void* page = get_page(cursor->table->pager, page_num);\n"
"-  uint32_t row_offset = row_num % ROWS_PER_PAGE;\n"
"-  uint32_t byte_offset = row_offset * ROW_SIZE;\n"
"-  return page + byte_offset;\n"
"+  return leaf_node_value(page, cursor->cell_num);\n"
" }\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:281
msgid "```diff\n"
" void cursor_advance(Cursor* cursor) {\n"
"-  cursor->row_num += 1;\n"
"-  if (cursor->row_num >= cursor->table->num_rows) {\n"
"+  uint32_t page_num = cursor->page_num;\n"
"+  void* node = get_page(cursor->table->pager, page_num);\n"
"+\n"
"+  cursor->cell_num += 1;\n"
"+  if (cursor->cell_num >= (*leaf_node_num_cells(node))) {\n"
"     cursor->end_of_table = true;\n"
"   }\n"
" }\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:295
msgid "## Insertion Into a Leaf Node"
msgstr ""

#: ../../../_parts/part8.md:297
msgid "In this article we're only going to implement enough to get a single-node tree. Recall from last article that a tree starts out as an empty leaf node:"
msgstr ""

#: ../../../_parts/part8.md:299
msgid "{% include image.html url=\"assets/images/btree1.png\" description=\"empty btree\" %}"
msgstr ""

#: ../../../_parts/part8.md:301
msgid "Key/value pairs can be added until the leaf node is full:"
msgstr ""

#: ../../../_parts/part8.md:303
msgid "{% include image.html url=\"assets/images/btree2.png\" description=\"one-node btree\" %}"
msgstr ""

#: ../../../_parts/part8.md:305
msgid "When we open the database for the first time, the database file will be empty, so we initialize page 0 to be an empty leaf node (the root node):"
msgstr ""

#: ../../../_parts/part8.md:307
msgid "```diff\n"
" Table* db_open(const char* filename) {\n"
"   Pager* pager = pager_open(filename);\n"
"-  uint32_t num_rows = pager->file_length / ROW_SIZE;"
msgstr ""

#: ../../../_parts/part8.md:312
#: ../../../_parts/part8.md:694
msgid "   Table* table = malloc(sizeof(Table));\n"
"   table->pager = pager;\n"
"-  table->num_rows = num_rows;\n"
"+  table->root_page_num = 0;\n"
"+\n"
"+  if (pager->num_pages == 0) {\n"
"+    // New database file. Initialize page 0 as leaf node.\n"
"+    void* root_node = get_page(pager, 0);\n"
"+    initialize_leaf_node(root_node);\n"
"+  }"
msgstr ""

#: ../../../_parts/part8.md:323
msgid "   return table;\n"
" }\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:327
msgid "Next we'll make a function for inserting a key/value pair into a leaf node. It will take a cursor as input to represent the position where the pair should be inserted."
msgstr ""

#: ../../../_parts/part8.md:329
msgid "```diff\n"
"+void leaf_node_insert(Cursor* cursor, uint32_t key, Row* value) {\n"
"+  void* node = get_page(cursor->table->pager, cursor->page_num);\n"
"+\n"
"+  uint32_t num_cells = *leaf_node_num_cells(node);\n"
"+  if (num_cells >= LEAF_NODE_MAX_CELLS) {\n"
"+    // Node full\n"
"+    printf(\"Need to implement splitting a leaf node.\\n\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  if (cursor->cell_num < num_cells) {\n"
"+    // Make room for new cell\n"
"+    for (uint32_t i = num_cells; i > cursor->cell_num; i--) {\n"
"+      memcpy(leaf_node_cell(node, i), leaf_node_cell(node, i - 1),\n"
"+             LEAF_NODE_CELL_SIZE);\n"
"+    }\n"
"+  }\n"
"+\n"
"+  *(leaf_node_num_cells(node)) += 1;\n"
"+  *(leaf_node_key(node, cursor->cell_num)) = key;\n"
"+  serialize_row(value, leaf_node_value(node, cursor->cell_num));\n"
"+}\n"
"+\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:355
msgid "We haven't implemented splitting yet, so we error if the node is full. Next we shift cells one space to the right to make room for the new cell. Then we write the new key/value into the empty space."
msgstr ""

#: ../../../_parts/part8.md:357
msgid "Since we assume the tree only has one node, our `execute_insert()` function simply needs to call this helper method:"
msgstr ""

#: ../../../_parts/part8.md:359
msgid "```diff\n"
" ExecuteResult execute_insert(Statement* statement, Table* table) {\n"
"-  if (table->num_rows >= TABLE_MAX_ROWS) {\n"
"+  void* node = get_page(table->pager, table->root_page_num);\n"
"+  if ((*leaf_node_num_cells(node) >= LEAF_NODE_MAX_CELLS)) {\n"
"     return EXECUTE_TABLE_FULL;\n"
"   }"
msgstr ""

#: ../../../_parts/part8.md:367
#: ../../../_parts/part8.md:808
msgid "   Row* row_to_insert = &(statement->row_to_insert);\n"
"   Cursor* cursor = table_end(table);"
msgstr ""

#: ../../../_parts/part8.md:370
#: ../../../_parts/part8.md:811
msgid "-  serialize_row(row_to_insert, cursor_value(cursor));\n"
"-  table->num_rows += 1;\n"
"+  leaf_node_insert(cursor, row_to_insert->id, row_to_insert);"
msgstr ""

#: ../../../_parts/part8.md:374
#: ../../../_parts/part8.md:815
msgid "   free(cursor);\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:377
msgid "With those changes, our database should work as before! Except now it returns a \"Table Full\" error much sooner, since we can't split the root node yet."
msgstr ""

#: ../../../_parts/part8.md:379
msgid "How many rows can the leaf node hold?"
msgstr ""

#: ../../../_parts/part8.md:381
msgid "## Command to Print Constants"
msgstr ""

#: ../../../_parts/part8.md:383
msgid "I'm adding a new meta command to print out a few constants of interest."
msgstr ""

#: ../../../_parts/part8.md:385
msgid "```diff\n"
"+void print_constants() {\n"
"+  printf(\"ROW_SIZE: %d\\n\", ROW_SIZE);\n"
"+  printf(\"COMMON_NODE_HEADER_SIZE: %d\\n\", COMMON_NODE_HEADER_SIZE);\n"
"+  printf(\"LEAF_NODE_HEADER_SIZE: %d\\n\", LEAF_NODE_HEADER_SIZE);\n"
"+  printf(\"LEAF_NODE_CELL_SIZE: %d\\n\", LEAF_NODE_CELL_SIZE);\n"
"+  printf(\"LEAF_NODE_SPACE_FOR_CELLS: %d\\n\", LEAF_NODE_SPACE_FOR_CELLS);\n"
"+  printf(\"LEAF_NODE_MAX_CELLS: %d\\n\", LEAF_NODE_MAX_CELLS);\n"
"+}\n"
"+\n"
"@@ -294,6 +376,14 @@ MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table* table) {\n"
"   if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"     db_close(table);\n"
"     exit(EXIT_SUCCESS);\n"
"+  } else if (strcmp(input_buffer->buffer, \".constants\") == 0) {\n"
"+    printf(\"Constants:\\n\");\n"
"+    print_constants();\n"
"+    return META_COMMAND_SUCCESS;\n"
"   } else {\n"
"     return META_COMMAND_UNRECOGNIZED_COMMAND;\n"
"   }\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:408
msgid "I'm also adding a test so we get alerted when those constants change:\n"
"```diff\n"
"+  it 'prints constants' do\n"
"+    script = [\n"
"+      \".constants\",\n"
"+      \".exit\",\n"
"+    ]\n"
"+    result = run_script(script)\n"
"+\n"
"+    expect(result).to match_array([\n"
"+      \"db > Constants:\",\n"
"+      \"ROW_SIZE: 293\",\n"
"+      \"COMMON_NODE_HEADER_SIZE: 6\",\n"
"+      \"LEAF_NODE_HEADER_SIZE: 10\",\n"
"+      \"LEAF_NODE_CELL_SIZE: 297\",\n"
"+      \"LEAF_NODE_SPACE_FOR_CELLS: 4086\",\n"
"+      \"LEAF_NODE_MAX_CELLS: 13\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:430
msgid "So our table can hold 13 rows right now!"
msgstr ""

#: ../../../_parts/part8.md:432
msgid "## Tree Visualization"
msgstr ""

#: ../../../_parts/part8.md:434
msgid "To help with debugging and visualization, I'm also adding a meta command to print out a representation of the btree."
msgstr ""

#: ../../../_parts/part8.md:436
msgid "```diff\n"
"+void print_leaf_node(void* node) {\n"
"+  uint32_t num_cells = *leaf_node_num_cells(node);\n"
"+  printf(\"leaf (size %d)\\n\", num_cells);\n"
"+  for (uint32_t i = 0; i < num_cells; i++) {\n"
"+    uint32_t key = *leaf_node_key(node, i);\n"
"+    printf(\"  - %d : %d\\n\", i, key);\n"
"+  }\n"
"+}\n"
"+\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:448
msgid "```diff\n"
"@@ -294,6 +376,14 @@ MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table* table) {\n"
"   if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"     db_close(table);\n"
"     exit(EXIT_SUCCESS);\n"
"+  } else if (strcmp(input_buffer->buffer, \".btree\") == 0) {\n"
"+    printf(\"Tree:\\n\");\n"
"+    print_leaf_node(get_page(table->pager, 0));\n"
"+    return META_COMMAND_SUCCESS;\n"
"   } else if (strcmp(input_buffer->buffer, \".constants\") == 0) {\n"
"     printf(\"Constants:\\n\");\n"
"     print_constants();\n"
"     return META_COMMAND_SUCCESS;\n"
"   } else {\n"
"     return META_COMMAND_UNRECOGNIZED_COMMAND;\n"
"   }\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:466
msgid "And a test"
msgstr ""

#: ../../../_parts/part8.md:468
msgid "```diff\n"
"+  it 'allows printing out the structure of a one-node btree' do\n"
"+    script = [3, 1, 2].map do |i|\n"
"+      \"insert #{i} user#{i} person#{i}@example.com\"\n"
"+    end\n"
"+    script << \".btree\"\n"
"+    script << \".exit\"\n"
"+    result = run_script(script)\n"
"+\n"
"+    expect(result).to match_array([\n"
"+      \"db > Executed.\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > Tree:\",\n"
"+      \"leaf (size 3)\",\n"
"+      \"  - 0 : 3\",\n"
"+      \"  - 1 : 1\",\n"
"+      \"  - 2 : 2\",\n"
"+      \"db > \"\n"
"+    ])\n"
"+  end\n"
"```"
msgstr ""

#: ../../../_parts/part8.md:491
msgid "Uh oh, we're still not storing rows in sorted order. You'll notice that `execute_insert()` inserts into the leaf node at the position returned by `table_end()`. So rows are stored in the order they were inserted, just like before."
msgstr ""

#: ../../../_parts/part8.md:493
msgid "## Next Time"
msgstr ""

#: ../../../_parts/part8.md:495
msgid "This all might seem like a step backwards. Our database now stores fewer rows than it did before, and we're still storing rows in unsorted order. But like I said at the beginning, this is a big change and it's important to break it up into manageable steps."
msgstr ""

#: ../../../_parts/part8.md:497
msgid "Next time, we'll implement finding a record by primary key, and start storing rows in sorted order."
msgstr ""

#: ../../../_parts/part8.md:499
msgid "## Complete Diff"
msgstr ""

#: ../../../_parts/part8.md:501
msgid "```diff\n"
"@@ -62,29 +62,101 @@ const uint32_t ROW_SIZE = ID_SIZE + USERNAME_SIZE + EMAIL_SIZE;"
msgstr ""

#: ../../../_parts/part8.md:504
msgid " const uint32_t PAGE_SIZE = 4096;\n"
" #define TABLE_MAX_PAGES 100\n"
"-const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;\n"
"-const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;"
msgstr ""

#: ../../../_parts/part8.md:516
msgid " typedef struct {\n"
"   Pager* pager;\n"
"-  uint32_t num_rows;\n"
"+  uint32_t root_page_num;\n"
" } Table;"
msgstr ""

#: ../../../_parts/part8.md:522
msgid " typedef struct {\n"
"   Table* table;\n"
"-  uint32_t row_num;\n"
"+  uint32_t page_num;\n"
"+  uint32_t cell_num;\n"
"   bool end_of_table;  // Indicates a position one past the last element\n"
" } Cursor;"
msgstr ""

#: ../../../_parts/part8.md:530
msgid "+typedef enum { NODE_INTERNAL, NODE_LEAF } NodeType;\n"
"+\n"
"+/*\n"
"+ * Common Node Header Layout\n"
"+ */\n"
"+const uint32_t NODE_TYPE_SIZE = sizeof(uint8_t);\n"
"+const uint32_t NODE_TYPE_OFFSET = 0;\n"
"+const uint32_t IS_ROOT_SIZE = sizeof(uint8_t);\n"
"+const uint32_t IS_ROOT_OFFSET = NODE_TYPE_SIZE;\n"
"+const uint32_t PARENT_POINTER_SIZE = sizeof(uint32_t);\n"
"+const uint32_t PARENT_POINTER_OFFSET = IS_ROOT_OFFSET + IS_ROOT_SIZE;\n"
"+const uint8_t COMMON_NODE_HEADER_SIZE =\n"
"+    NODE_TYPE_SIZE + IS_ROOT_SIZE + PARENT_POINTER_SIZE;\n"
"+\n"
"+/*\n"
"+ * Leaf Node Header Layout\n"
"+ */\n"
"+const uint32_t LEAF_NODE_NUM_CELLS_SIZE = sizeof(uint32_t);\n"
"+const uint32_t LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;\n"
"+const uint32_t LEAF_NODE_HEADER_SIZE =\n"
"+    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;\n"
"+\n"
"+/*\n"
"+ * Leaf Node Body Layout\n"
"+ */\n"
"+const uint32_t LEAF_NODE_KEY_SIZE = sizeof(uint32_t);\n"
"+const uint32_t LEAF_NODE_KEY_OFFSET = 0;\n"
"+const uint32_t LEAF_NODE_VALUE_SIZE = ROW_SIZE;\n"
"+const uint32_t LEAF_NODE_VALUE_OFFSET =\n"
"+    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;\n"
"+const uint32_t LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZE;\n"
"+const uint32_t LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;\n"
"+const uint32_t LEAF_NODE_MAX_CELLS =\n"
"+    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;\n"
"+\n"
"+uint32_t* leaf_node_num_cells(void* node) {\n"
"+  return node + LEAF_NODE_NUM_CELLS_OFFSET;\n"
"+}\n"
"+\n"
"+void* leaf_node_cell(void* node, uint32_t cell_num) {\n"
"+  return node + LEAF_NODE_HEADER_SIZE + cell_num * LEAF_NODE_CELL_SIZE;\n"
"+}\n"
"+\n"
"+uint32_t* leaf_node_key(void* node, uint32_t cell_num) {\n"
"+  return leaf_node_cell(node, cell_num);\n"
"+}\n"
"+\n"
"+void* leaf_node_value(void* node, uint32_t cell_num) {\n"
"+  return leaf_node_cell(node, cell_num) + LEAF_NODE_KEY_SIZE;\n"
"+}\n"
"+\n"
"+void print_constants() {\n"
"+  printf(\"ROW_SIZE: %d\\n\", ROW_SIZE);\n"
"+  printf(\"COMMON_NODE_HEADER_SIZE: %d\\n\", COMMON_NODE_HEADER_SIZE);\n"
"+  printf(\"LEAF_NODE_HEADER_SIZE: %d\\n\", LEAF_NODE_HEADER_SIZE);\n"
"+  printf(\"LEAF_NODE_CELL_SIZE: %d\\n\", LEAF_NODE_CELL_SIZE);\n"
"+  printf(\"LEAF_NODE_SPACE_FOR_CELLS: %d\\n\", LEAF_NODE_SPACE_FOR_CELLS);\n"
"+  printf(\"LEAF_NODE_MAX_CELLS: %d\\n\", LEAF_NODE_MAX_CELLS);\n"
"+}\n"
"+\n"
"+void print_leaf_node(void* node) {\n"
"+  uint32_t num_cells = *leaf_node_num_cells(node);\n"
"+  printf(\"leaf (size %d)\\n\", num_cells);\n"
"+  for (uint32_t i = 0; i < num_cells; i++) {\n"
"+    uint32_t key = *leaf_node_key(node, i);\n"
"+    printf(\"  - %d : %d\\n\", i, key);\n"
"+  }\n"
"+}\n"
"+\n"
" void print_row(Row* row) {\n"
"     printf(\"(%d, %s, %s)\\n\", row->id, row->username, row->email);\n"
" }\n"
"@@ -101,6 +173,8 @@ void deserialize_row(void *source, Row* destination) {\n"
"     memcpy(&(destination->email), source + EMAIL_OFFSET, EMAIL_SIZE);\n"
" }"
msgstr ""

#: ../../../_parts/part8.md:606
msgid "+void initialize_leaf_node(void* node) { *leaf_node_num_cells(node) = 0; }\n"
"+\n"
" void* get_page(Pager* pager, uint32_t page_num) {\n"
"   if (page_num > TABLE_MAX_PAGES) {\n"
"     printf(\"Tried to fetch page number out of bounds. %d > %d\\n\", page_num,\n"
"@@ -128,6 +202,10 @@ void* get_page(Pager* pager, uint32_t page_num) {\n"
"     }"
msgstr ""

#: ../../../_parts/part8.md:621
msgid "   return pager->pages[page_num];\n"
"@@ -136,8 +214,12 @@ void* get_page(Pager* pager, uint32_t page_num) {\n"
" Cursor* table_start(Table* table) {\n"
"   Cursor* cursor = malloc(sizeof(Cursor));\n"
"   cursor->table = table;\n"
"-  cursor->row_num = 0;\n"
"-  cursor->end_of_table = (table->num_rows == 0);\n"
"+  cursor->page_num = table->root_page_num;\n"
"+  cursor->cell_num = 0;\n"
"+\n"
"+  void* root_node = get_page(table->pager, table->root_page_num);\n"
"+  uint32_t num_cells = *leaf_node_num_cells(root_node);\n"
"+  cursor->end_of_table = (num_cells == 0);"
msgstr ""

#: ../../../_parts/part8.md:635
msgid "   return cursor;\n"
" }\n"
"@@ -145,24 +227,28 @@ Cursor* table_start(Table* table) {\n"
" Cursor* table_end(Table* table) {\n"
"   Cursor* cursor = malloc(sizeof(Cursor));\n"
"   cursor->table = table;\n"
"-  cursor->row_num = table->num_rows;\n"
"+  cursor->page_num = table->root_page_num;\n"
"+\n"
"+  void* root_node = get_page(table->pager, table->root_page_num);\n"
"+  uint32_t num_cells = *leaf_node_num_cells(root_node);\n"
"+  cursor->cell_num = num_cells;\n"
"   cursor->end_of_table = true;"
msgstr ""

#: ../../../_parts/part8.md:649
msgid "   return cursor;\n"
" }"
msgstr ""

#: ../../../_parts/part8.md:652
msgid " void* cursor_value(Cursor* cursor) {\n"
"-  uint32_t row_num = cursor->row_num;\n"
"-  uint32_t page_num = row_num / ROWS_PER_PAGE;\n"
"+  uint32_t page_num = cursor->page_num;\n"
"   void* page = get_page(cursor->table->pager, page_num);\n"
"-  uint32_t row_offset = row_num % ROWS_PER_PAGE;\n"
"-  uint32_t byte_offset = row_offset * ROW_SIZE;\n"
"-  return page + byte_offset;\n"
"+  return leaf_node_value(page, cursor->cell_num);\n"
" }"
msgstr ""

#: ../../../_parts/part8.md:663
msgid " void cursor_advance(Cursor* cursor) {\n"
"-  cursor->row_num += 1;\n"
"-  if (cursor->row_num >= cursor->table->num_rows) {\n"
"+  uint32_t page_num = cursor->page_num;\n"
"+  void* node = get_page(cursor->table->pager, page_num);\n"
"+\n"
"+  cursor->cell_num += 1;\n"
"+  if (cursor->cell_num >= (*leaf_node_num_cells(node))) {\n"
"     cursor->end_of_table = true;\n"
"   }\n"
" }\n"
"@@ -185,6 +271,12 @@ Pager* pager_open(const char* filename) {\n"
"   Pager* pager = malloc(sizeof(Pager));\n"
"   pager->file_descriptor = fd;\n"
"   pager->file_length = file_length;\n"
"+  pager->num_pages = (file_length / PAGE_SIZE);\n"
"+\n"
"+  if (file_length % PAGE_SIZE != 0) {\n"
"+    printf(\"Db file is not a whole number of pages. Corrupt file.\\n\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }"
msgstr ""

#: ../../../_parts/part8.md:685
msgid "   for (uint32_t i = 0; i < TABLE_MAX_PAGES; i++) {\n"
"     pager->pages[i] = NULL;\n"
"@@ -194,11 +285,15 @@ Pager* pager_open(const char* filename) {\n"
"@@ -195,11 +287,16 @@ Pager* pager_open(const char* filename) {"
msgstr ""

#: ../../../_parts/part8.md:690
msgid " Table* db_open(const char* filename) {\n"
"   Pager* pager = pager_open(filename);\n"
"-  uint32_t num_rows = pager->file_length / ROW_SIZE;"
msgstr ""

#: ../../../_parts/part8.md:705
msgid "   return table;\n"
" }\n"
"@@ -234,7 +331,7 @@ void close_input_buffer(InputBuffer* input_buffer) {\n"
"     free(input_buffer);\n"
" }"
msgstr ""

#: ../../../_parts/part8.md:711
msgid "-void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {\n"
"+void pager_flush(Pager* pager, uint32_t page_num) {\n"
"   if (pager->pages[page_num] == NULL) {\n"
"     printf(\"Tried to flush null page\\n\");\n"
"     exit(EXIT_FAILURE);\n"
"@@ -242,7 +337,7 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {\n"
"@@ -249,7 +346,7 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {\n"
"   }"
msgstr ""

#: ../../../_parts/part8.md:724
msgid "   if (bytes_written == -1) {\n"
"     printf(\"Error writing: %d\\n\", errno);\n"
"@@ -252,29 +347,16 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {\n"
"@@ -260,29 +357,16 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {"
msgstr ""

#: ../../../_parts/part8.md:729
msgid " void db_close(Table* table) {\n"
"   Pager* pager = table->pager;\n"
"-  uint32_t num_full_pages = table->num_rows / ROWS_PER_PAGE;"
msgstr ""

#: ../../../_parts/part8.md:744
msgid "-  // There may be a partial page to write to the end of the file\n"
"-  // This should not be needed after we switch to a B-tree\n"
"-  uint32_t num_additional_rows = table->num_rows % ROWS_PER_PAGE;\n"
"-  if (num_additional_rows > 0) {\n"
"-    uint32_t page_num = num_full_pages;\n"
"-    if (pager->pages[page_num] != NULL) {\n"
"-      pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);\n"
"-      free(pager->pages[page_num]);\n"
"-      pager->pages[page_num] = NULL;\n"
"-    }\n"
"-  }\n"
"-\n"
"   int result = close(pager->file_descriptor);\n"
"   if (result == -1) {\n"
"     printf(\"Error closing db file.\\n\");\n"
"@@ -305,6 +389,14 @@ MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table *table) {\n"
"   if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"     db_close(table);\n"
"     exit(EXIT_SUCCESS);\n"
"+  } else if (strcmp(input_buffer->buffer, \".btree\") == 0) {\n"
"+    printf(\"Tree:\\n\");\n"
"+    print_leaf_node(get_page(table->pager, 0));\n"
"+    return META_COMMAND_SUCCESS;\n"
"+  } else if (strcmp(input_buffer->buffer, \".constants\") == 0) {\n"
"+    printf(\"Constants:\\n\");\n"
"+    print_constants();\n"
"+    return META_COMMAND_SUCCESS;\n"
"   } else {\n"
"     return META_COMMAND_UNRECOGNIZED_COMMAND;\n"
"   }\n"
"@@ -354,16 +446,39 @@ PrepareResult prepare_statement(InputBuffer* input_buffer,\n"
"   return PREPARE_UNRECOGNIZED_STATEMENT;\n"
" }"
msgstr ""

#: ../../../_parts/part8.md:778
msgid "+void leaf_node_insert(Cursor* cursor, uint32_t key, Row* value) {\n"
"+  void* node = get_page(cursor->table->pager, cursor->page_num);\n"
"+\n"
"+  uint32_t num_cells = *leaf_node_num_cells(node);\n"
"+  if (num_cells >= LEAF_NODE_MAX_CELLS) {\n"
"+    // Node full\n"
"+    printf(\"Need to implement splitting a leaf node.\\n\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  if (cursor->cell_num < num_cells) {\n"
"+    // Make room for new cell\n"
"+    for (uint32_t i = num_cells; i > cursor->cell_num; i--) {\n"
"+      memcpy(leaf_node_cell(node, i), leaf_node_cell(node, i - 1),\n"
"+             LEAF_NODE_CELL_SIZE);\n"
"+    }\n"
"+  }\n"
"+\n"
"+  *(leaf_node_num_cells(node)) += 1;\n"
"+  *(leaf_node_key(node, cursor->cell_num)) = key;\n"
"+  serialize_row(value, leaf_node_value(node, cursor->cell_num));\n"
"+}\n"
"+\n"
" ExecuteResult execute_insert(Statement* statement, Table* table) {\n"
"-  if (table->num_rows >= TABLE_MAX_ROWS) {\n"
"+  void* node = get_page(table->pager, table->root_page_num);\n"
"+  if ((*leaf_node_num_cells(node) >= LEAF_NODE_MAX_CELLS)) {\n"
"     return EXECUTE_TABLE_FULL;\n"
"   }"
msgstr ""

#: ../../../_parts/part8.md:818
msgid "And the specs:\n"
"```diff\n"
"+  it 'allows printing out the structure of a one-node btree' do\n"
"+    script = [3, 1, 2].map do |i|\n"
"+      \"insert #{i} user#{i} person#{i}@example.com\"\n"
"+    end\n"
"+    script << \".btree\"\n"
"+    script << \".exit\"\n"
"+    result = run_script(script)\n"
"+\n"
"+    expect(result).to match_array([\n"
"+      \"db > Executed.\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > Tree:\",\n"
"+      \"leaf (size 3)\",\n"
"+      \"  - 0 : 3\",\n"
"+      \"  - 1 : 1\",\n"
"+      \"  - 2 : 2\",\n"
"+      \"db > \"\n"
"+    ])\n"
"+  end\n"
"+\n"
"+  it 'prints constants' do\n"
"+    script = [\n"
"+      \".constants\",\n"
"+      \".exit\",\n"
"+    ]\n"
"+    result = run_script(script)\n"
"+\n"
"+    expect(result).to match_array([\n"
"+      \"db > Constants:\",\n"
"+      \"ROW_SIZE: 293\",\n"
"+      \"COMMON_NODE_HEADER_SIZE: 6\",\n"
"+      \"LEAF_NODE_HEADER_SIZE: 10\",\n"
"+      \"LEAF_NODE_CELL_SIZE: 297\",\n"
"+      \"LEAF_NODE_SPACE_FOR_CELLS: 4086\",\n"
"+      \"LEAF_NODE_MAX_CELLS: 13\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
" end\n"
"```"
msgstr ""

