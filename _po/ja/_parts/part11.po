msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=; plural=;\n"

msgid ""
"---\n"
"title: Part 11 - Recursively Searching the B-Tree\n"
"date: 2017-10-22\n"
"---"
msgstr ""

msgid "Last time we ended with an error inserting our 15th row:"
msgstr ""

msgid ""
"```\n"
"db > insert 15 user15 person15@example.com\n"
"Need to implement searching an internal node\n"
"```"
msgstr ""

msgid "First, replace the code stub with a new function call."
msgstr ""

msgid ""
"```diff\n"
"   if (get_node_type(root_node) == NODE_LEAF) {\n"
"     return leaf_node_find(table, root_page_num, key);\n"
"   } else {\n"
"-    printf(\"Need to implement searching an internal node\n"
"\");\n"
"-    exit(EXIT_FAILURE);\n"
"+    return internal_node_find(table, root_page_num, key);\n"
"   }\n"
" }\n"
"```"
msgstr ""

msgid ""
"This function will perform binary search to find the child that should contain"
" the given key. Remember that the key to the right of each child pointer is th"
"e maximum key contained by that child."
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/btree6.png\" description=\"three-level "
"btree\" %}"
msgstr ""

msgid ""
"So our binary search compares the key to find and the key to the right of the "
"child pointer:"
msgstr ""

msgid ""
"```diff\n"
"+Cursor* internal_node_find(Table* table, uint32_t page_num, uint32_t key) {\n"
"+  void* node = get_page(table->pager, page_num);\n"
"+  uint32_t num_keys = *internal_node_num_keys(node);\n"
"+\n"
"+  /* Binary search to find index of child to search */\n"
"+  uint32_t min_index = 0;\n"
"+  uint32_t max_index = num_keys; /* there is one more child than key */\n"
"+\n"
"+  while (min_index != max_index) {\n"
"+    uint32_t index = (min_index + max_index) / 2;\n"
"+    uint32_t key_to_right = *internal_node_key(node, index);\n"
"+    if (key_to_right >= key) {\n"
"+      max_index = index;\n"
"+    } else {\n"
"+      min_index = index + 1;\n"
"+    }\n"
"+  }\n"
"```"
msgstr ""

msgid ""
"Also remember that the children of an internal node can be either leaf nodes o"
"r more internal nodes. After we find the correct child, call the appropriate s"
"earch function on it:"
msgstr ""

msgid ""
"```diff\n"
"+  uint32_t child_num = *internal_node_child(node, min_index);\n"
"+  void* child = get_page(table->pager, child_num);\n"
"+  switch (get_node_type(child)) {\n"
"+    case NODE_LEAF:\n"
"+      return leaf_node_find(table, child_num, key);\n"
"+    case NODE_INTERNAL:\n"
"+      return internal_node_find(table, child_num, key);\n"
"+  }\n"
"+}\n"
"```"
msgstr ""

msgid "# Tests"
msgstr ""

msgid ""
"Now inserting a key into a multi-node btree no longer results in an error. And"
" we can update our test:"
msgstr ""

msgid ""
"```diff\n"
"       \"    - 12\",\n"
"       \"    - 13\",\n"
"       \"    - 14\",\n"
"-      \"db > Need to implement searching an internal node\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > \",\n"
"     ])\n"
"   end\n"
"```"
msgstr ""

msgid ""
"I also think it's time we revisit another test. The one that tries inserting 1"
"400 rows. It still errors, but the error message is new. Right now, our tests "
"don't handle it very well when the program crashes. If that happens, let's jus"
"t use the output we've gotten so far:"
msgstr ""

msgid ""
"```diff\n"
"     raw_output = nil\n"
"     IO.popen(\"./db test.db\", \"r+\") do |pipe|\n"
"       commands.each do |command|\n"
"-        pipe.puts command\n"
"+        begin\n"
"+          pipe.puts command\n"
"+        rescue Errno::EPIPE\n"
"+          break\n"
"+        end\n"
"       end"
msgstr ""

msgid ""
"       pipe.close_write\n"
"```"
msgstr ""

msgid "And that reveals that our 1400-row test outputs this error:"
msgstr ""

msgid ""
"```diff\n"
"     end\n"
"     script << \".exit\"\n"
"     result = run_script(script)\n"
"-    expect(result[-2]).to eq('db > Error: Table full.')\n"
"+    expect(result.last(2)).to match_array([\n"
"+      \"db > Executed.\",\n"
"+      \"db > Need to implement updating parent after split\",\n"
"+    ])\n"
"   end\n"
"```"
msgstr ""

msgid "Looks like that's next on our to-do list!"
msgstr ""
