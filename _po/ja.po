msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=; plural=;\n"

msgid ""
"        ga('create', '{{ site.google_analytics }}', 'auto');\n"
"        ga('send', 'pageview');\n"
"    </script>\n"
"  {% endif %}\n"
"  </body>\n"
"</html>"
msgstr ""

msgid ""
"       pipe.close_write\n"
"```"
msgstr ""

msgid ""
"      # Read entire output\n"
"      raw_output = pipe.gets(nil)\n"
"    end\n"
"    raw_output.split(\"\n"
"\")\n"
"  end"
msgstr ""

msgid ""
"      <h1>{{ page.title }}</h1>\n"
"      {% if prev_part %}\n"
"          <p><a class=\"prev\" href=\"{{site.baseurl}}{{ prev_part.url }}\">{{prev"
"_part.title}}</a> <br></p>\n"
"      {% endif %}\n"
"      {% if next_part %}\n"
"          <p><a class=\"next\" href=\"{{site.baseurl}}{{ next_part.url }}\">{{next"
"_part.title}}</a> <br></p>\n"
"      {% endif %}"
msgstr ""

msgid "      pipe.close_write"
msgstr ""

msgid ""
"      {% for part in site.parts %}\n"
"          {% if part.url == page.url %}\n"
"              {% assign is_part = true %}\n"
"              {% assign part_index0 = forloop.index0 %}\n"
"              {% assign part_index1 = forloop.index %}\n"
"          {% endif %}\n"
"      {% endfor %}\n"
"      {% for part in site.parts %}\n"
"          {% if part_index0 == forloop.index %}\n"
"              {% assign prev_part = part %}\n"
"          {% endif %}\n"
"          {% if part_index1 == forloop.index0 %}\n"
"              {% assign next_part = part %}\n"
"          {% endif %}\n"
"      {% endfor %}"
msgstr ""

msgid ""
"      {% if prev_part %}\n"
"          <p><a class=\"prev\" href=\"{{site.baseurl}}{{ prev_part.url }}\">{{prev"
"_part.title}}</a> <br></p>\n"
"      {% endif %}\n"
"      {% if next_part %}\n"
"          <p><a class=\"next\" href=\"{{site.baseurl}}{{ next_part.url }}\">{{next"
"_part.title}}</a> <br></p>\n"
"      {% endif %}"
msgstr ""

msgid "      {{ content }}"
msgstr ""

msgid ""
"     ArgumentError:\n"
"       invalid byte sequence in UTF-8\n"
"     # ./spec/main_spec.rb:14:in `split'\n"
"     # ./spec/main_spec.rb:14:in `run_script'\n"
"     # ./spec/main_spec.rb:48:in `block (2 levels) in <top (required)>'\n"
"```"
msgstr ""

msgid ""
"     if (i == cursor->cell_num) {\n"
"-      serialize_row(value, destination);\n"
"+      serialize_row(value,\n"
"+                    leaf_node_value(destination_node, index_within_node));\n"
"+      *leaf_node_key(destination_node, index_within_node) = key;\n"
"     } else if (i > cursor->cell_num) {\n"
"       memcpy(destination, leaf_node_cell(old_node, i - 1), LEAF_NODE_CELL_SIZ"
"E);\n"
"     } else {\n"
"```"
msgstr ""

msgid ""
"     if (input_buffer->buffer[0] == '.') {\n"
"-      switch (do_meta_command(input_buffer)) {\n"
"+      switch (do_meta_command(input_buffer, table)) {\n"
"```\n"
"With these changes, we're able to close then reopen the database, and our reco"
"rds are still there!"
msgstr ""

msgid ""
"     pager->pages[page_num] = page;\n"
"+\n"
"+    if (page_num >= pager->num_pages) {\n"
"+      pager->num_pages = page_num + 1;\n"
"+    }\n"
"   }"
msgstr ""

msgid ""
"    <link rel=\"stylesheet\" href=\"{{ '/assets/css/style.css?v=' | append: site."
"github.build_revision | relative_url }}\">\n"
"    <meta name=\"viewport\" content=\"width=device-width\">\n"
"    <!--[if lt IE 9]>\n"
"    <script src=\"//html5shiv.googlecode.com/svn/trunk/html5.js\"></script>\n"
"    <![endif]-->\n"
"  </head>\n"
"  <body>\n"
"    <div class=\"wrapper\">\n"
"      <header>\n"
"        <h1>{{ site.title | default: site.github.repository_name }}</h1>\n"
"        <p>{{ site.description | default: site.github.project_tagline }}</p>"
msgstr ""

msgid ""
"    if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"      close_input_buffer(input_buffer);\n"
"      exit(EXIT_SUCCESS);\n"
"    } else {\n"
"      printf(\"Unrecognized command '%s'.\n"
"\", input_buffer->buffer);\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""
"    if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"      close_input_buffer(input_buffer);\n"
"      exit(EXIT_SUCCESS);\n"
"    } else {\n"
"      printf(\"'%s'は認識できないコマンドです。\n"
"\", input_buffer->buffer);\n"
"    }\n"
"  }\n"
"}\n"
"```"

msgid ""
"   Row* row_to_insert = &(statement->row_to_insert);\n"
"   Cursor* cursor = table_end(table);"
msgstr ""

msgid ""
"   Row* row_to_insert = &(statement->row_to_insert);\n"
"   uint32_t key_to_insert = row_to_insert->id;\n"
"```"
msgstr ""

msgid ""
"   Row* row_to_insert = &(statement->row_to_insert);\n"
"+  Cursor* cursor = table_end(table);"
msgstr ""

msgid ""
"   Row* row_to_insert = &(statement->row_to_insert);\n"
"-  Cursor* cursor = table_end(table);\n"
"+  uint32_t key_to_insert = row_to_insert->id;\n"
"+  Cursor* cursor = table_find(table, key_to_insert);\n"
"+\n"
"+  if (cursor->cell_num < num_cells) {\n"
"+    uint32_t key_at_index = *leaf_node_key(node, cursor->cell_num);\n"
"+    if (key_at_index == key_to_insert) {\n"
"+      return EXECUTE_DUPLICATE_KEY;\n"
"+    }\n"
"+  }"
msgstr ""

msgid ""
"   Table* table = malloc(sizeof(Table));\n"
"   table->pager = pager;\n"
"-  table->num_rows = num_rows;\n"
"+  table->root_page_num = 0;\n"
"+\n"
"+  if (pager->num_pages == 0) {\n"
"+    // New database file. Initialize page 0 as leaf node.\n"
"+    void* root_node = get_page(pager, 0);\n"
"+    initialize_leaf_node(root_node);\n"
"+  }"
msgstr ""

msgid ""
"   cursor->cell_num += 1;\n"
"   if (cursor->cell_num >= (*leaf_node_num_cells(node))) {\n"
"-    cursor->end_of_table = true;\n"
"+    /* Advance to next leaf node */\n"
"+    uint32_t next_page_num = *leaf_node_next_leaf(node);\n"
"+    if (next_page_num == 0) {\n"
"+      /* This was rightmost leaf */\n"
"+      cursor->end_of_table = true;\n"
"+    } else {\n"
"+      cursor->page_num = next_page_num;\n"
"+      cursor->cell_num = 0;\n"
"+    }\n"
"   }\n"
" }\n"
"```"
msgstr ""

msgid ""
"   for (uint32_t i = 0; i < TABLE_MAX_PAGES; i++) {\n"
"     pager->pages[i] = NULL;\n"
"@@ -194,11 +285,15 @@ Pager* pager_open(const char* filename) {\n"
"@@ -195,11 +287,16 @@ Pager* pager_open(const char* filename) {"
msgstr ""

msgid ""
"   for (uint32_t i = 0; i < TABLE_MAX_PAGES; i++) {\n"
"     pager->pages[i] = NULL;\n"
"```"
msgstr ""

msgid ""
"   free(cursor);\n"
"```"
msgstr ""

msgid ""
"   if (bytes_written == -1) {\n"
"     printf(\"Error writing: %d\n"
"\", errno);\n"
"@@ -252,29 +347,16 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32"
"_t size) {\n"
"@@ -260,29 +357,16 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32"
"_t size) {"
msgstr ""

msgid ""
"   if (bytes_written == -1) {\n"
"     printf(\"Error writing: %d\n"
"\", errno);\n"
"```"
msgstr ""

msgid ""
"   int id = atoi(id_string);\n"
"+  if (id < 0) {\n"
"+    return PREPARE_NEGATIVE_ID;\n"
"+  }\n"
"   if (strlen(username) > COLUMN_USERNAME_SIZE) {\n"
"     return PREPARE_STRING_TOO_LONG;\n"
"   }\n"
"@@ -230,9 +226,6 @@ int main(int argc, char* argv[]) {\n"
"     switch (prepare_statement(input_buffer, &statement)) {\n"
"       case (PREPARE_SUCCESS):\n"
"         break;\n"
"+      case (PREPARE_NEGATIVE_ID):\n"
"+        printf(\"ID must be positive.\n"
"\");\n"
"+        continue;\n"
"       case (PREPARE_STRING_TOO_LONG):\n"
"         printf(\"String is too long.\n"
"\");\n"
"         continue;\n"
"```"
msgstr ""

msgid ""
"   leaf_node_insert(cursor, row_to_insert->id, row_to_insert);\n"
"```"
msgstr ""

msgid ""
"   return cursor;\n"
" }"
msgstr ""

msgid ""
"   return cursor;\n"
" }\n"
"@@ -145,24 +227,28 @@ Cursor* table_start(Table* table) {\n"
" Cursor* table_end(Table* table) {\n"
"   Cursor* cursor = malloc(sizeof(Cursor));\n"
"   cursor->table = table;\n"
"-  cursor->row_num = table->num_rows;\n"
"+  cursor->page_num = table->root_page_num;\n"
"+\n"
"+  void* root_node = get_page(table->pager, table->root_page_num);\n"
"+  uint32_t num_cells = *leaf_node_num_cells(root_node);\n"
"+  cursor->cell_num = num_cells;\n"
"   cursor->end_of_table = true;"
msgstr ""

msgid ""
"   return cursor;\n"
" }\n"
"```"
msgstr ""

msgid ""
"   return pager->pages[page_num];\n"
"@@ -136,8 +214,12 @@ void* get_page(Pager* pager, uint32_t page_num) {\n"
" Cursor* table_start(Table* table) {\n"
"   Cursor* cursor = malloc(sizeof(Cursor));\n"
"   cursor->table = table;\n"
"-  cursor->row_num = 0;\n"
"-  cursor->end_of_table = (table->num_rows == 0);\n"
"+  cursor->page_num = table->root_page_num;\n"
"+  cursor->cell_num = 0;\n"
"+\n"
"+  void* root_node = get_page(table->pager, table->root_page_num);\n"
"+  uint32_t num_cells = *leaf_node_num_cells(root_node);\n"
"+  cursor->end_of_table = (num_cells == 0);"
msgstr ""

msgid ""
"   return pager->pages[page_num];\n"
"```"
msgstr ""

msgid ""
"   return table;\n"
" }\n"
"@@ -234,7 +331,7 @@ void close_input_buffer(InputBuffer* input_buffer) {\n"
"     free(input_buffer);\n"
" }"
msgstr ""

msgid ""
"   return table;\n"
" }\n"
"```"
msgstr ""

msgid ""
"   return table;\n"
"```"
msgstr ""

msgid ""
"   ssize_t bytes_written =\n"
"-      write(pager->file_descriptor, pager->pages[page_num], size);\n"
"+      write(pager->file_descriptor, pager->pages[page_num], PAGE_SIZE);"
msgstr ""

msgid ""
"   uint32_t num_cells = *leaf_node_num_cells(node);\n"
"   if (num_cells >= LEAF_NODE_MAX_CELLS) {\n"
"     // Node full\n"
"-    printf(\"Need to implement splitting a leaf node.\n"
"\");\n"
"-    exit(EXIT_FAILURE);\n"
"+    leaf_node_split_and_insert(cursor, key, value);\n"
"+    return;\n"
"   }\n"
"```"
msgstr ""

msgid ""
"   void* old_node = get_page(cursor->table->pager, cursor->page_num);\n"
"+  uint32_t old_max = get_node_max_key(old_node);\n"
"   uint32_t new_page_num = get_unused_page_num(cursor->table->pager);\n"
"   void* new_node = get_page(cursor->table->pager, new_page_num);\n"
"   initialize_leaf_node(new_node);\n"
"+  *node_parent(new_node) = *node_parent(old_node);\n"
"   *leaf_node_next_leaf(new_node) = *leaf_node_next_leaf(old_node);\n"
"   *leaf_node_next_leaf(old_node) = new_page_num;"
msgstr ""

msgid ""
"  // Ignore trailing newline\n"
"  input_buffer->input_length = bytes_read - 1;\n"
"  input_buffer->buffer[bytes_read - 1] = 0;\n"
"}"
msgstr ""
"  // 最後の行の改行を無視する\n"
"  input_buffer->input_length = bytes_read - 1;\n"
"  input_buffer->buffer[bytes_read - 1] = 0;\n"
"}"

msgid ""
"  // Ignore trailing newline\n"
"  input_buffer->input_length = bytes_read - 1;\n"
"  input_buffer->buffer[bytes_read - 1] = 0;\n"
"}\n"
"```"
msgstr ""
"  // 最後の行の改行を無視する\n"
"  input_buffer->input_length = bytes_read - 1;\n"
"  input_buffer->buffer[bytes_read - 1] = 0;\n"
"}\n"
"```"

msgid ""
"  // 最後の行の改行を無視する\n"
"  input_buffer->input_length = bytes_read - 1;\n"
"  input_buffer->buffer[bytes_read - 1] = 0;\n"
"}"
msgstr ""

msgid ""
"  // 最後の行の改行を無視する\n"
"  input_buffer->input_length = bytes_read - 1;\n"
"  input_buffer->buffer[bytes_read - 1] = 0;\n"
"}\n"
"```"
msgstr ""

msgid ""
"  1) database allows inserting strings that are the maximum length\n"
"     Failure/Error: raw_output.split(\"\n"
"\")"
msgstr ""

msgid ""
"  if (bytes_read <= 0) {\n"
"    printf(\"Error reading input\n"
"\");\n"
"    exit(EXIT_FAILURE);\n"
"  }"
msgstr ""
"  if (bytes_read <= 0) {\n"
"    printf(\"入力エラー!\n"
"\");\n"
"    exit(EXIT_FAILURE);\n"
"  }"

msgid ""
"  it 'inserts and retrieves a row' do\n"
"    result = run_script([\n"
"      \"insert 1 user1 person1@example.com\",\n"
"      \"select\",\n"
"      \".exit\",\n"
"    ])\n"
"    expect(result).to match_array([\n"
"      \"db > Executed.\",\n"
"      \"db > (1, user1, person1@example.com)\",\n"
"      \"Executed.\",\n"
"      \"db > \",\n"
"    ])\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"  return PREPARE_UNRECOGNIZED_STATEMENT;\n"
"}\n"
"```"
msgstr ""

msgid ""
"  return input_buffer;\n"
"}"
msgstr ""
"  return input_buffer;\n"
"}"

msgid ""
"  return input_buffer;\n"
"}\n"
"```"
msgstr ""
"  return input_buffer;\n"
"}\n"
"```"

msgid ""
"  {% if site.google_analytics %}\n"
"    <script>\n"
"        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||funct"
"ion(){\n"
"        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createEle"
"ment(o),\n"
"        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBe"
"fore(a,m)\n"
"        })(window,document,'script','https://www.google-analytics.com/analytic"
"s.js','ga');"
msgstr ""

msgid ""
" And indeed that fixes it:\n"
" ```ruby\n"
" bundle exec rspec\n"
"..."
msgstr ""

msgid ""
" ExecuteResult execute_select(Statement* statement, Table* table) {\n"
"+  Cursor* cursor = table_start(table);\n"
"+\n"
"   Row row;\n"
"-  for (uint32_t i = 0; i < table->num_rows; i++) {\n"
"-     deserialize_row(row_slot(table, i), &row);\n"
"+  while (!(cursor->end_of_table)) {\n"
"+     deserialize_row(cursor_value(cursor), &row);\n"
"      print_row(&row);\n"
"+     cursor_advance(cursor);\n"
"   }\n"
"+\n"
"+  free(cursor);\n"
"+\n"
"   return EXECUTE_SUCCESS;\n"
" }\n"
"```"
msgstr ""

msgid ""
" InputBuffer* new_input_buffer() {\n"
"@@ -142,10 +201,76 @@ void close_input_buffer(InputBuffer* input_buffer) {\n"
"   free(input_buffer);\n"
" }"
msgstr ""

msgid ""
" Pager* pager_open(const char* filename) {\n"
"@@ -327,19 +360,28 @@ ExecuteResult execute_insert(Statement* statement, Table"
"* table) {\n"
"     }"
msgstr ""

msgid ""
" Table* db_open(const char* filename) {\n"
"   Pager* pager = pager_open(filename);\n"
"-  uint32_t num_rows = pager->file_length / ROW_SIZE;"
msgstr ""

msgid ""
" With those changes we can actually save data in our database!\n"
" ```command-line\n"
"~ ./db\n"
"db > insert 1 cstack foo@bar.com\n"
"Executed.\n"
"db > insert 2 bob bob@example.com\n"
"Executed.\n"
"db > select\n"
"(1, cstack, foo@bar.com)\n"
"(2, bob, bob@example.com)\n"
"Executed.\n"
"db > insert foo bar 1\n"
"Syntax error. Could not parse statement.\n"
"db > .exit\n"
"~\n"
"```"
msgstr ""

msgid " ```"
msgstr ""

msgid ""
" const uint32_t PAGE_SIZE = 4096;\n"
" #define TABLE_MAX_PAGES 100\n"
"-const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;\n"
"-const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;"
msgstr ""

msgid ""
" enum PrepareResult_t {\n"
"   PREPARE_SUCCESS,\n"
"+  PREPARE_NEGATIVE_ID,\n"
"+  PREPARE_STRING_TOO_LONG,\n"
"   PREPARE_SYNTAX_ERROR,\n"
"   PREPARE_UNRECOGNIZED_STATEMENT\n"
"  };\n"
"@@ -34,8 +36,8 @@\n"
" #define COLUMN_EMAIL_SIZE 255\n"
" typedef struct {\n"
"   uint32_t id;\n"
"-  char username[COLUMN_USERNAME_SIZE];\n"
"-  char email[COLUMN_EMAIL_SIZE];\n"
"+  char username[COLUMN_USERNAME_SIZE + 1];\n"
"+  char email[COLUMN_EMAIL_SIZE + 1];\n"
" } Row;"
msgstr ""

msgid ""
" int main(int argc, char* argv[]) {\n"
"-  Table* table = new_table();\n"
"+  if (argc < 2) {\n"
"+      printf(\"Must supply a database filename.\n"
"\");\n"
"+      exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  char* filename = argv[1];\n"
"+  Table* table = db_open(filename);\n"
"+\n"
"   InputBuffer* input_buffer = new_input_buffer();\n"
"   while (true) {\n"
"     print_prompt();\n"
"```"
msgstr ""

msgid ""
" struct InputBuffer_t {\n"
"   char* buffer;\n"
"@@ -62,9 +65,16 @@ const uint32_t PAGE_SIZE = 4096;\n"
" const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;\n"
" const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;"
msgstr ""

msgid ""
" typedef struct {\n"
"   Pager* pager;\n"
"-  uint32_t num_rows;\n"
"+  uint32_t root_page_num;\n"
" } Table;"
msgstr ""

msgid ""
" typedef struct {\n"
"   Pager* pager;\n"
"-  uint32_t num_rows;\n"
"+  uint32_t root_page_num;\n"
" } Table;\n"
"```"
msgstr ""

msgid ""
" typedef struct {\n"
"   Table* table;\n"
"-  uint32_t row_num;\n"
"+  uint32_t page_num;\n"
"+  uint32_t cell_num;\n"
"   bool end_of_table;  // Indicates a position one past the last element\n"
" } Cursor;"
msgstr ""

msgid ""
" typedef struct {\n"
"   char* buffer;\n"
"@@ -10,6 +11,105 @@ typedef struct {\n"
" } InputBuffer;"
msgstr ""

msgid ""
" typedef struct {\n"
"   int file_descriptor;\n"
"   uint32_t file_length;\n"
"+  uint32_t num_pages;\n"
"   void* pages[TABLE_MAX_PAGES];\n"
" } Pager;"
msgstr ""

msgid ""
" void cursor_advance(Cursor* cursor) {\n"
"-  cursor->row_num += 1;\n"
"-  if (cursor->row_num >= cursor->table->num_rows) {\n"
"+  uint32_t page_num = cursor->page_num;\n"
"+  void* node = get_page(cursor->table->pager, page_num);\n"
"+\n"
"+  cursor->cell_num += 1;\n"
"+  if (cursor->cell_num >= (*leaf_node_num_cells(node))) {\n"
"     cursor->end_of_table = true;\n"
"   }\n"
" }\n"
"@@ -185,6 +271,12 @@ Pager* pager_open(const char* filename) {\n"
"   Pager* pager = malloc(sizeof(Pager));\n"
"   pager->file_descriptor = fd;\n"
"   pager->file_length = file_length;\n"
"+  pager->num_pages = (file_length / PAGE_SIZE);\n"
"+\n"
"+  if (file_length % PAGE_SIZE != 0) {\n"
"+    printf(\"Db file is not a whole number of pages. Corrupt file.\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }"
msgstr ""

msgid ""
" void db_close(Table* table) {\n"
"   Pager* pager = table->pager;\n"
"-  uint32_t num_full_pages = table->num_rows / ROWS_PER_PAGE;"
msgstr ""

msgid ""
" void* cursor_value(Cursor* cursor) {\n"
"-  uint32_t row_num = cursor->row_num;\n"
"-  uint32_t page_num = row_num / ROWS_PER_PAGE;\n"
"+  uint32_t page_num = cursor->page_num;\n"
"   void* page = get_page(cursor->table->pager, page_num);\n"
"-  uint32_t row_offset = row_num % ROWS_PER_PAGE;\n"
"-  uint32_t byte_offset = row_offset * ROW_SIZE;\n"
"-  return page + byte_offset;\n"
"+  return leaf_node_value(page, cursor->cell_num);\n"
" }"
msgstr ""

msgid ""
" }\n"
"+\n"
" PrepareResult prepare_statement(InputBuffer* input_buffer,\n"
"                                 Statement* statement) {\n"
"   if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n"
"@@ -227,7 +354,14 @@ ExecuteResult execute_statement(Statement* statement, Tab"
"le *table) {\n"
" }"
msgstr ""

msgid ""
"\"Unrecognized statement\"? That seems a bit like an exception. But [exceptions "
"are bad](https://www.youtube.com/watch?v=EVhCUSgNbzo) (and C doesn't even supp"
"ort them), so I'm using enum result codes wherever practical. The C compiler w"
"ill complain if my switch statement doesn't handle a member of the enum, so we"
" can feel a little more confident we handle every result of a function. Expect"
" more result codes to be added in the future."
msgstr ""

msgid "# Let's Build a Simple Database"
msgstr "# さあシンプルなデータベースを作りましょう!"

msgid "# Sqlite"
msgstr "# Sqlite"

msgid "# Tests"
msgstr ""

msgid "# さあシンプルなデータベースを作りましょう!"
msgstr ""

msgid "# シンプルなデータベースを作りましょう!"
msgstr ""

msgid "## A Major Problem"
msgstr ""

msgid "## Accessing Leaf Node Fields"
msgstr ""

msgid "## Allocating New Pages"
msgstr ""

msgid "## Alternative Table Formats"
msgstr ""

msgid "## Changes to Pager and Table Objects"
msgstr ""

msgid "## Changes to the Cursor Object"
msgstr ""

msgid "## Command to Print Constants"
msgstr ""

msgid "## Complete Diff"
msgstr ""

msgid ""
"## Complete Diff\n"
"```diff\n"
"+#include <errno.h>\n"
"+#include <fcntl.h>\n"
" #include <stdbool.h>\n"
" #include <stdio.h>\n"
" #include <stdlib.h>\n"
" #include <string.h>\n"
" #include <stdint.h>\n"
"+#include <unistd.h>"
msgstr ""

msgid "## Conclusion"
msgstr ""

msgid "## Creating a New Root"
msgstr ""

msgid "## Insertion Into a Leaf Node"
msgstr ""

msgid "## Internal Node Format"
msgstr ""

msgid "## Keeping Track of the Root"
msgstr ""

msgid "## Leaf Node Format"
msgstr ""

msgid "## Leaf Node Sizes"
msgstr ""

msgid "## Making a Simple REPL"
msgstr "## シンプルなREPLを作ってみよう!"

msgid "## Next Time"
msgstr ""

msgid "## Node Header Format"
msgstr ""

msgid "## Notes to myself"
msgstr "## ビルドするための備忘録"

msgid "## Printing the Tree"
msgstr ""

msgid "## Splitting Algorithm"
msgstr ""

msgid "## Tree Visualization"
msgstr ""

msgid "## シンプルなREPLを作ってみよう!"
msgstr ""

msgid "## ビルドするための備忘録"
msgstr ""

msgid ""
"**B木**は多くのノードから成り立っています。それらは一つのページに収められています。B木はページャーにディスクに戻す命令を発行し、ディスクからページを取"
"得したり保存します。"
msgstr ""

msgid ""
"**NOTE**: If we wanted to ensure that all bytes are initialized, it would\n"
"suffice to use `strncpy` instead of `memcpy` while copying the `username`\n"
"and `email` fields of rows in `serialize_row`, like so:"
msgstr ""

msgid "**os interface**はsqliteがコンパイルされたOSによって異なります。このチュートリアルは、様々なプラットフォームをサポートします。"
msgstr ""

msgid ""
"**ページャー**はデータを読み書きする命令を出します。ページャーはデータベースを適切なオフセットで読み書きします。ページャーはメモリに最近使用したページの"
"キャッシュを保存し、ディスクにページを書き戻す時に使用されます。"
msgstr ""

msgid ""
"**仮想マシン**はフロントエンドの段階で生成されたバイトコードを使用します。B木と呼ばれるデータ構造にそれぞれのデータは保存され、多数のテーブルやインデッ"
"クスを操作します。仮想マシンはバイトコードの実行を切り替えるのに必要です。"
msgstr ""

msgid ""
"+  free(cursor);\n"
"+\n"
"   return EXECUTE_SUCCESS;\n"
" }"
msgstr ""

msgid ""
"+  free(cursor);\n"
"+\n"
"   return EXECUTE_SUCCESS;\n"
" }\n"
" ```"
msgstr ""

msgid ""
"+  it 'keeps data after closing connection' do\n"
"+    result1 = run_script([\n"
"+      \"insert 1 user1 person1@example.com\",\n"
"+      \".exit\",\n"
"+    ])\n"
"+    expect(result1).to match_array([\n"
"+      \"db > Executed.\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+\n"
"+    result2 = run_script([\n"
"+      \"select\",\n"
"+      \".exit\",\n"
"+    ])\n"
"+    expect(result2).to match_array([\n"
"+      \"db > (1, user1, person1@example.com)\",\n"
"+      \"Executed.\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
"+\n"
"   it 'prints error message when table is full' do\n"
"     script = (1..1401).map do |i|\n"
"       \"insert #{i} user#{i} person#{i}@example.com\"\n"
"```"
msgstr ""

msgid ""
"+MetaCommandResult do_meta_command(InputBuffer* input_buffer) {\n"
"+  if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"+    close_input_buffer(input_buffer);\n"
"+    exit(EXIT_SUCCESS);\n"
"+  } else {\n"
"+    return META_COMMAND_UNRECOGNIZED_COMMAND;\n"
"+  }\n"
"+}\n"
"+\n"
"+PrepareResult prepare_statement(InputBuffer* input_buffer,\n"
"+                                Statement* statement) {\n"
"+  if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n"
"+    statement->type = STATEMENT_INSERT;\n"
"+    return PREPARE_SUCCESS;\n"
"+  }\n"
"+  if (strcmp(input_buffer->buffer, \"select\") == 0) {\n"
"+    statement->type = STATEMENT_SELECT;\n"
"+    return PREPARE_SUCCESS;\n"
"+  }\n"
"+\n"
"+  return PREPARE_UNRECOGNIZED_STATEMENT;\n"
"+}\n"
"+\n"
"+void execute_statement(Statement* statement) {\n"
"+  switch (statement->type) {\n"
"+    case (STATEMENT_INSERT):\n"
"+      printf(\"This is where we would do an insert.\n"
"\");\n"
"+      break;\n"
"+    case (STATEMENT_SELECT):\n"
"+      printf(\"This is where we would do a select.\n"
"\");\n"
"+      break;\n"
"+  }\n"
"+}\n"
"+\n"
" int main(int argc, char* argv[]) {\n"
"   InputBuffer* input_buffer = new_input_buffer();\n"
"   while (true) {\n"
"     print_prompt();\n"
"     read_input(input_buffer);"
msgstr ""

msgid ""
"+MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table *table) {\n"
"+  if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"+    close_input_buffer(input_buffer);\n"
"+    free_table(table);\n"
"+    exit(EXIT_SUCCESS);\n"
"+  } else {\n"
"+    return META_COMMAND_UNRECOGNIZED_COMMAND;\n"
"+  }\n"
"+}\n"
"+\n"
"+PrepareResult prepare_statement(InputBuffer* input_buffer,\n"
"+                                Statement* statement) {\n"
"+  if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n"
"+    statement->type = STATEMENT_INSERT;\n"
"+    int args_assigned = sscanf(\n"
"+\tinput_buffer->buffer, \"insert %d %s %s\", &(statement->row_to_insert.id),\n"
"+\tstatement->row_to_insert.username, statement->row_to_insert.email\n"
"+\t);\n"
"+    if (args_assigned < 3) {\n"
"+\treturn PREPARE_SYNTAX_ERROR;\n"
"+    }\n"
"+    return PREPARE_SUCCESS;\n"
"+  }\n"
"+  if (strcmp(input_buffer->buffer, \"select\") == 0) {\n"
"+    statement->type = STATEMENT_SELECT;\n"
"+    return PREPARE_SUCCESS;\n"
"+  }\n"
"+\n"
"+  return PREPARE_UNRECOGNIZED_STATEMENT;\n"
"+}\n"
"+\n"
"+ExecuteResult execute_insert(Statement* statement, Table* table) {\n"
"+  if (table->num_rows >= TABLE_MAX_ROWS) {\n"
"+     return EXECUTE_TABLE_FULL;\n"
"+  }\n"
"+\n"
"+  Row* row_to_insert = &(statement->row_to_insert);\n"
"+\n"
"+  serialize_row(row_to_insert, row_slot(table, table->num_rows));\n"
"+  table->num_rows += 1;\n"
"+\n"
"+  return EXECUTE_SUCCESS;\n"
"+}\n"
"+\n"
"+ExecuteResult execute_select(Statement* statement, Table* table) {\n"
"+  Row row;\n"
"+  for (uint32_t i = 0; i < table->num_rows; i++) {\n"
"+     deserialize_row(row_slot(table, i), &row);\n"
"+     print_row(&row);\n"
"+  }\n"
"+  return EXECUTE_SUCCESS;\n"
"+}\n"
"+\n"
"+ExecuteResult execute_statement(Statement* statement, Table *table) {\n"
"+  switch (statement->type) {\n"
"+    case (STATEMENT_INSERT):\n"
"+       \treturn execute_insert(statement, table);\n"
"+    case (STATEMENT_SELECT):\n"
"+\treturn execute_select(statement, table);\n"
"+  }\n"
"+}\n"
"+\n"
" int main(int argc, char* argv[]) {\n"
"+  Table* table = new_table();\n"
"   InputBuffer* input_buffer = new_input_buffer();\n"
"   while (true) {\n"
"     print_prompt();\n"
"     read_input(input_buffer);"
msgstr ""

msgid ""
"+typedef enum {\n"
"+  META_COMMAND_SUCCESS,\n"
"+  META_COMMAND_UNRECOGNIZED_COMMAND\n"
"+} MetaCommandResult;\n"
"+\n"
"+typedef enum { PREPARE_SUCCESS, PREPARE_UNRECOGNIZED_STATEMENT } PrepareResul"
"t;\n"
"+\n"
"+typedef enum { STATEMENT_INSERT, STATEMENT_SELECT } StatementType;\n"
"+\n"
"+typedef struct {\n"
"+  StatementType type;\n"
"+} Statement;\n"
"+\n"
" InputBuffer* new_input_buffer() {\n"
"   InputBuffer* input_buffer = malloc(sizeof(InputBuffer));\n"
"   input_buffer->buffer = NULL;\n"
"@@ -40,17 +57,67 @@ void close_input_buffer(InputBuffer* input_buffer) {\n"
"     free(input_buffer);\n"
" }"
msgstr ""

msgid ""
"+typedef enum { EXECUTE_SUCCESS, EXECUTE_TABLE_FULL } ExecuteResult;\n"
"+\n"
"+typedef enum {\n"
"+  META_COMMAND_SUCCESS,\n"
"+  META_COMMAND_UNRECOGNIZED_COMMAND\n"
"+} MetaCommandResult;\n"
"+\n"
"+typedef enum {\n"
"+  PREPARE_SUCCESS,\n"
"+  PREPARE_SYNTAX_ERROR,\n"
"+  PREPARE_UNRECOGNIZED_STATEMENT\n"
"+ } PrepareResult;\n"
"+\n"
"+typedef enum { STATEMENT_INSERT, STATEMENT_SELECT } StatementType;\n"
"+\n"
"+#define COLUMN_USERNAME_SIZE 32\n"
"+#define COLUMN_EMAIL_SIZE 255\n"
"+typedef struct {\n"
"+  uint32_t id;\n"
"+  char username[COLUMN_USERNAME_SIZE];\n"
"+  char email[COLUMN_EMAIL_SIZE];\n"
"+} Row;\n"
"+\n"
"+typedef struct {\n"
"+  StatementType type;\n"
"+  Row row_to_insert; //only used by insert statement\n"
"+} Statement;\n"
"+\n"
"+#define size_of_attribute(Struct, Attribute) sizeof(((Struct*)0)->Attribute)\n"
"+\n"
"+const uint32_t ID_SIZE = size_of_attribute(Row, id);\n"
"+const uint32_t USERNAME_SIZE = size_of_attribute(Row, username);\n"
"+const uint32_t EMAIL_SIZE = size_of_attribute(Row, email);\n"
"+const uint32_t ID_OFFSET = 0;\n"
"+const uint32_t USERNAME_OFFSET = ID_OFFSET + ID_SIZE;\n"
"+const uint32_t EMAIL_OFFSET = USERNAME_OFFSET + USERNAME_SIZE;\n"
"+const uint32_t ROW_SIZE = ID_SIZE + USERNAME_SIZE + EMAIL_SIZE;\n"
"+\n"
"+const uint32_t PAGE_SIZE = 4096;\n"
"+#define TABLE_MAX_PAGES 100\n"
"+const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;\n"
"+const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;\n"
"+\n"
"+typedef struct {\n"
"+  uint32_t num_rows;\n"
"+  void* pages[TABLE_MAX_PAGES];\n"
"+} Table;\n"
"+\n"
"+void print_row(Row* row) {\n"
"+  printf(\"(%d, %s, %s)\n"
"\", row->id, row->username, row->email);\n"
"+}\n"
"+\n"
"+void serialize_row(Row* source, void* destination) {\n"
"+  memcpy(destination + ID_OFFSET, &(source->id), ID_SIZE);\n"
"+  memcpy(destination + USERNAME_OFFSET, &(source->username), USERNAME_SIZE);\n"
"+  memcpy(destination + EMAIL_OFFSET, &(source->email), EMAIL_SIZE);\n"
"+}\n"
"+\n"
"+void deserialize_row(void *source, Row* destination) {\n"
"+  memcpy(&(destination->id), source + ID_OFFSET, ID_SIZE);\n"
"+  memcpy(&(destination->username), source + USERNAME_OFFSET, USERNAME_SIZE);\n"
"+  memcpy(&(destination->email), source + EMAIL_OFFSET, EMAIL_SIZE);\n"
"+}\n"
"+\n"
"+void* row_slot(Table* table, uint32_t row_num) {\n"
"+  uint32_t page_num = row_num / ROWS_PER_PAGE;\n"
"+  void *page = table->pages[page_num];\n"
"+  if (page == NULL) {\n"
"+     // Allocate memory only when we try to access page\n"
"+     page = table->pages[page_num] = malloc(PAGE_SIZE);\n"
"+  }\n"
"+  uint32_t row_offset = row_num % ROWS_PER_PAGE;\n"
"+  uint32_t byte_offset = row_offset * ROW_SIZE;\n"
"+  return page + byte_offset;\n"
"+}\n"
"+\n"
"+Table* new_table() {\n"
"+  Table* table = malloc(sizeof(Table));\n"
"+  table->num_rows = 0;\n"
"+  for (uint32_t i = 0; i < TABLE_MAX_PAGES; i++) {\n"
"+     table->pages[i] = NULL;\n"
"+  }\n"
"+  return table;\n"
"+}\n"
"+\n"
"+void free_table(Table* table) {\n"
"+  for (int i = 0; table->pages[i]; i++) {\n"
"+     free(table->pages[i]);\n"
"+  }\n"
"+  free(table);\n"
"+}\n"
"+\n"
" InputBuffer* new_input_buffer() {\n"
"   InputBuffer* input_buffer = malloc(sizeof(InputBuffer));\n"
"   input_buffer->buffer = NULL;\n"
"@@ -40,17 +140,105 @@ void close_input_buffer(InputBuffer* input_buffer) {\n"
"     free(input_buffer);\n"
" }"
msgstr ""

msgid ""
"+typedef enum { NODE_INTERNAL, NODE_LEAF } NodeType;\n"
"+\n"
"+/*\n"
"+ * Common Node Header Layout\n"
"+ */\n"
"+const uint32_t NODE_TYPE_SIZE = sizeof(uint8_t);\n"
"+const uint32_t NODE_TYPE_OFFSET = 0;\n"
"+const uint32_t IS_ROOT_SIZE = sizeof(uint8_t);\n"
"+const uint32_t IS_ROOT_OFFSET = NODE_TYPE_SIZE;\n"
"+const uint32_t PARENT_POINTER_SIZE = sizeof(uint32_t);\n"
"+const uint32_t PARENT_POINTER_OFFSET = IS_ROOT_OFFSET + IS_ROOT_SIZE;\n"
"+const uint8_t COMMON_NODE_HEADER_SIZE =\n"
"+    NODE_TYPE_SIZE + IS_ROOT_SIZE + PARENT_POINTER_SIZE;\n"
"+\n"
"+/*\n"
"+ * Leaf Node Header Layout\n"
"+ */\n"
"+const uint32_t LEAF_NODE_NUM_CELLS_SIZE = sizeof(uint32_t);\n"
"+const uint32_t LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;\n"
"+const uint32_t LEAF_NODE_HEADER_SIZE =\n"
"+    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;\n"
"+\n"
"+/*\n"
"+ * Leaf Node Body Layout\n"
"+ */\n"
"+const uint32_t LEAF_NODE_KEY_SIZE = sizeof(uint32_t);\n"
"+const uint32_t LEAF_NODE_KEY_OFFSET = 0;\n"
"+const uint32_t LEAF_NODE_VALUE_SIZE = ROW_SIZE;\n"
"+const uint32_t LEAF_NODE_VALUE_OFFSET =\n"
"+    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;\n"
"+const uint32_t LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZ"
"E;\n"
"+const uint32_t LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;"
"\n"
"+const uint32_t LEAF_NODE_MAX_CELLS =\n"
"+    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;\n"
"+\n"
"+uint32_t* leaf_node_num_cells(void* node) {\n"
"+  return node + LEAF_NODE_NUM_CELLS_OFFSET;\n"
"+}\n"
"+\n"
"+void* leaf_node_cell(void* node, uint32_t cell_num) {\n"
"+  return node + LEAF_NODE_HEADER_SIZE + cell_num * LEAF_NODE_CELL_SIZE;\n"
"+}\n"
"+\n"
"+uint32_t* leaf_node_key(void* node, uint32_t cell_num) {\n"
"+  return leaf_node_cell(node, cell_num);\n"
"+}\n"
"+\n"
"+void* leaf_node_value(void* node, uint32_t cell_num) {\n"
"+  return leaf_node_cell(node, cell_num) + LEAF_NODE_KEY_SIZE;\n"
"+}\n"
"+\n"
"+void print_constants() {\n"
"+  printf(\"ROW_SIZE: %d\n"
"\", ROW_SIZE);\n"
"+  printf(\"COMMON_NODE_HEADER_SIZE: %d\n"
"\", COMMON_NODE_HEADER_SIZE);\n"
"+  printf(\"LEAF_NODE_HEADER_SIZE: %d\n"
"\", LEAF_NODE_HEADER_SIZE);\n"
"+  printf(\"LEAF_NODE_CELL_SIZE: %d\n"
"\", LEAF_NODE_CELL_SIZE);\n"
"+  printf(\"LEAF_NODE_SPACE_FOR_CELLS: %d\n"
"\", LEAF_NODE_SPACE_FOR_CELLS);\n"
"+  printf(\"LEAF_NODE_MAX_CELLS: %d\n"
"\", LEAF_NODE_MAX_CELLS);\n"
"+}\n"
"+\n"
"+void print_leaf_node(void* node) {\n"
"+  uint32_t num_cells = *leaf_node_num_cells(node);\n"
"+  printf(\"leaf (size %d)\n"
"\", num_cells);\n"
"+  for (uint32_t i = 0; i < num_cells; i++) {\n"
"+    uint32_t key = *leaf_node_key(node, i);\n"
"+    printf(\"  - %d : %d\n"
"\", i, key);\n"
"+  }\n"
"+}\n"
"+\n"
" void print_row(Row* row) {\n"
"     printf(\"(%d, %s, %s)\n"
"\", row->id, row->username, row->email);\n"
" }\n"
"@@ -101,6 +173,8 @@ void deserialize_row(void *source, Row* destination) {\n"
"     memcpy(&(destination->email), source + EMAIL_OFFSET, EMAIL_SIZE);\n"
" }"
msgstr ""

msgid ""
"+typedef struct {\n"
"+  Table* table;\n"
"+  uint32_t row_num;\n"
"+  bool end_of_table; // Indicates a position one past the last element\n"
"+} Cursor;\n"
"+\n"
" void print_row(Row* row) {\n"
"     printf(\"(%d, %s, %s)\n"
"\", row->id, row->username, row->email);\n"
" }\n"
"@@ -126,12 +133,38 @@ void* get_page(Pager* pager, uint32_t page_num) {\n"
"     return pager->pages[page_num];\n"
" }"
msgstr ""

msgid ""
"+typedef struct {\n"
"+  int file_descriptor;\n"
"+  uint32_t file_length;\n"
"+  void* pages[TABLE_MAX_PAGES];\n"
"+} Pager;\n"
"+\n"
" typedef struct {\n"
"   uint32_t num_rows;\n"
"-  void* pages[TABLE_MAX_PAGES];\n"
"+  Pager* pager;\n"
" } Table;"
msgstr ""

msgid ""
"+void initialize_internal_node(void* node) {\n"
"+  set_node_type(node, NODE_INTERNAL);\n"
"+  set_node_root(node, false);\n"
"+  *internal_node_num_keys(node) = 0;\n"
"+}\n"
"```"
msgstr ""

msgid ""
"+void initialize_leaf_node(void* node) { *leaf_node_num_cells(node) = 0; }\n"
"+\n"
" void* get_page(Pager* pager, uint32_t page_num) {\n"
"   if (page_num > TABLE_MAX_PAGES) {\n"
"     printf(\"Tried to fetch page number out of bounds. %d > %d\n"
"\", page_num,\n"
"@@ -128,6 +202,10 @@ void* get_page(Pager* pager, uint32_t page_num) {\n"
"     }"
msgstr ""

msgid ""
"+void leaf_node_insert(Cursor* cursor, uint32_t key, Row* value) {\n"
"+  void* node = get_page(cursor->table->pager, cursor->page_num);\n"
"+\n"
"+  uint32_t num_cells = *leaf_node_num_cells(node);\n"
"+  if (num_cells >= LEAF_NODE_MAX_CELLS) {\n"
"+    // Node full\n"
"+    printf(\"Need to implement splitting a leaf node.\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  if (cursor->cell_num < num_cells) {\n"
"+    // Make room for new cell\n"
"+    for (uint32_t i = num_cells; i > cursor->cell_num; i--) {\n"
"+      memcpy(leaf_node_cell(node, i), leaf_node_cell(node, i - 1),\n"
"+             LEAF_NODE_CELL_SIZE);\n"
"+    }\n"
"+  }\n"
"+\n"
"+  *(leaf_node_num_cells(node)) += 1;\n"
"+  *(leaf_node_key(node, cursor->cell_num)) = key;\n"
"+  serialize_row(value, leaf_node_value(node, cursor->cell_num));\n"
"+}\n"
"+\n"
" ExecuteResult execute_insert(Statement* statement, Table* table) {\n"
"-  if (table->num_rows >= TABLE_MAX_ROWS) {\n"
"+  void* node = get_page(table->pager, table->root_page_num);\n"
"+  if ((*leaf_node_num_cells(node) >= LEAF_NODE_MAX_CELLS)) {\n"
"     return EXECUTE_TABLE_FULL;\n"
"   }"
msgstr ""

msgid ""
"+void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {\n"
"+  if (pager->pages[page_num] == NULL) {\n"
"+     printf(\"Tried to flush null page\n"
"\");\n"
"+     exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  off_t offset = lseek(pager->file_descriptor, page_num * PAGE_SIZE,\n"
"+     \t\t SEEK_SET);\n"
"+\n"
"+  if (offset == -1) {\n"
"+     printf(\"Error seeking: %d\n"
"\", errno);\n"
"+     exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  ssize_t bytes_written = write(\n"
"+     pager->file_descriptor, pager->pages[page_num], size\n"
"+     );\n"
"+\n"
"+  if (bytes_written == -1) {\n"
"+     printf(\"Error writing: %d\n"
"\", errno);\n"
"+     exit(EXIT_FAILURE);\n"
"+  }\n"
"+}\n"
"+\n"
"+void db_close(Table* table) {\n"
"+  Pager* pager = table->pager;\n"
"+  uint32_t num_full_pages = table->num_rows / ROWS_PER_PAGE;\n"
"+\n"
"+  for (uint32_t i = 0; i < num_full_pages; i++) {\n"
"+     if (pager->pages[i] == NULL) {\n"
"+         continue;\n"
"+     }\n"
"+     pager_flush(pager, i, PAGE_SIZE);\n"
"+     free(pager->pages[i]);\n"
"+     pager->pages[i] = NULL;\n"
"+  }\n"
"+\n"
"+  // There may be a partial page to write to the end of the file\n"
"+  // This should not be needed after we switch to a B-tree\n"
"+  uint32_t num_additional_rows = table->num_rows % ROWS_PER_PAGE;\n"
"+  if (num_additional_rows > 0) {\n"
"+     uint32_t page_num = num_full_pages;\n"
"+     if (pager->pages[page_num] != NULL) {\n"
"+         pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);\n"
"+         free(pager->pages[page_num]);\n"
"+         pager->pages[page_num] = NULL;\n"
"+     }\n"
"+  }\n"
"+\n"
"+  int result = close(pager->file_descriptor);\n"
"+  if (result == -1) {\n"
"+     printf(\"Error closing db file.\n"
"\");\n"
"+     exit(EXIT_FAILURE);\n"
"+  }\n"
"+  for (uint32_t i = 0; i < TABLE_MAX_PAGES; i++) {\n"
"+     void* page = pager->pages[i];\n"
"+     if (page) {\n"
"+         free(page);\n"
"+         pager->pages[i] = NULL;\n"
"+     }\n"
"+  }\n"
"+\n"
"+  free(pager);\n"
"+  free(table);\n"
"+}\n"
"+\n"
" MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table *table) {\n"
"   if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"     close_input_buffer(input_buffer);\n"
"-    free_table(table);\n"
"+    db_close(table);\n"
"     exit(EXIT_SUCCESS);\n"
"   } else {\n"
"     return META_COMMAND_UNRECOGNIZED_COMMAND;\n"
"@@ -182,6 +308,7 @@ PrepareResult prepare_insert(InputBuffer* input_buffer, St"
"atement* statement) {\n"
"     return PREPARE_SUCCESS;"
msgstr ""

msgid ""
"+void* get_page(Pager* pager, uint32_t page_num) {\n"
"+  if (page_num > TABLE_MAX_PAGES) {\n"
"+     printf(\"Tried to fetch page number out of bounds. %d > %d\n"
"\", page_num,\n"
"+     \tTABLE_MAX_PAGES);\n"
"+     exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  if (pager->pages[page_num] == NULL) {\n"
"+     // Cache miss. Allocate memory and load from file.\n"
"+     void* page = malloc(PAGE_SIZE);\n"
"+     uint32_t num_pages = pager->file_length / PAGE_SIZE;\n"
"+\n"
"+     // We might save a partial page at the end of the file\n"
"+     if (pager->file_length % PAGE_SIZE) {\n"
"+         num_pages += 1;\n"
"+     }\n"
"+\n"
"+     if (page_num <= num_pages) {\n"
"+         lseek(pager->file_descriptor, page_num * PAGE_SIZE, SEEK_SET);\n"
"+         ssize_t bytes_read = read(pager->file_descriptor, page, PAGE_SIZE);\n"
"+         if (bytes_read == -1) {\n"
"+     \tprintf(\"Error reading file: %d\n"
"\", errno);\n"
"+     \texit(EXIT_FAILURE);\n"
"+         }\n"
"+     }\n"
"+\n"
"+     pager->pages[page_num] = page;\n"
"+  }\n"
"+\n"
"+  return pager->pages[page_num];\n"
"+}\n"
"+\n"
" void* row_slot(Table* table, uint32_t row_num) {\n"
"   uint32_t page_num = row_num / ROWS_PER_PAGE;\n"
"-  void *page = table->pages[page_num];\n"
"-  if (page == NULL) {\n"
"-     // Allocate memory only when we try to access page\n"
"-     page = table->pages[page_num] = malloc(PAGE_SIZE);\n"
"-  }\n"
"+  void *page = get_page(table->pager, page_num);\n"
"   uint32_t row_offset = row_num % ROWS_PER_PAGE;\n"
"   uint32_t byte_offset = row_offset * ROW_SIZE;\n"
"   return page + byte_offset;\n"
" }"
msgstr ""

msgid ""
"-    execute_statement(&statement);\n"
"-    printf(\"Executed.\n"
"\");\n"
"+    switch (execute_statement(&statement, table)) {\n"
"+      case (EXECUTE_SUCCESS):\n"
"+        printf(\"Executed.\n"
"\");\n"
"+        break;\n"
"+      case (EXECUTE_TABLE_FULL):\n"
"+        printf(\"Error: Table full.\n"
"\");\n"
"+        break;\n"
"+    }\n"
"   }\n"
" }\n"
" ```"
msgstr ""

msgid ""
"-    if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"-      close_input_buffer(input_buffer);\n"
"-      exit(EXIT_SUCCESS);\n"
"-    } else {\n"
"-      printf(\"Unrecognized command '%s'.\n"
"\", input_buffer->buffer);\n"
"+    if (input_buffer->buffer[0] == '.') {\n"
"+      switch (do_meta_command(input_buffer)) {\n"
"+        case (META_COMMAND_SUCCESS):\n"
"+          continue;\n"
"+        case (META_COMMAND_UNRECOGNIZED_COMMAND):\n"
"+          printf(\"Unrecognized command '%s'\n"
"\", input_buffer->buffer);\n"
"+          continue;\n"
"+      }\n"
"     }\n"
"+\n"
"+    Statement statement;\n"
"+    switch (prepare_statement(input_buffer, &statement)) {\n"
"+      case (PREPARE_SUCCESS):\n"
"+        break;\n"
"+      case (PREPARE_UNRECOGNIZED_STATEMENT):\n"
"+        printf(\"Unrecognized keyword at start of '%s'.\n"
"\",\n"
"+               input_buffer->buffer);\n"
"+        continue;\n"
"+    }\n"
"+\n"
"+    execute_statement(&statement);\n"
"+    printf(\"Executed.\n"
"\");\n"
"   }\n"
" }\n"
"```"
msgstr ""

msgid ""
"-    if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"-      close_input_buffer(input_buffer);\n"
"-      exit(EXIT_SUCCESS);\n"
"-    } else {\n"
"-      printf(\"Unrecognized command '%s'.\n"
"\", input_buffer->buffer);\n"
"+    if (input_buffer->buffer[0] == '.') {\n"
"+      switch (do_meta_command(input_buffer, table)) {\n"
"+        case (META_COMMAND_SUCCESS):\n"
"+          continue;\n"
"+        case (META_COMMAND_UNRECOGNIZED_COMMAND):\n"
"+          printf(\"Unrecognized command '%s'\n"
"\", input_buffer->buffer);\n"
"+          continue;\n"
"+      }\n"
"+    }\n"
"+\n"
"+    Statement statement;\n"
"+    switch (prepare_statement(input_buffer, &statement)) {\n"
"+      case (PREPARE_SUCCESS):\n"
"+        break;\n"
"+      case (PREPARE_SYNTAX_ERROR):\n"
"+\tprintf(\"Syntax error. Could not parse statement.\n"
"\");\n"
"+\tcontinue;\n"
"+      case (PREPARE_UNRECOGNIZED_STATEMENT):\n"
"+        printf(\"Unrecognized keyword at start of '%s'.\n"
"\",\n"
"+               input_buffer->buffer);\n"
"+        continue;\n"
"+    }\n"
"+\n"
"+    switch (execute_statement(&statement, table)) {\n"
"+\tcase (EXECUTE_SUCCESS):\n"
"+\t    printf(\"Executed.\n"
"\");\n"
"+\t    break;\n"
"+\tcase (EXECUTE_TABLE_FULL):\n"
"+\t    printf(\"Error: Table full.\n"
"\");\n"
"+\t    break;\n"
"     }\n"
"   }\n"
" }\n"
"```"
msgstr ""

msgid ""
"-    if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"-      exit(EXIT_SUCCESS);\n"
"-    } else {\n"
"-      printf(\"Unrecognized command '%s'.\n"
"\", input_buffer->buffer);\n"
"+    if (input_buffer->buffer[0] == '.') {\n"
"+      switch (do_meta_command(input_buffer)) {\n"
"+        case (META_COMMAND_SUCCESS):\n"
"+          continue;\n"
"+        case (META_COMMAND_UNRECOGNIZED_COMMAND):\n"
"+          printf(\"Unrecognized command '%s'\n"
"\", input_buffer->buffer);\n"
"+          continue;\n"
"+      }\n"
"     }\n"
"+\n"
"+    Statement statement;\n"
"+    switch (prepare_statement(input_buffer, &statement)) {\n"
"+      case (PREPARE_SUCCESS):\n"
"+        break;\n"
"+      case (PREPARE_UNRECOGNIZED_STATEMENT):\n"
"+        printf(\"Unrecognized keyword at start of '%s'.\n"
"\",\n"
"+               input_buffer->buffer);\n"
"+        continue;\n"
"+    }\n"
"+\n"
"+    execute_statement(&statement);\n"
"+    printf(\"Executed.\n"
"\");\n"
"   }\n"
" }\n"
"```"
msgstr ""

msgid ""
"-  /* Binary search to find index of child to search */\n"
"+  /* Binary search */\n"
"   uint32_t min_index = 0;\n"
"   uint32_t max_index = num_keys; /* there is one more child than key */"
msgstr ""

msgid ""
"-  // There may be a partial page to write to the end of the file\n"
"-  // This should not be needed after we switch to a B-tree\n"
"-  uint32_t num_additional_rows = table->num_rows % ROWS_PER_PAGE;\n"
"-  if (num_additional_rows > 0) {\n"
"-    uint32_t page_num = num_full_pages;\n"
"-    if (pager->pages[page_num] != NULL) {\n"
"-      pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);\n"
"-      free(pager->pages[page_num]);\n"
"-      pager->pages[page_num] = NULL;\n"
"-    }\n"
"-  }\n"
"-\n"
"   int result = close(pager->file_descriptor);\n"
"   if (result == -1) {\n"
"     printf(\"Error closing db file.\n"
"\");\n"
"@@ -305,6 +389,14 @@ MetaCommandResult do_meta_command(InputBuffer* input_buff"
"er, Table *table) {\n"
"   if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"     db_close(table);\n"
"     exit(EXIT_SUCCESS);\n"
"+  } else if (strcmp(input_buffer->buffer, \".btree\") == 0) {\n"
"+    printf(\"Tree:\n"
"\");\n"
"+    print_leaf_node(get_page(table->pager, 0));\n"
"+    return META_COMMAND_SUCCESS;\n"
"+  } else if (strcmp(input_buffer->buffer, \".constants\") == 0) {\n"
"+    printf(\"Constants:\n"
"\");\n"
"+    print_constants();\n"
"+    return META_COMMAND_SUCCESS;\n"
"   } else {\n"
"     return META_COMMAND_UNRECOGNIZED_COMMAND;\n"
"   }\n"
"@@ -354,16 +446,39 @@ PrepareResult prepare_statement(InputBuffer* input_buffe"
"r,\n"
"   return PREPARE_UNRECOGNIZED_STATEMENT;\n"
" }"
msgstr ""

msgid ""
"-  // There may be a partial page to write to the end of the file\n"
"-  // This should not be needed after we switch to a B-tree\n"
"-  uint32_t num_additional_rows = table->num_rows % ROWS_PER_PAGE;\n"
"-  if (num_additional_rows > 0) {\n"
"-    uint32_t page_num = num_full_pages;\n"
"-    if (pager->pages[page_num] != NULL) {\n"
"-      pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);\n"
"-      free(pager->pages[page_num]);\n"
"-      pager->pages[page_num] = NULL;\n"
"-    }\n"
"-  }\n"
"-\n"
"   int result = close(pager->file_descriptor);\n"
"   if (result == -1) {\n"
"     printf(\"Error closing db file.\n"
"\");\n"
"```"
msgstr ""

msgid ""
"-  for (uint32_t i = 0; i < num_full_pages; i++) {\n"
"+  for (uint32_t i = 0; i < pager->num_pages; i++) {\n"
"     if (pager->pages[i] == NULL) {\n"
"       continue;\n"
"     }\n"
"-    pager_flush(pager, i, PAGE_SIZE);\n"
"+    pager_flush(pager, i);\n"
"     free(pager->pages[i]);\n"
"     pager->pages[i] = NULL;\n"
"   }"
msgstr ""

msgid ""
"-  serialize_row(row_to_insert, cursor_value(cursor));\n"
"-  table->num_rows += 1;\n"
"+  leaf_node_insert(cursor, row_to_insert->id, row_to_insert);"
msgstr ""

msgid ""
"-  serialize_row(row_to_insert, row_slot(table, table->num_rows));\n"
"+  serialize_row(row_to_insert, cursor_value(cursor));\n"
"   table->num_rows += 1;"
msgstr ""

msgid ""
"-  uint32_t child_num = *internal_node_child(node, min_index);\n"
"+  return min_index;\n"
"+}\n"
"+\n"
"+Cursor* internal_node_find(Table* table, uint32_t page_num, uint32_t key) {\n"
"+  void* node = get_page(table->pager, page_num);\n"
"+\n"
"+  uint32_t child_index = internal_node_find_child(node, key);\n"
"+  uint32_t child_num = *internal_node_child(node, child_index);\n"
"   void* child = get_page(table->pager, child_num);\n"
"   switch (get_node_type(child)) {\n"
"     case NODE_LEAF:\n"
"```"
msgstr ""

msgid ""
"- Create a cursor at the beginning of the table\n"
"- Create a cursor at the end of the table\n"
"- Access the row the cursor is pointing to\n"
"- Advance the cursor to the next row"
msgstr ""

msgid ""
"- Delete the row pointed to by a cursor\n"
"- Modify the row pointed to by a cursor\n"
"- Search a table for a given ID, and create a cursor pointing to the row with "
"that ID"
msgstr ""

msgid ""
"- Searching for a particular value is fast (logarithmic time)\n"
"- Inserting / deleting a value you've already found is fast (constant-ish time"
" to rebalance)\n"
"- Traversing a range of values is fast (unlike a hash map)"
msgstr ""

msgid ""
"- Store rows in blocks of memory called pages\n"
"- Each page stores as many rows as it can fit\n"
"- Rows are serialized into a compact representation with each page\n"
"- Pages are only allocated as needed\n"
"- Keep a fixed-size array of pointers to pages"
msgstr ""

msgid ""
"- flushes the page cache to disk\n"
"- closes the database file\n"
"- frees the memory for the Pager and Table data structures"
msgstr ""

msgid ""
"- opening the database file\n"
"- initializing a pager data structure\n"
"- initializing a table data structure"
msgstr ""

msgid ""
"- support two operations: inserting a row and printing all rows\n"
"- reside only in memory (no persistence to disk)\n"
"- support a single, hard-coded table"
msgstr ""

msgid ""
"- up to 3 children per internal node\n"
"- up to 2 keys per internal node\n"
"- at least 2 children per internal node\n"
"- at least 1 key per internal node"
msgstr ""

msgid ""
"---\n"
"title: Part 1 - Introduction and Setting up the REPL\n"
"date: 2017-08-30\n"
"---"
msgstr ""
"---\n"
"title: パート1 - イントロダクションとREPLのセットアップ\n"
"date: 2017-08-30\n"
"---"

msgid ""
"---\n"
"title: Part 10 - Splitting a Leaf Node\n"
"date: 2017-10-09\n"
"---"
msgstr ""

msgid ""
"---\n"
"title: Part 11 - Recursively Searching the B-Tree\n"
"date: 2017-10-22\n"
"---"
msgstr ""

msgid ""
"---\n"
"title: Part 12 - Scanning a Multi-Level B-Tree\n"
"date: 2017-11-11\n"
"---"
msgstr ""

msgid ""
"---\n"
"title: Part 13 - Updating Parent Node After a Split\n"
"date: 2017-11-26\n"
"---"
msgstr ""

msgid ""
"---\n"
"title: Part 2 - World's Simplest SQL Compiler and Virtual Machine\n"
"date: 2017-08-31\n"
"---"
msgstr ""

msgid ""
"---\n"
"title: Part 3 - An In-Memory, Append-Only, Single-Table Database\n"
"date: 2017-09-01\n"
"---"
msgstr ""

msgid ""
"---\n"
"title: Part 4 - Our First Tests (and Bugs)\n"
"date: 2017-09-03\n"
"---"
msgstr ""

msgid ""
"---\n"
"title: Part 5 - Persistence to Disk\n"
"date: 2017-09-08\n"
"---"
msgstr ""

msgid ""
"---\n"
"title: Part 6 - The Cursor Abstraction\n"
"date: 2017-09-10\n"
"---"
msgstr ""

msgid ""
"---\n"
"title: Part 7 - Introduction to the B-Tree\n"
"date: 2017-09-23\n"
"---"
msgstr ""

msgid ""
"---\n"
"title: Part 8 - B-Tree Leaf Node Format\n"
"date: 2017-09-25\n"
"---"
msgstr ""

msgid ""
"---\n"
"title: Part 9 - Binary Search and Duplicate Keys\n"
"date: 2017-10-01\n"
"---"
msgstr ""

msgid ""
"---\n"
"title: パート1 - イントロダクションとREPLのセットアップ\n"
"date: 2017-08-30\n"
"---"
msgstr ""

msgid ""
"-PrepareResult prepare_statement(InputBuffer* input_buffer,\n"
"-                                Statement* statement) {\n"
"-  if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n"
"+PrepareResult prepare_insert(InputBuffer* input_buffer, Statement* statement)"
" {\n"
"   statement->type = STATEMENT_INSERT;\n"
"-  int args_assigned = sscanf(\n"
"-     input_buffer->buffer, \"insert %d %s %s\", &(statement->row_to_insert.id),"
"\n"
"-     statement->row_to_insert.username, statement->row_to_insert.email\n"
"-     );\n"
"-  if (args_assigned < 3) {\n"
"+\n"
"+  char* keyword = strtok(input_buffer->buffer, \" \");\n"
"+  char* id_string = strtok(NULL, \" \");\n"
"+  char* username = strtok(NULL, \" \");\n"
"+  char* email = strtok(NULL, \" \");\n"
"+\n"
"+  if (id_string == NULL || username == NULL || email == NULL) {\n"
"      return PREPARE_SYNTAX_ERROR;\n"
"   }\n"
"+\n"
"+  int id = atoi(id_string);\n"
"+  if (id < 0) {\n"
"+     return PREPARE_NEGATIVE_ID;\n"
"+  }\n"
"+  if (strlen(username) > COLUMN_USERNAME_SIZE) {\n"
"+     return PREPARE_STRING_TOO_LONG;\n"
"+  }\n"
"+  if (strlen(email) > COLUMN_EMAIL_SIZE) {\n"
"+     return PREPARE_STRING_TOO_LONG;\n"
"+  }\n"
"+\n"
"+  statement->row_to_insert.id = id;\n"
"+  strcpy(statement->row_to_insert.username, username);\n"
"+  strcpy(statement->row_to_insert.email, email);\n"
"+\n"
"   return PREPARE_SUCCESS;\n"
"+\n"
"+}\n"
"+PrepareResult prepare_statement(InputBuffer* input_buffer,\n"
"+                                Statement* statement) {\n"
"+  if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n"
"+      return prepare_insert(input_buffer, statement);\n"
"   }\n"
"   if (strcmp(input_buffer->buffer, \"select\") == 0) {\n"
"     statement->type = STATEMENT_SELECT;\n"
"@@ -223,6 +247,12 @@ int main(int argc, char* argv[]) {\n"
"     switch (prepare_statement(input_buffer, &statement)) {\n"
"       case (PREPARE_SUCCESS):\n"
"         break;\n"
"+      case (PREPARE_NEGATIVE_ID):\n"
"+\tprintf(\"ID must be positive.\n"
"\");\n"
"+\tcontinue;\n"
"+      case (PREPARE_STRING_TOO_LONG):\n"
"+\tprintf(\"String is too long.\n"
"\");\n"
"+\tcontinue;\n"
"       case (PREPARE_SYNTAX_ERROR):\n"
" \tprintf(\"Syntax error. Could not parse statement.\n"
"\");\n"
" \tcontinue;\n"
"```\n"
"And we added tests:\n"
"```diff\n"
"+describe 'database' do\n"
"+  def run_script(commands)\n"
"+    raw_output = nil\n"
"+    IO.popen(\"./db\", \"r+\") do |pipe|\n"
"+      commands.each do |command|\n"
"+        pipe.puts command\n"
"+      end\n"
"+\n"
"+      pipe.close_write\n"
"+\n"
"+      # Read entire output\n"
"+      raw_output = pipe.gets(nil)\n"
"+    end\n"
"+    raw_output.split(\"\n"
"\")\n"
"+  end\n"
"+\n"
"+  it 'inserts and retrieves a row' do\n"
"+    result = run_script([\n"
"+      \"insert 1 user1 person1@example.com\",\n"
"+      \"select\",\n"
"+      \".exit\",\n"
"+    ])\n"
"+    expect(result).to match_array([\n"
"+      \"db > Executed.\",\n"
"+      \"db > (1, user1, person1@example.com)\",\n"
"+      \"Executed.\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
"+\n"
"+  it 'prints error message when table is full' do\n"
"+    script = (1..1401).map do |i|\n"
"+      \"insert #{i} user#{i} person#{i}@example.com\"\n"
"+    end\n"
"+    script << \".exit\"\n"
"+    result = run_script(script)\n"
"+    expect(result[-2]).to eq('db > Error: Table full.')\n"
"+  end\n"
"+\n"
"+  it 'allows inserting strings that are the maximum length' do\n"
"+    long_username = \"a\"*32\n"
"+    long_email = \"a\"*255\n"
"+    script = [\n"
"+      \"insert 1 #{long_username} #{long_email}\",\n"
"+      \"select\",\n"
"+      \".exit\",\n"
"+    ]\n"
"+    result = run_script(script)\n"
"+    expect(result).to match_array([\n"
"+      \"db > Executed.\",\n"
"+      \"db > (1, #{long_username}, #{long_email})\",\n"
"+      \"Executed.\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
"+\n"
"+  it 'prints error message if strings are too long' do\n"
"+    long_username = \"a\"*33\n"
"+    long_email = \"a\"*256\n"
"+    script = [\n"
"+      \"insert 1 #{long_username} #{long_email}\",\n"
"+      \"select\",\n"
"+      \".exit\",\n"
"+    ]\n"
"+    result = run_script(script)\n"
"+    expect(result).to match_array([\n"
"+      \"db > String is too long.\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
"+\n"
"+  it 'prints an error message if id is negative' do\n"
"+    script = [\n"
"+      \"insert -1 cstack foo@bar.com\",\n"
"+      \"select\",\n"
"+      \".exit\",\n"
"+    ]\n"
"+    result = run_script(script)\n"
"+    expect(result).to match_array([\n"
"+      \"db > ID must be positive.\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
"+end\n"
"```"
msgstr ""

msgid ""
"-Table* new_table() {\n"
"-  Table* table = malloc(sizeof(Table));\n"
"-  table->num_rows = 0;\n"
"+Pager* pager_open(const char* filename) {\n"
"+  int fd = open(filename,\n"
"+     \t  O_RDWR | \t// Read/Write mode\n"
"+     \t      O_CREAT,\t// Create file if it does not exist\n"
"+     \t  S_IWUSR |\t// User write permission\n"
"+     \t      S_IRUSR\t// User read permission\n"
"+     \t  );\n"
"+\n"
"+  if (fd == -1) {\n"
"+     printf(\"Unable to open file\n"
"\");\n"
"+     exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  off_t file_length = lseek(fd, 0, SEEK_END);\n"
"+\n"
"+  Pager* pager = malloc(sizeof(Pager));\n"
"+  pager->file_descriptor = fd;\n"
"+  pager->file_length = file_length;\n"
"+\n"
"   for (uint32_t i = 0; i < TABLE_MAX_PAGES; i++) {\n"
"-     table->pages[i] = NULL;\n"
"+     pager->pages[i] = NULL;\n"
"   }\n"
"-  return table;\n"
"+\n"
"+  return pager;\n"
" }"
msgstr ""

msgid ""
"-void free_table(Table* table) {\n"
"-  for (int i = 0; table->pages[i]; i++) {\n"
"-     free(table->pages[i]);\n"
"-  }\n"
"-  free(table);\n"
"+Table* db_open(const char* filename) {\n"
"+  Pager* pager = pager_open(filename);\n"
"+  uint32_t num_rows = pager->file_length / ROW_SIZE;\n"
"+\n"
"+  Table* table = malloc(sizeof(Table));\n"
"+  table->pager = pager;\n"
"+  table->num_rows = num_rows;\n"
"+\n"
"+  return table;\n"
" }"
msgstr ""

msgid ""
"-void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {\n"
"+void pager_flush(Pager* pager, uint32_t page_num) {\n"
"   if (pager->pages[page_num] == NULL) {\n"
"     printf(\"Tried to flush null page\n"
"\");\n"
"     exit(EXIT_FAILURE);\n"
"@@ -242,7 +337,7 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32_t"
" size) {\n"
"@@ -249,7 +346,7 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32_t"
" size) {\n"
"   }"
msgstr ""

msgid ""
"-void* row_slot(Table* table, uint32_t row_num) {\n"
"-  uint32_t page_num = row_num / ROWS_PER_PAGE;\n"
"-  void *page = get_page(table->pager, page_num);\n"
"-  uint32_t row_offset = row_num % ROWS_PER_PAGE;\n"
"-  uint32_t byte_offset = row_offset * ROW_SIZE;\n"
"-  return page + byte_offset;\n"
"+Cursor* table_start(Table* table) {\n"
"+  Cursor* cursor = malloc(sizeof(Cursor));\n"
"+  cursor->table = table;\n"
"+  cursor->row_num = 0;\n"
"+  cursor->end_of_table = (table->num_rows == 0);\n"
"+\n"
"+  return cursor;\n"
"+}\n"
"+\n"
"+Cursor* table_end(Table* table) {\n"
"+  Cursor* cursor = malloc(sizeof(Cursor));\n"
"+  cursor->table = table;\n"
"+  cursor->row_num = table->num_rows;\n"
"+  cursor->end_of_table = true;\n"
"+\n"
"+  return cursor;\n"
"+}\n"
"+\n"
"+void* cursor_value(Cursor* cursor) {\n"
"+  uint32_t row_num = cursor->row_num;\n"
"+  uint32_t page_num = row_num / ROWS_PER_PAGE;\n"
"+  void *page = get_page(cursor->table->pager, page_num);\n"
"+  uint32_t row_offset = row_num % ROWS_PER_PAGE;\n"
"+  uint32_t byte_offset = row_offset * ROW_SIZE;\n"
"+  return page + byte_offset;\n"
"+}\n"
"+\n"
"+void cursor_advance(Cursor* cursor) {\n"
"+  cursor->row_num += 1;\n"
"+  if (cursor->row_num >= cursor->table->num_rows) {\n"
"+    cursor->end_of_table = true;\n"
"+  }\n"
" }"
msgstr ""

msgid ""
"...but one of them looks corrupted\n"
"```\n"
"(1919251317, 14, on14@example.com)\n"
"```"
msgstr ""

msgid ""
"1. Update the first key in the parent to be the maximum key in the left child "
"(\"3\")\n"
"2. Add a new child pointer / key pair after the updated key\n"
"  - The new pointer points to the new child node\n"
"  - The new key is the maximum key in the new child node (\"5\")"
msgstr ""

msgid ""
"> \"Nothing in the world can take the place of persistence.\" -- [Calvin Coolidg"
"e](https://en.wikiquote.org/wiki/Calvin_Coolidge)"
msgstr ""

msgid ""
"> If there is no space on the leaf node, we would split the existing entries r"
"esiding there and the new one (being inserted) into two equal halves: lower an"
"d upper halves. (Keys on the upper half are strictly greater than those on the"
" lower half.) We allocate a new leaf node, and move the upper half into the ne"
"w node."
msgstr ""

msgid ""
"> Let N be the root node. First allocate two nodes, say L and R. Move lower ha"
"lf of N into L and the upper half into R. Now N is empty. Add 〈L, K,R〉 in N, w"
"here K is the max key in L. Page N remains the root. Note that the depth of th"
"e tree has increased by one, but the new tree remains height balanced without "
"violating any B+-tree property."
msgstr ""

msgid ""
"@@ -150,18 +152,40 @@ MetaCommandResult do_meta_command(InputBuffer* input_buf"
"fer, Table *table) {\n"
"   }\n"
" }"
msgstr ""

msgid ""
"@@ -386,7 +394,14 @@ Cursor* internal_node_find(Table* table, uint32_t page_nu"
"m, uint32_t key) {\n"
"     }\n"
"   }"
msgstr ""

msgid ""
"@@ -709,8 +766,12 @@ void leaf_node_split_and_insert(Cursor* cursor, uint32_t "
"key, Row* value) {\n"
"   if (is_node_root(old_node)) {\n"
"     return create_new_root(cursor->table, new_page_num);\n"
"   } else {\n"
"-    printf(\"Need to implement updating parent after split\n"
"\");\n"
"-    exit(EXIT_FAILURE);\n"
"+    uint32_t parent_page_num = *node_parent(old_node);\n"
"+    uint32_t new_max = get_node_max_key(old_node);\n"
"+    void* parent = get_page(cursor->table->pager, parent_page_num);\n"
"+\n"
"+    update_internal_node_key(parent, old_max, new_max);\n"
"+    internal_node_insert(cursor->table, parent_page_num, new_page_num);\n"
"+    return;\n"
"   }\n"
" }\n"
"```"
msgstr ""

msgid ""
"@@ -84,32 +94,81 @@ void deserialize_row(void *source, Row* destination) {\n"
"   memcpy(&(destination->email), source + EMAIL_OFFSET, EMAIL_SIZE);\n"
" }"
msgstr ""

msgid ""
"A B-Tree is different from a binary tree (the \"B\" probably stands for the inve"
"ntor's name, but could also stand for \"balanced\"). Here's an example B-Tree:"
msgstr ""

msgid ""
"A cursor also has a reference to the table it's part of (so our cursor functio"
"ns can take just the cursor as a parameter)."
msgstr ""

msgid ""
"A cursor represents a position in the table. When our table was a simple array"
" of rows, we could access a row given just the row number. Now that it's a tre"
"e, we identify a position by the page number of the node, and the cell number "
"within that node."
msgstr ""

msgid ""
"A query goes through a chain of components in order to retrieve or modify data"
". The **front-end** consists of the:\n"
"- tokenizer\n"
"- parser\n"
"- code generator"
msgstr ""
"クエリは以下のような手順で、取得や変更したデータを解析しています。**フロントエンド** はこれらの要素から構成されています。:\n"
"- 字句解析(tokenizer)\n"
"- パーサー(parser)\n"
"- コード生成"

msgid ""
"Add a method to access the new field:\n"
"```diff\n"
"+uint32_t* leaf_node_next_leaf(void* node) {\n"
"+  return node + LEAF_NODE_NEXT_LEAF_OFFSET;\n"
"+}\n"
"```"
msgstr ""

msgid ""
"Adding a new field changes a few constants:\n"
"```diff\n"
"   it 'prints constants' do\n"
"     script = [\n"
"       \".constants\",\n"
"@@ -199,9 +228,9 @@ describe 'database' do\n"
"       \"db > Constants:\",\n"
"       \"ROW_SIZE: 293\",\n"
"       \"COMMON_NODE_HEADER_SIZE: 6\",\n"
"-      \"LEAF_NODE_HEADER_SIZE: 10\",\n"
"+      \"LEAF_NODE_HEADER_SIZE: 14\",\n"
"       \"LEAF_NODE_CELL_SIZE: 297\",\n"
"-      \"LEAF_NODE_SPACE_FOR_CELLS: 4086\",\n"
"+      \"LEAF_NODE_SPACE_FOR_CELLS: 4082\",\n"
"       \"LEAF_NODE_MAX_CELLS: 13\",\n"
"       \"db > \",\n"
"     ])\n"
"```"
msgstr ""

msgid ""
"Advancing the cursor in our current table structure is as simple as incrementi"
"ng the row number. This will be a bit more complicated in a B-tree."
msgstr ""

msgid ""
"After a bunch of debugging, I discovered this was due to some bad pointer arit"
"hmetic."
msgstr ""

msgid "After fixing that bug, we finally print out the entire table as expected:"
msgstr ""

msgid ""
"After some debugging, I found out it's because of a bug in how we split leaf n"
"odes:"
msgstr ""

msgid ""
"After those changes, we actually print 15 rows...\n"
"```\n"
"db > select\n"
"(1, user1, person1@example.com)\n"
"(2, user2, person2@example.com)\n"
"(3, user3, person3@example.com)\n"
"(4, user4, person4@example.com)\n"
"(5, user5, person5@example.com)\n"
"(6, user6, person6@example.com)\n"
"(7, user7, person7@example.com)\n"
"(8, user8, person8@example.com)\n"
"(9, user9, person9@example.com)\n"
"(10, user10, person10@example.com)\n"
"(11, user11, person11@example.com)\n"
"(12, user12, person12@example.com)\n"
"(13, user13, person13@example.com)\n"
"(1919251317, 14, on14@example.com)\n"
"(15, user15, person15@example.com)\n"
"Executed.\n"
"db >\n"
"```"
msgstr ""

msgid ""
"Alright! We've got persistence. It's not the greatest. For example if you kill"
" the program without typing `.exit`, you lose your changes. Additionally, we'r"
"e writing all pages back to disk, even pages that haven't changed since we rea"
"d them from disk. These are issues we can address later."
msgstr ""

msgid ""
"Alright, that's enough testing for now. Next is a very important feature: pers"
"istence! We're going to save our database to a file and read it back out again"
"."
msgstr ""

msgid ""
"Alright, that's it! Like I said, this was a shorter refactor that should help "
"us as we rewrite our table data structure into a B-Tree. `execute_select()` an"
"d `execute_insert()` can interact with the table entirely through the cursor w"
"ithout assuming anything about how the table is stored."
msgstr ""

msgid ""
"Alright, we've got a working REPL. In the next part, we'll start developing ou"
"r command language. Meanwhile, here's the entire program from this part:"
msgstr "さて、動作できるREPLを完成させました!次のパートでは、オリジナルのコマンドライン言語を開発します。さて、今まで作成したプログラムの全体図を示します。:"

msgid ""
"Alright. One more step toward a fully-operational btree implementation. The ne"
"xt step should be splitting internal nodes. Until then!"
msgstr ""

msgid ""
"Also notice that there's some wasted space at the end. We store as many cells "
"as we can after the header, but the leftover space can't hold an entire cell. "
"We leave it empty to avoid splitting cells between nodes."
msgstr ""

msgid ""
"Also remember that the children of an internal node can be either leaf nodes o"
"r more internal nodes. After we find the correct child, call the appropriate s"
"earch function on it:"
msgstr ""

msgid ""
"An empty B-tree has a single node: the root node. The root node starts as a le"
"af node with zero key/value pairs:"
msgstr ""

msgid "And a test"
msgstr ""

msgid ""
"And add a new implementation that searches for key 0 (the minimum possible key"
"). Even if key 0 does not exist in the table, this method will return the posi"
"tion of the lowest id (the start of the left-most leaf node)."
msgstr ""

msgid "And that reveals that our 1400-row test outputs this error:"
msgstr ""

msgid ""
"And the diff to our tests:\n"
"```diff\n"
" describe 'database' do\n"
"+  before do\n"
"+    `rm -rf test.db`\n"
"+  end\n"
"+\n"
"   def run_script(commands)\n"
"     raw_output = nil\n"
"-    IO.popen(\"./db\", \"r+\") do |pipe|\n"
"+    IO.popen(\"./db test.db\", \"r+\") do |pipe|\n"
"       commands.each do |command|\n"
"         pipe.puts command\n"
"       end\n"
"@@ -28,6 +32,27 @@ describe 'database' do\n"
"     ])\n"
"   end"
msgstr ""

msgid ""
"And the specs:\n"
"```diff\n"
"+  it 'allows printing out the structure of a one-node btree' do\n"
"+    script = [3, 1, 2].map do |i|\n"
"+      \"insert #{i} user#{i} person#{i}@example.com\"\n"
"+    end\n"
"+    script << \".btree\"\n"
"+    script << \".exit\"\n"
"+    result = run_script(script)\n"
"+\n"
"+    expect(result).to match_array([\n"
"+      \"db > Executed.\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > Tree:\",\n"
"+      \"leaf (size 3)\",\n"
"+      \"  - 0 : 3\",\n"
"+      \"  - 1 : 1\",\n"
"+      \"  - 2 : 2\",\n"
"+      \"db > \"\n"
"+    ])\n"
"+  end\n"
"+\n"
"+  it 'prints constants' do\n"
"+    script = [\n"
"+      \".constants\",\n"
"+      \".exit\",\n"
"+    ]\n"
"+    result = run_script(script)\n"
"+\n"
"+    expect(result).to match_array([\n"
"+      \"db > Constants:\",\n"
"+      \"ROW_SIZE: 293\",\n"
"+      \"COMMON_NODE_HEADER_SIZE: 6\",\n"
"+      \"LEAF_NODE_HEADER_SIZE: 10\",\n"
"+      \"LEAF_NODE_CELL_SIZE: 297\",\n"
"+      \"LEAF_NODE_SPACE_FOR_CELLS: 4086\",\n"
"+      \"LEAF_NODE_MAX_CELLS: 13\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
" end\n"
"```"
msgstr ""

msgid ""
"And the test fails!\n"
"```ruby\n"
"Failures:"
msgstr ""

msgid ""
"And update the call to the print function, passing an indentation level of zer"
"o."
msgstr ""

msgid "And we can add a new test for duplicate keys:"
msgstr ""

msgid ""
"As a web developer, I use relational databases every day at my job, but they'r"
"e a black box to me. Some questions I have:\n"
"- What format is data saved in? (in memory and on disk)\n"
"- When does it move from memory to disk?\n"
"- Why can there only be one primary key per table?\n"
"- How does rolling back a transaction work?\n"
"- How are indexes formatted?\n"
"- When and how does a full table scan happen?\n"
"- What format is a prepared statement saved in?"
msgstr ""
"web開発者として、[私](https://github.com/cstack)はデータベースを毎日使います。しかしデータベースの中身がブラックボックスのよ"
"うに感じます。いくつか不思議に思っていることがあります。:\n"
"- データは(メモリと外部記憶装置などにおいて)どのようにして保存されるのでしょうか?\n"
"- いつデータはメモリから外部記憶装置に移されるのでしょうか?\n"
"- なぜテーブルごとのキーは一意なのでしょうか?\n"
"- トランザクションのローリングバックの仕組みはどのようなものなのでしょうか?\n"
"- インデックスのフォーマットの仕組みはどのようなものでしょうか?\n"
"- いつ、どんな感じで、テーブルが満タンになったとき何が起きるのでしょうか?\n"
"- プリペアドステートメントはどのようなフォーマットで保存されるのでしょうか?"

msgid "As-is, it will output this:"
msgstr ""

msgid ""
"At this point, we've already allocated the right child and moved the upper hal"
"f into it. Our function takes the right child as input and allocates a new pag"
"e to store the left child."
msgstr ""

msgid "Based on these constants, here's how the layout of an internal node will look:"
msgstr ""

msgid ""
"Based on these constants, here's what the layout of a leaf node looks like cur"
"rently:"
msgstr ""

msgid "Basically our goal for this article is to go from this:"
msgstr ""

msgid ""
"Because we store the rightmost child pointer separately from the rest of the c"
"hild/key pairs, we have to handle things differently if the new child is going"
" to become the rightmost child."
msgstr ""

msgid ""
"Breaking things into two steps like this has a couple advantages:\n"
"- Reduces the complexity of each part (e.g. virtual machine does not worry abo"
"ut syntax errors)\n"
"- Allows compiling common queries once and caching the bytecode for improved p"
"erformance"
msgstr ""

msgid ""
"But [scanf has some disadvantages](https://stackoverflow.com/questions/2430303"
"/disadvantages-of-scanf). If the string it's reading is larger than the buffer"
" it's reading into, it will cause a buffer overflow and start writing into une"
"xpected places. We want to check the length of each string before we copy it i"
"nto a `Row` structure. And to do that, we need to divide the input by spaces."
msgstr ""

msgid "But when we run that test case right now, what actually happens is:"
msgstr ""

msgid ""
"Calling `strtok` successively on the input buffer breaks it into substrings by"
" inserting a null character whenever it reaches a delimiter (space, in our cas"
"e). It returns a pointer to the start of the substring."
msgstr ""

msgid ""
"Each **B-tree** consists of many nodes. Each node is one page in length. The B"
"-tree can retrieve a page from disk or save it back to disk by issuing command"
"s to the pager."
msgstr ""
"**B木**は多くのノードから成り立っています。それらは一つのページに収められています。B木はページャーにディスクに戻す命令を発行し、ディスクからページを取"
"得したり保存します。"

msgid ""
"Each node will correspond to one page. Internal nodes will point to their chil"
"dren by storing the page number that stores the child. The btree asks the page"
"r for a particular page number and gets back a pointer into the page cache. Pa"
"ges are stored in the database file one after the other in order of page numbe"
"r."
msgstr ""

msgid ""
"Easy part's over. Here's a description of what we need to do from [SQLite Data"
"base System: Design and Implementation](https://play.google.com/store/books/de"
"tails/Sibsankar_Haldar_SQLite_Database_System_Design_and?id=9Z6IQQnX1JEC&hl=en"
")"
msgstr ""

msgid ""
"Every node is going to take up exactly one page, even if it's not full. That m"
"eans our pager no longer needs to support reading/writing partial pages.\n"
"```diff\n"
"-void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {\n"
"+void pager_flush(Pager* pager, uint32_t page_num) {\n"
"   if (pager->pages[page_num] == NULL) {\n"
"     printf(\"Tried to flush null page\n"
"\");\n"
"     exit(EXIT_FAILURE);\n"
"@@ -242,7 +337,7 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32_t"
" size) {\n"
"   }"
msgstr ""

msgid ""
"Exceptions:\n"
"- Leaf nodes have 0 children\n"
"- The root node can have fewer than m children but must have at least 2\n"
"- If the root node is a leaf node (the only node), it still has 0 children"
msgstr ""

msgid ""
"Finally we can change our \"virtual machine\" methods to use the cursor abstract"
"ion. When inserting a row, we open a cursor at the end of table, write to that"
" cursor location, then close the cursor."
msgstr ""

msgid "Finally we initialize the root page as a new internal node with two children."
msgstr ""

msgid ""
"Finally, it has a boolean called `end_of_table`. This is so we can represent a"
" position past the end of the table (which is somewhere we may want to insert "
"a row)."
msgstr ""

msgid ""
"Finally, we parse and execute the command. There is only one recognized comman"
"d right now : `.exit`, which terminates the program. Otherwise we print an err"
"or message and continue the loop."
msgstr ""
"最後に、私たちはパースして、コマンドを実行します。たった一つの今すぐ実行できるコマンドがあります。: `.exit`それはプログラムを終了するというコマンド"
"です。さもなければ、私たちはエラーを出力して、ループを継続します。"

msgid ""
"Finished in 0.00871 seconds (files took 0.09506 seconds to load)\n"
"1 example, 0 failures\n"
"```"
msgstr ""

msgid ""
"Finished in 0.01553 seconds (files took 0.08156 seconds to load)\n"
"2 examples, 0 failures\n"
"```"
msgstr ""

msgid ""
"Finished in 0.0188 seconds (files took 0.08516 seconds to load)\n"
"3 examples, 0 failures\n"
"```"
msgstr ""

msgid ""
"Finished in 0.02284 seconds (files took 0.116 seconds to load)\n"
"4 examples, 0 failures\n"
"```"
msgstr ""

msgid "First things first, let's remove the error handling for a full leaf node:"
msgstr ""

msgid ""
"First we'll define the compact representation of a row:\n"
"```diff\n"
"+#define size_of_attribute(Struct, Attribute) sizeof(((Struct*)0)->Attribute)\n"
"+\n"
"+const uint32_t ID_SIZE = size_of_attribute(Row, id);\n"
"+const uint32_t USERNAME_SIZE = size_of_attribute(Row, username);\n"
"+const uint32_t EMAIL_SIZE = size_of_attribute(Row, email);\n"
"+const uint32_t ID_OFFSET = 0;\n"
"+const uint32_t USERNAME_OFFSET = ID_OFFSET + ID_SIZE;\n"
"+const uint32_t EMAIL_OFFSET = USERNAME_OFFSET + USERNAME_SIZE;\n"
"+const uint32_t ROW_SIZE = ID_SIZE + USERNAME_SIZE + EMAIL_SIZE;\n"
"```"
msgstr ""

msgid "First, replace the code stub with a new function call."
msgstr ""

msgid ""
"Following our new abstraction, we move the logic for fetching a page into its "
"own method:"
msgstr ""

msgid ""
"For an internal node, the maximum key is always its right key. For a leaf node"
", it's the key at the maximum index:"
msgstr ""

msgid ""
"For extra fun, let's take a look at `mydb.db` to see how our data is being sto"
"red. I'll use vim as a hex editor to look at the memory layout of the file:"
msgstr ""

msgid ""
"For now, we'll wait to flush the cache to disk until the user closes the conne"
"ction to the database. When the user exits, we'll call a new method called `db"
"_close()`, which"
msgstr ""

msgid ""
"For now, we're assuming that in a database with N pages, page numbers 0 throug"
"h N-1 are allocated. Therefore we can always allocate page number N for new pa"
"ges. Eventually after we implement deletion, some pages may become empty and t"
"heir page numbers unused. To be more efficient, we could re-allocate those fre"
"e pages."
msgstr ""

msgid ""
"For the next step on our epic b-tree implementation journey, we're going to ha"
"ndle fixing up the parent node after splitting a leaf. I'm going to use the fo"
"llowing example as a reference:"
msgstr ""

msgid ""
"Given our current table data structure, all you need to identify a location in"
" a table is the row number."
msgstr ""

msgid "Here are the getter and setter:"
msgstr ""

msgid "Here are the methods for reading and writing to an internal node:"
msgstr ""

msgid "Here's a test case for the new printing functionality!"
msgstr ""

msgid ""
"Here's how [SQLite Database System](https://play.google.com/store/books/detail"
"s/Sibsankar_Haldar_SQLite_Database_System_Design_and?id=9Z6IQQnX1JEC&hl=en) ex"
"plains the process of creating a new root node:"
msgstr ""

msgid "Here's my plan:"
msgstr ""

msgid "Here's the `.btree` output of the new test on its own:"
msgstr ""

msgid ""
"Here's the complete diff for this part:\n"
"```diff\n"
"@@ -22,6 +22,8 @@"
msgstr ""

msgid ""
"Here's the complete diff to this part:\n"
"```diff\n"
"@@ -78,6 +78,13 @@ struct {\n"
" } Table;"
msgstr ""

msgid "How many rows can the leaf node hold?"
msgstr ""

msgid ""
"I also think it's time we revisit another test. The one that tries inserting 1"
"400 rows. It still errors, but the error message is new. Right now, our tests "
"don't handle it very well when the program crashes. If that happens, let's jus"
"t use the output we've gotten so far:"
msgstr ""

msgid ""
"I'll add another test that prints a four-node tree. Just so we test more cases"
" than sequential ids, this test will add records in a pseudorandom order."
msgstr ""

msgid ""
"I'll define a short helper to send a list of commands to our database program "
"then make assertions about the output:"
msgstr ""

msgid "I'm adding a new meta command to print out a few constants of interest."
msgstr ""

msgid ""
"I'm also adding a test so we get alerted when those constants change:\n"
"```diff\n"
"+  it 'prints constants' do\n"
"+    script = [\n"
"+      \".constants\",\n"
"+      \".exit\",\n"
"+    ]\n"
"+    result = run_script(script)\n"
"+\n"
"+    expect(result).to match_array([\n"
"+      \"db > Constants:\",\n"
"+      \"ROW_SIZE: 293\",\n"
"+      \"COMMON_NODE_HEADER_SIZE: 6\",\n"
"+      \"LEAF_NODE_HEADER_SIZE: 10\",\n"
"+      \"LEAF_NODE_CELL_SIZE: 297\",\n"
"+      \"LEAF_NODE_SPACE_FOR_CELLS: 4086\",\n"
"+      \"LEAF_NODE_MAX_CELLS: 13\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
"```"
msgstr ""

msgid ""
"I'm going to hold off on discussion of deleting keys from the tree until after"
" we've implemented insertion."
msgstr ""

msgid "I'm going to replace the current `print_leaf_node()` function"
msgstr ""

msgid ""
"I'm going to use [rspec](http://rspec.info/) to write my tests because I'm fam"
"iliar with it, and the syntax is fairly readable."
msgstr ""

msgid ""
"I'm going to use [strtok()](http://www.cplusplus.com/reference/cstring/strtok/"
") to do that. I think it's easiest to understand if you see it in action:"
msgstr ""

msgid ""
"I'm making our page size 4 kilobytes because it's the same size as a page used"
" in the virtual memory systems of most computer architectures. This means one "
"page in our database corresponds to one page used by the operating system. The"
" operating system will move pages in and out of memory as whole units instead "
"of breaking them up."
msgstr ""

msgid ""
"I'm renaming `new_table()` to `db_open()` because it now has the effect of ope"
"ning a connection to the database. By opening a connection, I mean:"
msgstr ""

msgid ""
"I'm setting an arbitrary limit of 100 pages that we will allocate. When we swi"
"tch to a tree structure, our database's maximum size will only be limited by t"
"he maximum size of a file. (Although we'll still limit how many pages we keep "
"in memory at once)"
msgstr ""

msgid ""
"I'm stubbing out the branch for internal nodes because we haven't implemented "
"internal nodes yet. We can search the leaf node with binary search."
msgstr ""

msgid ""
"If there's no room in the internal node for another cell, throw an error. We'l"
"l implement that later."
msgstr ""

msgid ""
"If we insert a couple key/value pairs, they are stored in the leaf node in sor"
"ted order."
msgstr ""

msgid ""
"If we stored the table as an array, but kept rows sorted by id, we could use b"
"inary search to find a particular id. However, insertion would be slow because"
" we would have to move a lot of rows to make space."
msgstr ""

msgid ""
"If we try it ourselves, we'll see that there's some weird characters when we t"
"ry to print out the row. (I'm abbreviating the long strings):\n"
"```command-line\n"
"db > insert 1 aaaaa... aaaaa...\n"
"Executed.\n"
"db > select\n"
"(1, aaaaa...aaa\\�, aaaaa...aaa\\�)\n"
"Executed.\n"
"db >\n"
"```"
msgstr ""

msgid ""
"If you've been following along closely you may notice we've missed something b"
"ig. Look what happens if we try to insert one additional row:"
msgstr ""

msgid ""
"In actuality, we can't store a full 4 KB of data per leaf node due to the over"
"head of the header, keys, and wasted space. But we can search through somethin"
"g like 500 GB of data by loading only 4 pages from disk. This is why the B-Tre"
"e is a useful data structure for databases."
msgstr ""

msgid ""
"In addition to these common header fields, leaf nodes need to store how many \""
"cells\" they contain. A cell is a key/value pair."
msgstr ""

msgid ""
"In order to do this we need to upgrade our parser. As a reminder, we're curren"
"tly using [scanf()](https://linux.die.net/man/3/scanf):\n"
"```c\n"
"if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n"
"  statement->type = STATEMENT_INSERT;\n"
"  int args_assigned = sscanf(\n"
"      input_buffer->buffer, \"insert %d %s %s\", &(statement->row_to_insert.id),"
"\n"
"      statement->row_to_insert.username, statement->row_to_insert.email);\n"
"  if (args_assigned < 3) {\n"
"    return PREPARE_SYNTAX_ERROR;\n"
"  }\n"
"  return PREPARE_SUCCESS;\n"
"}\n"
"```"
msgstr ""

msgid ""
"In order to get a reference to the parent, we need to start recording in each "
"node a pointer to its parent node."
msgstr ""

msgid "In other words, how does a database **work**?"
msgstr "手短に言うと、どのようにしてデータベースは**動くのでしょうか?**"

msgid ""
"In our current design, the length of the file encodes how many rows are in the"
" database, so we need to write a partial page at the end of the file. That's w"
"hy `pager_flush()` takes both a page number and a size. It's not the greatest "
"design, but it will go away pretty quickly when we start implementing the B-tr"
"ee."
msgstr ""

msgid ""
"In our example, we would get into the `else` block. First we make room for the"
" new cell by shifting other cells one space to the right. (Although in our exa"
"mple there are 0 cells to shift)"
msgstr ""

msgid ""
"In this article we're only going to implement enough to get a single-node tree"
". Recall from last article that a tree starts out as an empty leaf node:"
msgstr ""

msgid ""
"In this example, we add the key \"3\" to the tree. That causes the left leaf nod"
"e to split. After the split we fix up the tree by doing the following:"
msgstr ""

msgid "Initializing both types of nodes should default to setting `is_root` to false:"
msgstr ""

msgid ""
"InputBuffer* new_input_buffer() {\n"
"  InputBuffer* input_buffer = (InputBuffer*)malloc(sizeof(InputBuffer));\n"
"  input_buffer->buffer = NULL;\n"
"  input_buffer->buffer_length = 0;\n"
"  input_buffer->input_length = 0;"
msgstr ""
"InputBuffer* new_input_buffer() {\n"
"  InputBuffer* input_buffer = (InputBuffer*)malloc(sizeof(InputBuffer));\n"
"  input_buffer->buffer = NULL;\n"
"  input_buffer->buffer_length = 0;\n"
"  input_buffer->input_length = 0;"

msgid ""
"InputBuffer* new_input_buffer() {\n"
"  InputBuffer* input_buffer = malloc(sizeof(InputBuffer));\n"
"  input_buffer->buffer = NULL;\n"
"  input_buffer->buffer_length = 0;\n"
"  input_buffer->input_length = 0;"
msgstr ""
"InputBuffer* new_input_buffer() {\n"
"  InputBuffer* input_buffer = malloc(sizeof(InputBuffer));\n"
"  input_buffer->buffer = NULL;\n"
"  input_buffer->buffer_length = 0;\n"
"  input_buffer->input_length = 0;"

msgid ""
"Inside `internal_node_find_child()` we'll reuse some code we already have for "
"finding a key in an internal node. Refactor `internal_node_find()` to use the "
"new helper method."
msgstr ""

msgid ""
"Instead, we're going with a tree structure. Each node in the tree can contain "
"a variable number of rows, so we have to store some information in each node t"
"o keep track of how many rows it contains. Plus there is the storage overhead "
"of all the internal nodes which don't store any rows. In exchange for a larger"
" database file, we get fast insertion, deletion and lookup."
msgstr ""

msgid ""
"It's a little space inefficient to use an entire byte per boolean value in the"
" header, but this makes it easier to write code to access those values."
msgstr ""

msgid "It's gonna be great."
msgstr ""

msgid "Key/value pairs can be added until the leaf node is full:"
msgstr ""

msgid "Last time we ended with an error inserting our 15th row:"
msgstr ""

msgid ""
"Last time we noted that we're still storing keys in unsorted order. We're goin"
"g to fix that problem, plus detect and reject duplicate keys."
msgstr ""

msgid ""
"Lastly, `execute_statement` contains a few stubs:\n"
"```c\n"
"void execute_statement(Statement* statement) {\n"
"  switch (statement->type) {\n"
"    case (STATEMENT_INSERT):\n"
"      printf(\"This is where we would do an insert.\n"
"\");\n"
"      break;\n"
"    case (STATEMENT_SELECT):\n"
"      printf(\"This is where we would do a select.\n"
"\");\n"
"      break;\n"
"  }\n"
"}\n"
"```"
msgstr ""

msgid ""
"Lastly, we need to accept the filename as a command-line argument. Don't forge"
"t to also add the extra argument to `do_meta_command`:"
msgstr ""

msgid ""
"Lastly, we need to initialize the table, create the respective\n"
"memory release function and handle a few more error cases:"
msgstr ""

msgid "Lastly, we need to make and handle a new error code."
msgstr ""

msgid ""
"Lastly, we pass the prepared statement to `execute_statement`. This function w"
"ill eventually become our virtual machine."
msgstr ""

msgid ""
"Leaf nodes and internal nodes have different layouts. Let's make an enum to ke"
"ep track of node type:"
msgstr ""

msgid "Let's get a handle to the old node and create the new node:"
msgstr ""

msgid ""
"Let's go back and define a few new functions and constants. When we created a "
"new leaf node, we put it in a page decided by `get_unused_page_num()`:"
msgstr ""

msgid ""
"Let's keep adding keys. 18 and 21. We get to the point where we have to split "
"again, but there's no room in the parent node for another key/pointer pair."
msgstr ""

msgid ""
"Let's say that the capacity of a leaf node is two key/value pairs. When we ins"
"ert another, we have to split the leaf node and put half the pairs in each nod"
"e. Both nodes become children of a new internal node which will now be the roo"
"t node."
msgstr ""

msgid ""
"Let's try it out!\n"
"```shell\n"
"~ ./db\n"
"db > .tables\n"
"Unrecognized command '.tables'.\n"
"db > .exit\n"
"~\n"
"```"
msgstr ""
"試してみましょう!\n"
"```shell\n"
"~ ./db\n"
"db > .tables\n"
"'.tables'は認識できません\n"
"db > .exit\n"
"~\n"
"```"

msgid ""
"Let's work through an example to see how a B-tree grows as you insert elements"
" into it. To keep things simple, the tree will be order 3. That means:"
msgstr ""

msgid ""
"Like sqlite, we're going to persist records by saving the entire database to a"
" file."
msgstr ""

msgid ""
"Look carefully and you'll spot a bug:\n"
"```\n"
"    - 5\n"
"    - 6\n"
"    - 7\n"
"  - key 1\n"
"```"
msgstr ""

msgid "Looks like that's next on our to-do list!"
msgstr ""

msgid ""
"NOTE! [Pointer arithmetic on void pointers is not part of the C standard and m"
"ay not work with your compiler](https://stackoverflow.com/questions/3523145/po"
"inter-arithmetic-for-void-pointer-in-c/46238658#46238658). I may do an article"
" in the future on portability, but I'm leaving my void pointer arithmetic for "
"now."
msgstr ""

msgid ""
"Next time we'll continue the epic B-tree saga by implementing search on a mult"
"i-level tree."
msgstr ""

msgid ""
"Next time we'll introduce cursors, which should make it easier to implement th"
"e B-tree."
msgstr ""

msgid "Next time, we start implementing the btree!"
msgstr ""

msgid ""
"Next time, we'll implement finding a record by primary key, and start storing "
"rows in sorted order."
msgstr ""

msgid ""
"Next we'll make a function for inserting a key/value pair into a leaf node. It"
" will take a cursor as input to represent the position where the pair should b"
"e inserted."
msgstr ""

msgid ""
"Next, `print_prompt()` prints a prompt to the user. We do this before reading "
"each line of input."
msgstr "次に、`print_prompt()`はユーザーにプロンプトを表示する関数です。入力を読み取る前にこれを実行します。"

msgid ""
"Next, a `Table` structure that points to pages of rows and keeps track of how "
"many rows there are:\n"
"```diff\n"
"+const uint32_t PAGE_SIZE = 4096;\n"
"+#define TABLE_MAX_PAGES 100\n"
"+const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;\n"
"+const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;\n"
"+\n"
"+typedef struct {\n"
"+  uint32_t num_rows;\n"
"+  void* pages[TABLE_MAX_PAGES];\n"
"+} Table;\n"
"```"
msgstr ""

msgid "Next, copy every cell into its new location:"
msgstr ""

msgid ""
"Next, we add a step that converts the line of input into our internal represen"
"tation of a statement. This is our hacky version of the sqlite front-end."
msgstr ""

msgid ""
"Next, we write the new child pointer and key into the cell determined by `inde"
"x`."
msgstr ""

msgid ""
"Nodes need to store some metadata in a header at the beginning of the page. Ev"
"ery node will store what type of node it is, whether or not it is the root nod"
"e, and a pointer to its parent (to allow finding a node's siblings). I define "
"constants for the size and offset of every header field:"
msgstr ""

msgid ""
"Nodes with children are called \"internal\" nodes. Internal nodes and leaf nodes"
" are structured differently:"
msgstr ""

msgid ""
"Non-SQL statements like `.exit` are called \"meta-commands\". They all start wit"
"h a dot, so we check for them and handle them in a separate function."
msgstr ""

msgid ""
"Note that it doesn't return any error codes because there's nothing that could"
" go wrong yet."
msgstr ""

msgid ""
"Note that we use `strncmp` for \"insert\" since the \"insert\" keyword will be fol"
"lowed by data. (e.g. `insert 1 cstack foo@bar.com`)"
msgstr ""

msgid ""
"Notice our huge branching factor. Because each child pointer / key pair is so "
"small, we can fit 510 keys and 511 child pointers in each internal node. That "
"means we'll never have to traverse many layers of the tree to find a given key"
"!"
msgstr ""

msgid ""
"Notice that two of our new functions return enums indicating success or failur"
"e:"
msgstr ""

msgid ""
"Now inserting a key into a multi-node btree no longer results in an error. And"
" we can update our test:"
msgstr ""

msgid ""
"Now it is proper to define a function that frees the memory allocated for an\n"
"instance of `InputBuffer *` and the `buffer` element of the respective\n"
"structure (`getline` allocates memory for `input_buffer->buffer` in\n"
"`read_input`)."
msgstr ""
"ここで、`InputBuffer *`のインスタンス変数と`buffer`の要素のメモリを\n"
"解放する関数が必要です。\n"
"(`getline`は`read_input`の中の`input_buffer->buffer`へメモリを割り当てます。\n"
")。"

msgid ""
"Now it makes more sense to store the number of pages in our database rather th"
"an the number of rows. The number of pages should be associated with the pager"
" object, not the table, since it's the number of pages used by the database, n"
"ot a particular table. A btree is identified by its root node page number, so "
"the table object needs to keep track of that."
msgstr ""

msgid ""
"Now it's feasible to test inserting a large number of rows into the database:\n"
"```ruby\n"
"it 'prints error message when table is full' do\n"
"  script = (1..1401).map do |i|\n"
"    \"insert #{i} user#{i} person#{i}@example.com\"\n"
"  end\n"
"  script << \".exit\"\n"
"  result = run_script(script)\n"
"  expect(result[-2]).to eq('db > Error: Table full.')\n"
"end\n"
"```"
msgstr ""

msgid ""
"Now let's insert the key \"2\". First we look up which leaf node it would be in "
"if it was present, and we arrive at the left leaf node. The node is full, so w"
"e split the leaf node and create a new entry in the parent node."
msgstr ""

msgid "Now let's look at the rest of the function:"
msgstr ""

msgid ""
"Now that we're finally creating an internal node, we have to define its layout"
". It starts with the common header, then the number of keys it contains, then "
"the page number of its rightmost child. Internal nodes always have one more ch"
"ild pointer than they have keys. That extra child pointer is stored in the hea"
"der."
msgstr ""

msgid ""
"Now we can make `execute_statement` read/write from our table structure:\n"
"```diff\n"
"-void execute_statement(Statement* statement) {\n"
"+ExecuteResult execute_insert(Statement* statement, Table* table) {\n"
"+  if (table->num_rows >= TABLE_MAX_ROWS) {\n"
"+    return EXECUTE_TABLE_FULL;\n"
"+  }\n"
"+\n"
"+  Row* row_to_insert = &(statement->row_to_insert);\n"
"+\n"
"+  serialize_row(row_to_insert, row_slot(table, table->num_rows));\n"
"+  table->num_rows += 1;\n"
"+\n"
"+  return EXECUTE_SUCCESS;\n"
"+}\n"
"+\n"
"+ExecuteResult execute_select(Statement* statement, Table* table) {\n"
"+  Row row;\n"
"+  for (uint32_t i = 0; i < table->num_rows; i++) {\n"
"+    deserialize_row(row_slot(table, i), &row);\n"
"+    print_row(&row);\n"
"+  }\n"
"+  return EXECUTE_SUCCESS;\n"
"+}\n"
"+\n"
"+ExecuteResult execute_statement(Statement* statement, Table* table) {\n"
"   switch (statement->type) {\n"
"     case (STATEMENT_INSERT):\n"
"-      printf(\"This is where we would do an insert.\n"
"\");\n"
"-      break;\n"
"+      return execute_insert(statement, table);\n"
"     case (STATEMENT_SELECT):\n"
"-      printf(\"This is where we would do a select.\n"
"\");\n"
"-      break;\n"
"+      return execute_select(statement, table);\n"
"   }\n"
" }\n"
"```"
msgstr ""

msgid ""
"Now we get to the heart of this article, implementing `internal_node_insert()`"
". I'll explain it in pieces."
msgstr ""

msgid ""
"Now we need to copy that data into some data structure representing the table."
" SQLite uses a B-tree for fast lookups, inserts and deletes. We'll start with "
"something simpler. Like a B-tree, it will group rows into pages, but instead o"
"f arranging those pages as a tree it will arrange them as an array."
msgstr ""

msgid ""
"Now we need to find the affected cell in the parent node. The child doesn't kn"
"ow its own page number, so we can't look for that. But it does know its own ma"
"ximum key, so we can search the parent for that key."
msgstr ""

msgid ""
"Now whenever we want to advance the cursor past the end of a leaf node, we can"
" check if the leaf node has a sibling. If it does, jump to it. Otherwise, we'r"
"e at the end of the table."
msgstr ""

msgid ""
"Now would be a great time to write some tests, for a couple reasons:\n"
"- We're planning to dramatically change the data structure storing our table, "
"and tests would catch regressions.\n"
"- There are a couple edge cases we haven't tested manually (e.g. filling up th"
"e table)"
msgstr ""

msgid ""
"On the least indented level, we see the root node (an internal node). It says "
"`size 1` because it has one key. Indented one level, we see a leaf node, a key"
", and another leaf node. The key in the root node (7) is is the maximum key in"
" the first leaf node. Every key greater than 7 is in the second leaf node."
msgstr ""

msgid ""
"Our \"prepared statement\" right now just contains an enum with two possible val"
"ues. It will contain more data as we allow parameters in statements:"
msgstr ""

msgid ""
"Our B-Tree doesn't feel like much of a tree with only one node. To fix that, w"
"e need some code to split a leaf node in twain. And after that, we need to cre"
"ate an internal node to serve as a parent for the two leaf nodes."
msgstr ""

msgid ""
"Our `row_slot()` function will become `cursor_value()`, which returns a pointe"
"r to the position described by the cursor:"
msgstr ""

msgid ""
"Our database lets you insert records and read them back out, but only as long "
"as you keep the program running. If you kill the program and start it back up,"
" all your records are gone. Here's a spec for the behavior we want:"
msgstr ""

msgid "Our hard-coded table is going to store users and look like this:"
msgstr ""

msgid ""
"Reading through the code we have so far, I realized we might not handle storin"
"g text fields correctly. Easy to test with this example:\n"
"```ruby\n"
"it 'allows inserting strings that are the maximum length' do\n"
"  long_username = \"a\"*32\n"
"  long_email = \"a\"*255\n"
"  script = [\n"
"    \"insert 1 #{long_username} #{long_email}\",\n"
"    \"select\",\n"
"    \".exit\",\n"
"  ]\n"
"  result = run_script(script)\n"
"  expect(result).to match_array([\n"
"    \"db > Executed.\",\n"
"    \"db > (1, #{long_username}, #{long_email})\",\n"
"    \"Executed.\",\n"
"    \"db > \",\n"
"  ])\n"
"end\n"
"```"
msgstr ""

msgid "Remember that each cell in a leaf node consists of first a key then a value:"
msgstr ""

msgid ""
"Right now, our `execute_insert()` function always chooses to insert at the end"
" of the table. Instead, we should search the table for the correct place to in"
"sert, then insert there. If the key already exists there, return an error."
msgstr ""

msgid ""
"Rows should not cross page boundaries. Since pages probably won't exist next t"
"o each other in memory, this assumption makes it easier to read/write rows."
msgstr ""

msgid ""
"Run site locally:\n"
"```\n"
"bundle exec jekyll serve\n"
"```"
msgstr ""

msgid ""
"Running tests again...\n"
"```command-line\n"
"bundle exec rspec\n"
".."
msgstr ""

msgid ""
"SQLクエリがフロントエンドに入力された時、出力はsqliteの仮想マシンの中間コードへ変換されます。(データベースを操作するには、コンパイルされたプログラ"
"ムが必要なのです。)"
msgstr ""

msgid "Set `next_leaf` to 0 by default when initializing a new leaf node:"
msgstr ""

msgid ""
"Since we assume the tree only has one node, our `execute_insert()` function si"
"mply needs to call this helper method:"
msgstr ""

msgid ""
"Since we're now checking node type, we need functions to get and set that valu"
"e in a node."
msgstr ""

msgid ""
"So first things first, replace our stub code with two new function calls: `upd"
"ate_internal_node_key()` for step 1 and `internal_node_insert()` for step 2"
msgstr ""

msgid "So get rid of the old implementation:"
msgstr ""

msgid ""
"So our binary search compares the key to find and the key to the right of the "
"child pointer:"
msgstr ""

msgid "So our table can hold 13 rows right now!"
msgstr ""

msgid ""
"Speaking of tests, our large-dataset test gets past our old stub and gets to o"
"ur new one:"
msgstr ""

msgid ""
"Speaking of which, here is how we figure out where to read/write in memory for"
" a particular row:\n"
"```diff\n"
"+void* row_slot(Table* table, uint32_t row_num) {\n"
"+  uint32_t page_num = row_num / ROWS_PER_PAGE;\n"
"+  void* page = table->pages[page_num];\n"
"+  if (page == NULL) {\n"
"+    // Allocate memory only when we try to access page\n"
"+    page = table->pages[page_num] = malloc(PAGE_SIZE);\n"
"+  }\n"
"+  uint32_t row_offset = row_num % ROWS_PER_PAGE;\n"
"+  uint32_t byte_offset = row_offset * ROW_SIZE;\n"
"+  return page + byte_offset;\n"
"+}\n"
"```"
msgstr ""

msgid ""
"Sqlite starts a read-execute-print loop when you start it from the command lin"
"e:"
msgstr "Sqliteはコマンドラインから起動すると、REPLになります。:"

msgid "Sqliteはコマンドラインから起動すると、REPLになります。:"
msgstr ""

msgid ""
"Sweet, it works! Our db can hold 1400 rows right now because we set the maximu"
"m number of pages to 100, and 14 rows can fit in a page."
msgstr ""

msgid ""
"That means we need to upgrade our `prepare_statement` function to parse argume"
"nts"
msgstr ""

msgid ""
"That's it! Next up: implement splitting leaf nodes and creating internal nodes"
"."
msgstr ""

msgid ""
"That's weird. It's only printing one row, and that row looks corrupted (notice"
" the id doesn't match the username)."
msgstr ""

msgid ""
"The **os interface** is the layer that differs depending on which operating sy"
"stem sqlite was compiled for. In this tutorial, I'm not going to support multi"
"ple platforms."
msgstr "**os interface**はsqliteがコンパイルされたOSによって異なります。このチュートリアルは、様々なプラットフォームをサポートします。"

msgid ""
"The **pager** receives commands to read or write pages of data. It is responsi"
"ble for reading/writing at appropriate offsets in the database file. It also k"
"eeps a cache of recently-accessed pages in memory, and determines when those p"
"ages need to be written back to disk."
msgstr ""
"**ページャー**はデータを読み書きする命令を出します。ページャーはデータベースを適切なオフセットで読み書きします。ページャーはメモリに最近使用したページの"
"キャッシュを保存し、ディスクにページを書き戻す時に使用されます。"

msgid ""
"The **virtual machine** takes bytecode generated by the front-end as instructi"
"ons. It can then perform operations on one or more tables or indexes, each of "
"which is stored in a data structure called a B-tree. The VM is essentially a b"
"ig switch statement on the type of bytecode instruction."
msgstr ""
"**仮想マシン**はフロントエンドの段階で生成されたバイトコードを使用します。B木と呼ばれるデータ構造にそれぞれのデータは保存され、多数のテーブルやインデッ"
"クスを操作します。仮想マシンはバイトコードの実行を切り替えるのに必要です。"

msgid ""
"The B-Tree is the data structure SQLite uses to represent both tables and inde"
"xes, so it's a pretty central idea. This article will just introduce the data "
"structure, so it won't have any code."
msgstr ""

msgid ""
"The Pager accesses the page cache and the file. The Table object makes request"
"s for pages through the pager:"
msgstr ""

msgid ""
"The _back-end_ consists of the:\n"
"- virtual machine\n"
"- B-tree\n"
"- pager\n"
"- os interface"
msgstr ""
"_バックエンド_ はこれらの要素から成り立っています:\n"
"- 仮想マシン\n"
"- B木\n"
"- ページャー\n"
"- OSインターフェース"

msgid ""
"The `get_page()` method has the logic for handling a cache miss. We assume pag"
"es are saved one after the other in the database file: Page 0 at offset 0, pag"
"e 1 at offset 4096, page 2 at offset 8192, etc. If the requested page lies out"
"side the bounds of the file, we know it should be blank, so we just allocate s"
"ome memory and return it. The page will be added to the file when we flush the"
" cache to disk later."
msgstr ""

msgid ""
"The body is an array of cells where each cell contains a child pointer and a k"
"ey. Every key should be the maximum key contained in the child to its left."
msgstr ""

msgid ""
"The body of a leaf node is an array of cells. Each cell is a key followed by a"
" value (a serialized row)."
msgstr ""

msgid ""
"The code to access keys, values and metadata all involve pointer arithmetic us"
"ing the constants we just defined."
msgstr ""

msgid ""
"The depth of the tree only increases when we split the root node. Every leaf n"
"ode has the same depth and close to the same number of key/value pairs, so the"
" tree remains balanced and quick to search."
msgstr ""

msgid ""
"The first four bytes are the id of the first row (4 bytes because we store a `"
"uint32_t`). It's stored in little-endian byte order, so the least significant "
"byte comes first (01), followed by the higher-order bytes (00 00 00). We used "
"`memcpy()` to copy bytes from our `Row` struct into the page cache, so that me"
"ans the struct was laid out in memory in little-endian byte order. That's an a"
"ttribute of the machine I compiled the program for. If we wanted to write a da"
"tabase file on my machine, then read it on a big-endian machine, we'd have to "
"change our `serialize_row()` and `deserialize_row()` methods to always store a"
"nd read bytes in the same order."
msgstr ""

msgid ""
"The index where the new cell (child/key pair) should be inserted depends on th"
"e maximum key in the new child. In the example we looked at, `child_max_key` w"
"ould be 5 and `index` would be 1."
msgstr ""

msgid ""
"The input to the front-end is a SQL query. the output is sqlite virtual machin"
"e bytecode (essentially a compiled program that can operate on the database)."
msgstr ""
"SQLクエリがフロントエンドに入力された時、出力はsqliteの仮想マシンの中間コードへ変換されます。(データベースを操作するには、コンパイルされたプログラ"
"ムが必要なのです。)"

msgid ""
"The internal node has 1 key and 2 pointers to child nodes. If we want to look "
"up a key that is less than or equal to 5, we look in the left child. If we wan"
"t to look up a key greater than 5, we look in the right child."
msgstr ""

msgid "The key there should be 7, not 1!"
msgstr ""

msgid ""
"The new format is a little simplified, so we need to update the existing `.btr"
"ee` test:"
msgstr ""

msgid ""
"The next 256 bytes store the email in the same way. Here we can see some rando"
"m junk after the terminating null character. This is most likely due to uninit"
"ialized memory in our `Row` struct. We copy the entire 256-byte email buffer i"
"nto the file, including any bytes after the end of the string. Whatever was in"
" memory when we allocated that struct is still there. But since we use a termi"
"nating null character, it has no effect on behavior."
msgstr ""

msgid ""
"The next 33 bytes store the username as a null-terminated string. Apparently \""
"cstack\" in ASCII hexadecimal is `63 73 74 61 63 6b`, followed by a null charac"
"ter (`00`). The rest of the 33 bytes are unused."
msgstr ""

msgid "The old root is copied to the left child so we can reuse the root page:"
msgstr ""

msgid ""
"The picture from above is a B-Tree, which SQLite uses to store indexes. To sto"
"re tables, SQLites uses a variation called a B+ tree."
msgstr ""

msgid ""
"The skeleton of our database is taking shape... wouldn't it be nice if it stor"
"ed data? In the next part, we'll implement `insert` and `select`, creating the"
" world's worst data store. In the mean time, here's the entire diff from this "
"part:"
msgstr ""

msgid ""
"The solution is to split the root node into two internal nodes, then create ne"
"w root node to be their parent."
msgstr ""

msgid ""
"The weirdness is because `execute_select()` begins at the start of the table, "
"and our current implementation of `table_start()` returns cell 0 of the root n"
"ode. But the root of our tree is now an internal node which doesn't contain an"
"y rows. The data that was printed must have been left over from when the root "
"node was a leaf. `execute_select()` should really return cell 0 of the leftmos"
"t leaf node."
msgstr ""

msgid ""
"Then we need to update the nodes' parent. If the original node was the root, i"
"t had no parent. In that case, create a new root node to act as the parent. I'"
"ll stub out the other branch for now:"
msgstr ""

msgid ""
"There's lots of [documentation of sqlite internals](https://www.sqlite.org/arc"
"h.html) on their website, plus I've got a copy of [SQLite Database System: Des"
"ign and Implementation](https://play.google.com/store/books/details?id=9Z6IQQn"
"X1JEC)."
msgstr ""
"[sqliteの仕組み](https://www.sqlite.org/arch.html)がsqliteのサイトにあり, そして私は[SQLite Dat"
"abase System: Design and Implementation](https://play.google.com/store/books/d"
"etails?id=9Z6IQQnX1JEC)という電子書籍を持っています。"

msgid ""
"These methods return a pointer to the value in question, so they can be used b"
"oth as a getter and a setter."
msgstr ""

msgid ""
"This all might seem like a step backwards. Our database now stores fewer rows "
"than it did before, and we're still storing rows in unsorted order. But like I"
" said at the beginning, this is a big change and it's important to break it up"
" into manageable steps."
msgstr ""

msgid "This bytecode is passed to the virtual machine, which executes it."
msgstr ""

msgid ""
"This function will perform binary search to find the child that should contain"
" the given key. Remember that the key to the right of each child pointer is th"
"e maximum key contained by that child."
msgstr ""

msgid ""
"This is a simple schema, but it gets us to support multiple data types and mul"
"tiple sizes of text data types."
msgstr ""

msgid "This means the layout of a serialized row will look like this:"
msgstr ""

msgid ""
"This should be a shorter part than the last one. We're just going to refactor "
"a bit to make it easier to start the B-Tree implementation."
msgstr ""

msgid ""
"This simple test makes sure we get back what we put in. And indeed it passes:\n"
"```command-line\n"
"bundle exec rspec\n"
"."
msgstr ""

msgid ""
"This will either return\n"
"- the position of the key,\n"
"- the position of another key that we'll need to move if we want to insert the"
" new key, or\n"
"- the position one past the last key"
msgstr ""

msgid ""
"Those are the behaviors we're going to implement now. Later, we will also want"
" to:"
msgstr ""

msgid ""
"To do that, our main function will have an infinite loop that prints the promp"
"t, gets a line of input, then processes that line of input:"
msgstr "このような処理を行うため、メイン関数は、プロンプトを表示して、入力を読み込み、それを処理する無限ループへ入ります。:"

msgid ""
"To figure things out, I'm writing a database from scratch. It's modeled off sq"
"lite because it is designed to be small with fewer features than MySQL or Post"
"greSQL, so I have a better hope of understanding it. The entire database is st"
"ored in a single file!"
msgstr ""
"これらの謎を解くために、私はデータベースをフルスクラッチで作っています。MySQLやPostgreSQLといったものよりも軽量で、機能も少ないためsqlit"
"eをモデルにしました。なので、データベースをより理解しやすくなったと思っています。実はデータベースは一つのファイルに、保存されているのです!"

msgid ""
"To help us visualize the state of the database, we should update our `.btree` "
"metacommand to print a multi-level tree."
msgstr ""

msgid ""
"To help with debugging and visualization, I'm also adding a meta command to pr"
"int out a representation of the btree."
msgstr ""

msgid ""
"To keep the tree balanced, we evenly distribute cells between the two new node"
"s. If a leaf node can hold N cells, then during a split we need to distribute "
"N+1 cells between two nodes (N original cells plus one new one). I'm arbitrari"
"ly choosing the left node to get one more cell if N+1 is odd."
msgstr ""

msgid ""
"To make this easier, we're going to make an abstraction called the pager. We a"
"sk the pager for page number `x`, and the pager gives us back a block of memor"
"y. It first looks in its cache. On a cache miss, it copies data from disk into"
" memory (by reading the database file)."
msgstr ""

msgid ""
"To read a line of input, use [getline()](http://man7.org/linux/man-pages/man3/"
"getline.3.html):\n"
"```c\n"
"ssize_t getline(char **lineptr, size_t *n, FILE *stream);\n"
"```\n"
"`lineptr` : a pointer to the variable we use to point to the buffer containing"
" the read line. If it set to `NULL` it is mallocatted by `getline` and should "
"thus be freed by the user, even if the command fails."
msgstr ""
"入力されたものを読み込むため、[getline()](https://manpages.debian.org/unstable/manpages-ja-de"
"v/getline.3.ja.html)関数を使います。:\n"
"```c\n"
"ssize_t getline(char **lineptr, size_t *n, FILE *stream);\n"
"```\n"
"`lineptr` : は読み込んだものを保存しているバッファを指し示すポインタ変数です。もし`NULL`が設定されていれば、`getline`によって割り"
"当てられた時、コマンドが失敗したとしても、ユーザーは明示的に解放する必要があります。"

msgid ""
"To reduce the size of testcases needed, I'm hardcoding `INTERNAL_NODE_MAX_CELL"
"S` for now"
msgstr ""

msgid ""
"To scan the entire table, we need to jump to the second leaf node after we rea"
"ch the end of the first. To do that, we're going to save a new field in the le"
"af node header called \"next_leaf\", which will hold the page number of the leaf"
"'s sibling node on the right. The rightmost leaf node will have a `next_leaf` "
"value of 0 to denote no sibling (page 0 is reserved for the root node of the t"
"able anyway)."
msgstr ""

msgid ""
"Uh oh, we're still not storing rows in sorted order. You'll notice that `execu"
"te_insert()` inserts into the leaf node at the position returned by `table_end"
"()`. So rows are stored in the order they were inserted, just like before."
msgstr ""

msgid ""
"Unlike a binary tree, each node in a B-Tree can have more than 2 children. Eac"
"h node can have up to m children, where m is called the tree's \"order\". To kee"
"p the tree mostly balanced, we also say nodes have to have at least m/2 childr"
"en (rounded up)."
msgstr ""

msgid "Until next time."
msgstr ""

msgid "Until then!"
msgstr ""

msgid ""
"Until we get to implementing indexes, I'm going to talk solely about B+ trees,"
" but I'll just refer to it as a B-tree or a btree."
msgstr ""

msgid "Update cell counts in each node's header:"
msgstr ""

msgid "Update the leaf node header format to include the new field:"
msgstr ""

msgid "Very satisfying, I know."
msgstr ""

msgid ""
"We already set ourselves up to do that by serializing rows into page-sized mem"
"ory blocks. To add persistence, we can simply write those blocks of memory to "
"a file, and read them back into memory the next time the program starts up."
msgstr ""

msgid ""
"We also need code to convert to and from the compact representation.\n"
"```diff\n"
"+void serialize_row(Row* source, void* destination) {\n"
"+  memcpy(destination + ID_OFFSET, &(source->id), ID_SIZE);\n"
"+  memcpy(destination + USERNAME_OFFSET, &(source->username), USERNAME_SIZE);\n"
"+  memcpy(destination + EMAIL_OFFSET, &(source->email), EMAIL_SIZE);\n"
"+}\n"
"+\n"
"+void deserialize_row(void* source, Row* destination) {\n"
"+  memcpy(&(destination->id), source + ID_OFFSET, ID_SIZE);\n"
"+  memcpy(&(destination->username), source + USERNAME_OFFSET, USERNAME_SIZE);\n"
"+  memcpy(&(destination->email), source + EMAIL_OFFSET, EMAIL_SIZE);\n"
"+}\n"
"```"
msgstr ""

msgid "We also need to initialize node type."
msgstr ""

msgid ""
"We can call [strlen()](http://www.cplusplus.com/reference/cstring/strlen/) on "
"each text value to see if it's too long."
msgstr ""

msgid ""
"We can handle the error like we do any other error code:\n"
"```diff\n"
" enum PrepareResult_t {\n"
"   PREPARE_SUCCESS,\n"
"+  PREPARE_STRING_TOO_LONG,\n"
"   PREPARE_SYNTAX_ERROR,\n"
"   PREPARE_UNRECOGNIZED_STATEMENT\n"
" };\n"
"```\n"
"```diff\n"
" switch (prepare_statement(input_buffer, &statement)) {\n"
"   case (PREPARE_SUCCESS):\n"
"     break;\n"
"+  case (PREPARE_STRING_TOO_LONG):\n"
"+    printf(\"String is too long.\n"
"\");\n"
"+    continue;\n"
"   case (PREPARE_SYNTAX_ERROR):\n"
"     printf(\"Syntax error. Could not parse statement.\n"
"\");\n"
"     continue;\n"
"```"
msgstr ""

msgid "We don't need the `table_end()` function anymore."
msgstr ""

msgid "We have to cast to `uint8_t` first to ensure it's serialized as a single byte."
msgstr ""

msgid ""
"We haven't implemented splitting yet, so we error if the node is full. Next we"
" shift cells one space to the right to make room for the new cell. Then we wri"
"te the new key/value into the empty space."
msgstr ""

msgid ""
"We now support constructing a multi-level btree, but we've broken `select` sta"
"tements in the process. Here's a test case that inserts 15 rows and then tries"
" to print them."
msgstr ""

msgid ""
"We should not allow inserting usernames or emails that are longer than column "
"size. The spec for that looks like this:\n"
"```ruby\n"
"it 'prints error message if strings are too long' do\n"
"  long_username = \"a\"*33\n"
"  long_email = \"a\"*256\n"
"  script = [\n"
"    \"insert 1 #{long_username} #{long_email}\",\n"
"    \"select\",\n"
"    \".exit\",\n"
"  ]\n"
"  result = run_script(script)\n"
"  expect(result).to match_array([\n"
"    \"db > String is too long.\",\n"
"    \"db > Executed.\",\n"
"    \"db > \",\n"
"  ])\n"
"end\n"
"```"
msgstr ""

msgid "We should set `is_root` to true when creating the first node of the table:"
msgstr ""

msgid ""
"We store those parsed arguments into a new `Row` data structure inside the sta"
"tement object:"
msgstr ""

msgid ""
"We tell `getline` to store the read line in `input_buffer->buffer` and the siz"
"e of the allocated buffer in `input_buffer->buffer_length`. We store the retur"
"n value in `input_buffer->input_length`."
msgstr ""
"`getline`は読み込んだ行を`input_buffer->buffer`保存し、割り当てられたバッファのサイズを`input_buffer->buff"
"er_length`に保存します。戻り値を`input_buffer->input_length`に保存します。"

msgid ""
"We were writing the new row (value) into the start of the cell, where the key "
"should go. That means part of the username was going into the section for id ("
"hence the crazy large id)."
msgstr ""

msgid ""
"We'll address those issues in the next part. For now, here's the complete diff"
" from this part:\n"
"```diff\n"
"@@ -2,6 +2,7 @@\n"
" #include <stdio.h>\n"
" #include <stdlib.h>\n"
" #include <string.h>\n"
"+#include <stdint.h>"
msgstr ""

msgid ""
"We'll define `InputBuffer` as a small wrapper around the state we need to stor"
"e to interact with [getline()](http://man7.org/linux/man-pages/man3/getline.3."
"html). (More on that in a minute)\n"
"```c\n"
"typedef struct {\n"
"  char* buffer;\n"
"  size_t buffer_length;\n"
"  ssize_t input_length;\n"
"} InputBuffer;"
msgstr ""
"`InputBuffer`を[getline()](https://manpages.debian.org/unstable/manpages-ja-dev"
"/getline.3.ja.html)関数で、保存するためのラッパー変数として使用します。(このことについて、後程述べたいと思います。)\n"
"```c\n"
"typedef struct {\n"
"  char* buffer;\n"
"  size_t buffer_length;\n"
"  ssize_t input_length;\n"
"} InputBuffer;"

msgid "We'll replace it with a method that searches the tree for a given key."
msgstr ""

msgid ""
"We're changing the format of our table from an unsorted array of rows to a B-T"
"ree. This is a pretty big change that is going to take multiple articles to im"
"plement. By the end of this article, we'll define the layout of a leaf node an"
"d support inserting key/value pairs into a single-node tree. But first, let's "
"recap the reasons for switching to a tree structure."
msgstr ""

msgid ""
"We're finally using the `is_root` field in the common node header. Recall that"
" we use it to decide how to split a leaf node:"
msgstr ""

msgid ""
"We're going to add a `Cursor` object which represents a location in the table."
" Things you might want to do with cursors:"
msgstr ""

msgid ""
"We're going to start small by putting a lot of limitations on our database. Fo"
"r now, it will:"
msgstr ""

msgid ""
"We're making a clone of sqlite. The \"front-end\" of sqlite is a SQL compiler th"
"at parses a string and outputs an internal representation called bytecode."
msgstr ""

msgid ""
"We've got the ability to insert rows into our database and to print out all ro"
"ws. Let's take a moment to test what we've got so far."
msgstr ""

msgid ""
"What's going on? If you take a look at our definition of a Row, we allocate ex"
"actly 32 bytes for username and exactly 255 bytes for email. But [C strings](h"
"ttp://www.cprogramming.com/tutorial/c/lesson9.html) are supposed to end with a"
" null character, which we didn't allocate space for. The solution is to alloca"
"te one additional byte:\n"
"```diff\n"
" const uint32_t COLUMN_EMAIL_SIZE = 255;\n"
" typedef struct {\n"
"   uint32_t id;\n"
"-  char username[COLUMN_USERNAME_SIZE];\n"
"-  char email[COLUMN_EMAIL_SIZE];\n"
"+  char username[COLUMN_USERNAME_SIZE + 1];\n"
"+  char email[COLUMN_EMAIL_SIZE + 1];\n"
" } Row;\n"
" ```"
msgstr ""

msgid ""
"When selecting all rows in the table, we open a cursor at the start of the tab"
"le, print the row, then advance the cursor to the next row. Repeat until we've"
" reached the end of the table."
msgstr ""

msgid ""
"When we implement this data structure, each node will correspond to one page. "
"The root node will exist in page 0. Child pointers will simply be the page num"
"ber that contains the child node."
msgstr ""

msgid ""
"When we open the database for the first time, the database file will be empty,"
" so we initialize page 0 to be an empty leaf node (the root node):"
msgstr ""

msgid ""
"Whenever we split a leaf node, update the sibling pointers. The old leaf's sib"
"ling becomes the new leaf, and the new leaf's sibling becomes whatever used to"
" be the old leaf's sibling."
msgstr ""

msgid "Whew! One bug after another, but we're making progress."
msgstr ""

msgid ""
"Which makes our test pass\n"
"```command-line\n"
"bundle exec rspec\n"
"...."
msgstr ""

msgid ""
"While we're here, we might as well handle one more error case:\n"
"```ruby\n"
"it 'prints an error message if id is negative' do\n"
"  script = [\n"
"    \"insert -1 cstack foo@bar.com\",\n"
"    \"select\",\n"
"    \".exit\",\n"
"  ]\n"
"  result = run_script(script)\n"
"  expect(result).to match_array([\n"
"    \"db > ID must be positive.\",\n"
"    \"db > Executed.\",\n"
"    \"db > \",\n"
"  ])\n"
"end\n"
"```\n"
"```diff\n"
" enum PrepareResult_t {\n"
"   PREPARE_SUCCESS,\n"
"+  PREPARE_NEGATIVE_ID,\n"
"   PREPARE_STRING_TOO_LONG,\n"
"   PREPARE_SYNTAX_ERROR,\n"
"   PREPARE_UNRECOGNIZED_STATEMENT\n"
"@@ -148,9 +147,6 @@ PrepareResult prepare_insert(InputBuffer* input_buffer, St"
"atement* statement) {\n"
"   }"
msgstr ""

msgid "Whoops! Who wrote that TODO message? :P"
msgstr ""

msgid "Why is a tree a good data structure for a database?"
msgstr ""

msgid ""
"With 15 entries, our btree consists of one internal node and two leaf nodes, w"
"hich looks something like this:"
msgstr ""

msgid ""
"With the current format, each page stores only rows (no metadata) so it is pre"
"tty space efficient. Insertion is also fast because we just append to the end."
" However, finding a particular row can only be done by scanning the entire tab"
"le. And if we want to delete a row, we have to fill in the hole by moving ever"
"y row that comes after it."
msgstr ""

msgid "With these changes, our test can change to check for sorted order:"
msgstr ""

msgid ""
"With these refactors, we now recognize two new keywords!\n"
"```command-line\n"
"~ ./db\n"
"db > insert foo bar\n"
"This is where we would do an insert.\n"
"Executed.\n"
"db > delete foo\n"
"Unrecognized keyword at start of 'delete foo'.\n"
"db > select\n"
"This is where we would do a select.\n"
"Executed.\n"
"db > .tables\n"
"Unrecognized command '.tables'\n"
"db > .exit\n"
"~\n"
"```"
msgstr ""

msgid ""
"With this in mind, let's refactor our `main` function and support two new keyw"
"ords in the process:"
msgstr ""

msgid "With those changes, it still only prints out one node's worth of rows:"
msgstr ""

msgid ""
"With those changes, our database should work as before! Except now it returns "
"a \"Table Full\" error much sooner, since we can't split the root node yet."
msgstr ""

msgid "Without further ado, here's the `Cursor` type:"
msgstr ""

msgid ""
"[A journey of a thousand miles begins with a single step](https://en.wiktionar"
"y.org/wiki/a_journey_of_a_thousand_miles_begins_with_a_single_step), so let's "
"start with something a little more straightforward: the REPL."
msgstr ""
"[千里の道は一歩から!](https://ja.wiktionary.org/wiki/%E5%8D%83%E9%87%8C%E3%81%AE%E9%81%"
"93%E3%82%82%E4%B8%80%E6%AD%A9%E3%81%8B%E3%82%89)、簡単なところから始めましょう!:REPL"

msgid ""
"[View rendered tutorial](https://cstack.github.io/db_tutorial/) (with more det"
"ails on what this is.)"
msgstr ""
"[ビルド済みのチュートリアル(日本語)](https://cstack.github.io/db_tutorial/) (こちらに、このプロジェクトについて"
"の詳細があります。)"

msgid ""
"[sqliteの仕組み](https://www.sqlite.org/arch.html)がsqliteのサイトにあり, そして私は[SQLite Dat"
"abase System: Design and Implementation](https://play.google.com/store/books/d"
"etails?id=9Z6IQQnX1JEC)という電子書籍を持っています。"
msgstr ""

msgid ""
"[ビルド済みのチュートリアル(日本語)](https://cstack.github.io/db_tutorial/) (こちらに、このプロジェクトについて"
"の詳細があります。)"
msgstr ""

msgid ""
"[ビルド済みのチュートリアル(英語版)](https://cstack.github.io/db_tutorial) (このプロジェクトについての詳細がこち"
"らにあります)"
msgstr ""

msgid ""
"[千里の道は一歩から!](https://ja.wiktionary.org/wiki/%E5%8D%83%E9%87%8C%E3%81%AE%E9%81%"
"93%E3%82%82%E4%B8%80%E6%AD%A9%E3%81%8B%E3%82%89)、簡単なところから始めましょう!:REPL"
msgstr ""

msgid ""
"_バックエンド_ はこれらの要素から成り立っています:\n"
"- 仮想マシン\n"
"- B木\n"
"- ページャー\n"
"- OSインターフェース"
msgstr ""

msgid ""
"`INTERNAL_NODE_CHILD_SIZE` is 4. My intention here was to add 4 bytes to the r"
"esult of `internal_node_cell()`, but since `internal_node_cell()` returns a `u"
"int32_t*`, this it was actually adding `4 * sizeof(uint32_t)` bytes. I fixed i"
"t by casting to a `void*` before doing the arithmetic."
msgstr ""

msgid ""
"`InputBuffer`を[getline()](https://manpages.debian.org/unstable/manpages-ja-dev"
"/getline.3.ja.html)関数で、保存するためのラッパー変数として使用します。(このことについて、後程述べたいと思います。)\n"
"```c\n"
"typedef struct {\n"
"  char* buffer;\n"
"  size_t buffer_length;\n"
"  ssize_t input_length;\n"
"} InputBuffer;"
msgstr ""

msgid ""
"```\n"
"- internal (size 3)\n"
"  - leaf (size 7)\n"
"    - 1\n"
"    - 2\n"
"    - 3\n"
"    - 4\n"
"    - 5\n"
"    - 6\n"
"    - 7\n"
"  - key 1\n"
"  - leaf (size 8)\n"
"    - 8\n"
"    - 9\n"
"    - 10\n"
"    - 11\n"
"    - 12\n"
"    - 13\n"
"    - 14\n"
"    - 15\n"
"  - key 15\n"
"  - leaf (size 7)\n"
"    - 16\n"
"    - 17\n"
"    - 18\n"
"    - 19\n"
"    - 20\n"
"    - 21\n"
"    - 22\n"
"  - key 22\n"
"  - leaf (size 8)\n"
"    - 23\n"
"    - 24\n"
"    - 25\n"
"    - 26\n"
"    - 27\n"
"    - 28\n"
"    - 29\n"
"    - 30\n"
"db >\n"
"```"
msgstr ""

msgid ""
"```\n"
"Tree:\n"
"- internal (size 1)\n"
"  - leaf (size 7)\n"
"    - 1\n"
"    - 2\n"
"    - 3\n"
"    - 4\n"
"    - 5\n"
"    - 6\n"
"    - 7\n"
"  - key 7\n"
"  - leaf (size 7)\n"
"    - 8\n"
"    - 9\n"
"    - 10\n"
"    - 11\n"
"    - 12\n"
"    - 13\n"
"    - 14\n"
"```"
msgstr ""

msgid ""
"```\n"
"db > insert 15 user15 person15@example.com\n"
"Need to implement searching an internal node\n"
"```"
msgstr ""

msgid ""
"```\n"
"db > select\n"
"(1, user1, person1@example.com)\n"
"(2, user2, person2@example.com)\n"
"(3, user3, person3@example.com)\n"
"(4, user4, person4@example.com)\n"
"(5, user5, person5@example.com)\n"
"(6, user6, person6@example.com)\n"
"(7, user7, person7@example.com)\n"
"(8, user8, person8@example.com)\n"
"(9, user9, person9@example.com)\n"
"(10, user10, person10@example.com)\n"
"(11, user11, person11@example.com)\n"
"(12, user12, person12@example.com)\n"
"(13, user13, person13@example.com)\n"
"(14, user14, person14@example.com)\n"
"(15, user15, person15@example.com)\n"
"Executed.\n"
"db >\n"
"```"
msgstr ""

msgid ""
"```\n"
"db > select\n"
"(1, user1, person1@example.com)\n"
"(2, user2, person2@example.com)\n"
"(3, user3, person3@example.com)\n"
"(4, user4, person4@example.com)\n"
"(5, user5, person5@example.com)\n"
"(6, user6, person6@example.com)\n"
"(7, user7, person7@example.com)\n"
"Executed.\n"
"db >\n"
"```"
msgstr ""

msgid ""
"```\n"
"db > select\n"
"(2, user1, person1@example.com)\n"
"Executed.\n"
"```"
msgstr ""

msgid ""
"```\n"
"insert 1 cstack foo@bar.com\n"
"```"
msgstr ""

msgid ""
"```\n"
"vim mydb.db\n"
":%!xxd\n"
"```\n"
"{% include image.html url=\"assets/images/file-format.png\" description=\"Current"
" File Format\" %}"
msgstr ""

msgid ""
"```\n"
"~ ./db mydb.db\n"
"db > insert 1 cstack foo@bar.com\n"
"Executed.\n"
"db > insert 2 voltorb volty@example.com\n"
"Executed.\n"
"db > .exit\n"
"~\n"
"~ ./db mydb.db\n"
"db > select\n"
"(1, cstack, foo@bar.com)\n"
"(2, voltorb, volty@example.com)\n"
"Executed.\n"
"db > .exit\n"
"~\n"
"```"
msgstr ""

msgid ""
"```c\n"
"  if (is_node_root(old_node)) {\n"
"    return create_new_root(cursor->table, new_page_num);\n"
"  } else {\n"
"    printf(\"Need to implement updating parent after split\n"
"\");\n"
"    exit(EXIT_FAILURE);\n"
"  }\n"
"}\n"
"```"
msgstr ""

msgid ""
"```c\n"
"#include <stdbool.h>\n"
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <string.h>"
msgstr ""
"```c\n"
"#include <stdbool.h>\n"
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <string.h>"

msgid ""
"```c\n"
"MetaCommandResult do_meta_command(InputBuffer* input_buffer) {\n"
"  if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"    exit(EXIT_SUCCESS);\n"
"  } else {\n"
"    return META_COMMAND_UNRECOGNIZED_COMMAND;\n"
"  }\n"
"}\n"
"```"
msgstr ""

msgid ""
"```c\n"
"if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"  close_input_buffer(input_buffer);\n"
"  exit(EXIT_SUCCESS);\n"
"} else {\n"
"  printf(\"Unrecognized command '%s'.\n"
"\", input_buffer->buffer);\n"
"}\n"
"```"
msgstr ""
"```c\n"
"if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"  close_input_buffer(input_buffer);\n"
"  exit(EXIT_SUCCESS);\n"
"} else {\n"
"  printf(\"'%s'は認識できないコマンドです。\n"
"\", input_buffer->buffer);\n"
"}\n"
"```"

msgid ""
"```c\n"
"int main(int argc, char* argv[]) {\n"
"  InputBuffer* input_buffer = new_input_buffer();\n"
"  while (true) {\n"
"    print_prompt();\n"
"    read_input(input_buffer);"
msgstr ""
"```c\n"
"int main(int argc, char* argv[]) {\n"
"  InputBuffer* input_buffer = new_input_buffer();\n"
"  while (true) {\n"
"    print_prompt();\n"
"    read_input(input_buffer);"

msgid ""
"```c\n"
"typedef enum {\n"
"  META_COMMAND_SUCCESS,\n"
"  META_COMMAND_UNRECOGNIZED_COMMAND\n"
"} MetaCommandResult;"
msgstr ""

msgid ""
"```c\n"
"typedef enum { STATEMENT_INSERT, STATEMENT_SELECT } StatementType;"
msgstr ""

msgid ""
"```c\n"
"void close_input_buffer(InputBuffer* input_buffer) {\n"
"    free(input_buffer->buffer);\n"
"    free(input_buffer);\n"
"}\n"
"```"
msgstr ""
"```c\n"
"void close_input_buffer(InputBuffer* input_buffer) {\n"
"    free(input_buffer->buffer);\n"
"    free(input_buffer);\n"
"}\n"
"```"

msgid ""
"```c\n"
"void print_prompt() { printf(\"db > \"); }\n"
"```"
msgstr ""
"```c\n"
"void print_prompt() { printf(\"db > \"); }\n"
"```"

msgid ""
"```c\n"
"void read_input(InputBuffer* input_buffer) {\n"
"  ssize_t bytes_read =\n"
"      getline(&(input_buffer->buffer), &(input_buffer->buffer_length), stdin);"
msgstr ""
"```c\n"
"void read_input(InputBuffer* input_buffer) {\n"
"  ssize_t bytes_read =\n"
"      getline(&(input_buffer->buffer), &(input_buffer->buffer_length), stdin);"

msgid ""
"```diff\n"
"       \"    - 12\",\n"
"       \"    - 13\",\n"
"       \"    - 14\",\n"
"-      \"db > Need to implement searching an internal node\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > \",\n"
"     ])\n"
"   end\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"       \"db > Executed.\",\n"
"       \"db > Executed.\",\n"
"       \"db > Tree:\",\n"
"-      \"leaf (size 3)\",\n"
"-      \"  - 0 : 1\",\n"
"-      \"  - 1 : 2\",\n"
"-      \"  - 2 : 3\",\n"
"+      \"- leaf (size 3)\",\n"
"+      \"  - 1\",\n"
"+      \"  - 2\",\n"
"+      \"  - 3\",\n"
"       \"db > \"\n"
"     ])\n"
"   end\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"       \"db > Executed.\",\n"
"       \"db > Tree:\",\n"
"       \"leaf (size 3)\",\n"
"-      \"  - 0 : 3\",\n"
"-      \"  - 1 : 1\",\n"
"-      \"  - 2 : 2\",\n"
"+      \"  - 0 : 1\",\n"
"+      \"  - 1 : 2\",\n"
"+      \"  - 2 : 3\",\n"
"       \"db > \"\n"
"     ])\n"
"   end\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"       case (EXECUTE_SUCCESS):\n"
"         printf(\"Executed.\n"
"\");\n"
"         break;\n"
"+      case (EXECUTE_DUPLICATE_KEY):\n"
"+        printf(\"Error: Duplicate key.\n"
"\");\n"
"+        break;\n"
"       case (EXECUTE_TABLE_FULL):\n"
"         printf(\"Error: Table full.\n"
"\");\n"
"         break;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"     // New database file. Initialize page 0 as leaf node.\n"
"     void* root_node = get_page(pager, 0);\n"
"     initialize_leaf_node(root_node);\n"
"+    set_node_root(root_node, true);\n"
"   }"
msgstr ""

msgid ""
"```diff\n"
"     end\n"
"     script << \".exit\"\n"
"     result = run_script(script)\n"
"-    expect(result[-2]).to eq('db > Error: Table full.')\n"
"+    expect(result.last(2)).to match_array([\n"
"+      \"db > Executed.\",\n"
"+      \"db > Need to implement updating parent after split\",\n"
"+    ])\n"
"   end\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"     raw_output = nil\n"
"     IO.popen(\"./db test.db\", \"r+\") do |pipe|\n"
"       commands.each do |command|\n"
"-        pipe.puts command\n"
"+        begin\n"
"+          pipe.puts command\n"
"+        rescue Errno::EPIPE\n"
"+          break\n"
"+        end\n"
"       end"
msgstr ""

msgid ""
"```diff\n"
"   Row* row_to_insert = &(statement->row_to_insert);\n"
"+  Cursor* cursor = table_end(table);"
msgstr ""

msgid ""
"```diff\n"
"   if (get_node_type(root_node) == NODE_LEAF) {\n"
"     return leaf_node_find(table, root_page_num, key);\n"
"   } else {\n"
"-    printf(\"Need to implement searching an internal node\n"
"\");\n"
"-    exit(EXIT_FAILURE);\n"
"+    return internal_node_find(table, root_page_num, key);\n"
"   }\n"
" }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"   if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n"
"     statement->type = STATEMENT_INSERT;\n"
"+    int args_assigned = sscanf(\n"
"+        input_buffer->buffer, \"insert %d %s %s\", &(statement->row_to_insert.i"
"d),\n"
"+        statement->row_to_insert.username, statement->row_to_insert.email);\n"
"+    if (args_assigned < 3) {\n"
"+      return PREPARE_SYNTAX_ERROR;\n"
"+    }\n"
"     return PREPARE_SUCCESS;\n"
"   }\n"
"   if (strcmp(input_buffer->buffer, \"select\") == 0) {\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"   } else if (strcmp(input_buffer->buffer, \".btree\") == 0) {\n"
"     printf(\"Tree:\n"
"\");\n"
"-    print_leaf_node(get_page(table->pager, 0));\n"
"+    print_tree(table->pager, 0, 0);\n"
"     return META_COMMAND_SUCCESS;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
" Cursor* table_end(Table* table) {\n"
"   Cursor* cursor = malloc(sizeof(Cursor));\n"
"   cursor->table = table;\n"
"-  cursor->row_num = table->num_rows;\n"
"+  cursor->page_num = table->root_page_num;\n"
"+\n"
"+  void* root_node = get_page(table->pager, table->root_page_num);\n"
"+  uint32_t num_cells = *leaf_node_num_cells(root_node);\n"
"+  cursor->cell_num = num_cells;\n"
"   cursor->end_of_table = true;"
msgstr ""

msgid ""
"```diff\n"
" Cursor* table_start(Table* table) {\n"
"   Cursor* cursor = malloc(sizeof(Cursor));\n"
"   cursor->table = table;\n"
"-  cursor->row_num = 0;\n"
"-  cursor->end_of_table = (table->num_rows == 0);\n"
"+  cursor->page_num = table->root_page_num;\n"
"+  cursor->cell_num = 0;\n"
"+\n"
"+  void* root_node = get_page(table->pager, table->root_page_num);\n"
"+  uint32_t num_cells = *leaf_node_num_cells(root_node);\n"
"+  cursor->end_of_table = (num_cells == 0);"
msgstr ""

msgid ""
"```diff\n"
" ExecuteResult execute_insert(Statement* statement, Table* table) {\n"
"-  if (table->num_rows >= TABLE_MAX_ROWS) {\n"
"+  void* node = get_page(table->pager, table->root_page_num);\n"
"+  if ((*leaf_node_num_cells(node) >= LEAF_NODE_MAX_CELLS)) {\n"
"     return EXECUTE_TABLE_FULL;\n"
"   }"
msgstr ""

msgid ""
"```diff\n"
" ExecuteResult execute_select(Statement* statement, Table* table) {\n"
"+  Cursor* cursor = table_start(table);\n"
"+\n"
"   Row row;\n"
"-  for (uint32_t i = 0; i < table->num_rows; i++) {\n"
"-    deserialize_row(row_slot(table, i), &row);\n"
"+  while (!(cursor->end_of_table)) {\n"
"+    deserialize_row(cursor_value(cursor), &row);\n"
"     print_row(&row);\n"
"+    cursor_advance(cursor);\n"
"   }\n"
"+\n"
"+  free(cursor);\n"
"+\n"
"   return EXECUTE_SUCCESS;\n"
" }\n"
" ```"
msgstr ""

msgid ""
"```diff\n"
" Table* db_open(const char* filename) {\n"
"   Pager* pager = pager_open(filename);\n"
"-  uint32_t num_rows = pager->file_length / ROW_SIZE;"
msgstr ""

msgid ""
"```diff\n"
" const uint32_t LEAF_NODE_NUM_CELLS_SIZE = sizeof(uint32_t);\n"
" const uint32_t LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;\n"
"-const uint32_t LEAF_NODE_HEADER_SIZE =\n"
"-    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;\n"
"+const uint32_t LEAF_NODE_NEXT_LEAF_SIZE = sizeof(uint32_t);\n"
"+const uint32_t LEAF_NODE_NEXT_LEAF_OFFSET =\n"
"+    LEAF_NODE_NUM_CELLS_OFFSET + LEAF_NODE_NUM_CELLS_SIZE;\n"
"+const uint32_t LEAF_NODE_HEADER_SIZE = COMMON_NODE_HEADER_SIZE +\n"
"+                                       LEAF_NODE_NUM_CELLS_SIZE +\n"
"+                                       LEAF_NODE_NEXT_LEAF_SIZE;"
msgstr ""

msgid ""
"```diff\n"
" const uint32_t PAGE_SIZE = 4096;\n"
" const uint32_t TABLE_MAX_PAGES = 100;\n"
"-const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;\n"
"-const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;"
msgstr ""

msgid ""
"```diff\n"
" int main(int argc, char* argv[]) {\n"
"   InputBuffer* input_buffer = new_input_buffer();\n"
"   while (true) {\n"
"     print_prompt();\n"
"     read_input(input_buffer);"
msgstr ""

msgid ""
"```diff\n"
" int main(int argc, char* argv[]) {\n"
"-  Table* table = new_table();\n"
"+  if (argc < 2) {\n"
"+    printf(\"Must supply a database filename.\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  char* filename = argv[1];\n"
"+  Table* table = db_open(filename);\n"
"+\n"
"   InputBuffer* input_buffer = new_input_buffer();\n"
"   while (true) {\n"
"     print_prompt();\n"
"     read_input(input_buffer);"
msgstr ""

msgid ""
"```diff\n"
" typedef struct {\n"
"   Table* table;\n"
"-  uint32_t row_num;\n"
"+  uint32_t page_num;\n"
"+  uint32_t cell_num;\n"
"   bool end_of_table;  // Indicates a position one past the last element\n"
" } Cursor;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
" uint32_t* internal_node_key(void* node, uint32_t key_num) {\n"
"-  return internal_node_cell(node, key_num) + INTERNAL_NODE_CHILD_SIZE;\n"
"+  return (void*)internal_node_cell(node, key_num) + INTERNAL_NODE_CHILD_SIZE;"
"\n"
" }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
" void cursor_advance(Cursor* cursor) {\n"
"-  cursor->row_num += 1;\n"
"-  if (cursor->row_num >= cursor->table->num_rows) {\n"
"+  uint32_t page_num = cursor->page_num;\n"
"+  void* node = get_page(cursor->table->pager, page_num);\n"
"+\n"
"+  cursor->cell_num += 1;\n"
"+  if (cursor->cell_num >= (*leaf_node_num_cells(node))) {\n"
"     cursor->end_of_table = true;\n"
"   }\n"
" }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
" void db_close(Table* table) {\n"
"   Pager* pager = table->pager;\n"
"-  uint32_t num_full_pages = table->num_rows / ROWS_PER_PAGE;"
msgstr ""

msgid ""
"```diff\n"
" void initialize_leaf_node(void* node) {\n"
"   set_node_type(node, NODE_LEAF);\n"
"+  set_node_root(node, false);\n"
"   *leaf_node_num_cells(node) = 0;\n"
" }"
msgstr ""

msgid ""
"```diff\n"
" void leaf_node_insert(Cursor* cursor, uint32_t key, Row* value) {\n"
"   void* node = get_page(cursor->table->pager, cursor->page_num);"
msgstr ""

msgid ""
"```diff\n"
" void serialize_row(Row* source, void* destination) {\n"
"     memcpy(destination + ID_OFFSET, &(source->id), ID_SIZE);\n"
"-    memcpy(destination + USERNAME_OFFSET, &(source->username), USERNAME_SIZE)"
";\n"
"-    memcpy(destination + EMAIL_OFFSET, &(source->email), EMAIL_SIZE);\n"
"+    strncpy(destination + USERNAME_OFFSET, source->username, USERNAME_SIZE);\n"
"+    strncpy(destination + EMAIL_OFFSET, source->email, EMAIL_SIZE);\n"
" }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
" void* cursor_value(Cursor* cursor) {\n"
"-  uint32_t row_num = cursor->row_num;\n"
"-  uint32_t page_num = row_num / ROWS_PER_PAGE;\n"
"+  uint32_t page_num = cursor->page_num;\n"
"   void* page = get_page(cursor->table->pager, page_num);\n"
"-  uint32_t row_offset = row_num % ROWS_PER_PAGE;\n"
"-  uint32_t byte_offset = row_offset * ROW_SIZE;\n"
"-  return page + byte_offset;\n"
"+  return leaf_node_value(page, cursor->cell_num);\n"
" }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
" void* row_slot(Table* table, uint32_t row_num) {\n"
"   uint32_t page_num = row_num / ROWS_PER_PAGE;\n"
"-  void* page = table->pages[page_num];\n"
"-  if (page == NULL) {\n"
"-    // Allocate memory only when we try to access page\n"
"-    page = table->pages[page_num] = malloc(PAGE_SIZE);\n"
"-  }\n"
"+  void* page = get_page(table->pager, page_num);\n"
"   uint32_t row_offset = row_num % ROWS_PER_PAGE;\n"
"   uint32_t byte_offset = row_offset * ROW_SIZE;\n"
"   return page + byte_offset;\n"
" }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+\n"
"+  uint32_t right_child_page_num = *internal_node_right_child(parent);\n"
"+  void* right_child = get_page(table->pager, right_child_page_num);\n"
"+\n"
"+  if (child_max_key > get_node_max_key(right_child)) {\n"
"+    /* Replace right child */\n"
"+    *internal_node_child(parent, original_num_keys) = right_child_page_num;\n"
"+    *internal_node_key(parent, original_num_keys) =\n"
"+        get_node_max_key(right_child);\n"
"+    *internal_node_right_child(parent) = child_page_num;\n"
"+  } else {\n"
"+    /* Make room for the new cell */\n"
"+    for (uint32_t i = original_num_keys; i > index; i--) {\n"
"+      void* destination = internal_node_cell(parent, i);\n"
"+      void* source = internal_node_cell(parent, i - 1);\n"
"+      memcpy(destination, source, INTERNAL_NODE_CELL_SIZE);\n"
"+    }\n"
"+    *internal_node_child(parent, index) = child_page_num;\n"
"+    *internal_node_key(parent, index) = child_max_key;\n"
"+  }\n"
"+}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+  /*\n"
"+  All existing keys plus new key should be divided\n"
"+  evenly between old (left) and new (right) nodes.\n"
"+  Starting from the right, move each key to correct position.\n"
"+  */\n"
"+  for (int32_t i = LEAF_NODE_MAX_CELLS; i >= 0; i--) {\n"
"+    void* destination_node;\n"
"+    if (i >= LEAF_NODE_LEFT_SPLIT_COUNT) {\n"
"+      destination_node = new_node;\n"
"+    } else {\n"
"+      destination_node = old_node;\n"
"+    }\n"
"+    uint32_t index_within_node = i % LEAF_NODE_LEFT_SPLIT_COUNT;\n"
"+    void* destination = leaf_node_cell(destination_node, index_within_node);\n"
"+\n"
"+    if (i == cursor->cell_num) {\n"
"+      serialize_row(value, destination);\n"
"+    } else if (i > cursor->cell_num) {\n"
"+      memcpy(destination, leaf_node_cell(old_node, i - 1), LEAF_NODE_CELL_SIZ"
"E);\n"
"+    } else {\n"
"+      memcpy(destination, leaf_node_cell(old_node, i), LEAF_NODE_CELL_SIZE);\n"
"+    }\n"
"+  }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+  /* Left child has data copied from old root */\n"
"+  memcpy(left_child, root, PAGE_SIZE);\n"
"+  set_node_root(left_child, false);\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+  /* Root node is a new internal node with one key and two children */\n"
"+  initialize_internal_node(root);\n"
"+  set_node_root(root, true);\n"
"+  *internal_node_num_keys(root) = 1;\n"
"+  *internal_node_child(root, 0) = left_child_page_num;\n"
"+  uint32_t left_child_max_key = get_node_max_key(left_child);\n"
"+  *internal_node_key(root, 0) = left_child_max_key;\n"
"+  *internal_node_right_child(root) = right_child_page_num;\n"
"+}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+  /* Update cell count on both leaf nodes */\n"
"+  *(leaf_node_num_cells(old_node)) = LEAF_NODE_LEFT_SPLIT_COUNT;\n"
"+  *(leaf_node_num_cells(new_node)) = LEAF_NODE_RIGHT_SPLIT_COUNT;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+  if (is_node_root(old_node)) {\n"
"+    return create_new_root(cursor->table, new_page_num);\n"
"+  } else {\n"
"+    printf(\"Need to implement updating parent after split\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+  it 'allows printing out the structure of a 3-leaf-node btree' do\n"
"+    script = (1..14).map do |i|\n"
"+      \"insert #{i} user#{i} person#{i}@example.com\"\n"
"+    end\n"
"+    script << \".btree\"\n"
"+    script << \"insert 15 user15 person15@example.com\"\n"
"+    script << \".exit\"\n"
"+    result = run_script(script)\n"
"+\n"
"+    expect(result[14...(result.length)]).to match_array([\n"
"+      \"db > Tree:\",\n"
"+      \"- internal (size 1)\",\n"
"+      \"  - leaf (size 7)\",\n"
"+      \"    - 1\",\n"
"+      \"    - 2\",\n"
"+      \"    - 3\",\n"
"+      \"    - 4\",\n"
"+      \"    - 5\",\n"
"+      \"    - 6\",\n"
"+      \"    - 7\",\n"
"+      \"  - key 7\",\n"
"+      \"  - leaf (size 7)\",\n"
"+      \"    - 8\",\n"
"+      \"    - 9\",\n"
"+      \"    - 10\",\n"
"+      \"    - 11\",\n"
"+      \"    - 12\",\n"
"+      \"    - 13\",\n"
"+      \"    - 14\",\n"
"+      \"db > Need to implement searching an internal node\",\n"
"+    ])\n"
"+  end\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+  it 'allows printing out the structure of a 4-leaf-node btree' do\n"
"+    script = [\n"
"+      \"insert 18 user18 person18@example.com\",\n"
"+      \"insert 7 user7 person7@example.com\",\n"
"+      \"insert 10 user10 person10@example.com\",\n"
"+      \"insert 29 user29 person29@example.com\",\n"
"+      \"insert 23 user23 person23@example.com\",\n"
"+      \"insert 4 user4 person4@example.com\",\n"
"+      \"insert 14 user14 person14@example.com\",\n"
"+      \"insert 30 user30 person30@example.com\",\n"
"+      \"insert 15 user15 person15@example.com\",\n"
"+      \"insert 26 user26 person26@example.com\",\n"
"+      \"insert 22 user22 person22@example.com\",\n"
"+      \"insert 19 user19 person19@example.com\",\n"
"+      \"insert 2 user2 person2@example.com\",\n"
"+      \"insert 1 user1 person1@example.com\",\n"
"+      \"insert 21 user21 person21@example.com\",\n"
"+      \"insert 11 user11 person11@example.com\",\n"
"+      \"insert 6 user6 person6@example.com\",\n"
"+      \"insert 20 user20 person20@example.com\",\n"
"+      \"insert 5 user5 person5@example.com\",\n"
"+      \"insert 8 user8 person8@example.com\",\n"
"+      \"insert 9 user9 person9@example.com\",\n"
"+      \"insert 3 user3 person3@example.com\",\n"
"+      \"insert 12 user12 person12@example.com\",\n"
"+      \"insert 27 user27 person27@example.com\",\n"
"+      \"insert 17 user17 person17@example.com\",\n"
"+      \"insert 16 user16 person16@example.com\",\n"
"+      \"insert 13 user13 person13@example.com\",\n"
"+      \"insert 24 user24 person24@example.com\",\n"
"+      \"insert 25 user25 person25@example.com\",\n"
"+      \"insert 28 user28 person28@example.com\",\n"
"+      \".btree\",\n"
"+      \".exit\",\n"
"+    ]\n"
"+    result = run_script(script)\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+  it 'allows printing out the structure of a one-node btree' do\n"
"+    script = [3, 1, 2].map do |i|\n"
"+      \"insert #{i} user#{i} person#{i}@example.com\"\n"
"+    end\n"
"+    script << \".btree\"\n"
"+    script << \".exit\"\n"
"+    result = run_script(script)\n"
"+\n"
"+    expect(result).to match_array([\n"
"+      \"db > Executed.\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > Executed.\",\n"
"+      \"db > Tree:\",\n"
"+      \"leaf (size 3)\",\n"
"+      \"  - 0 : 3\",\n"
"+      \"  - 1 : 1\",\n"
"+      \"  - 2 : 2\",\n"
"+      \"db > \"\n"
"+    ])\n"
"+  end\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+  it 'prints all rows in a multi-level tree' do\n"
"+    script = []\n"
"+    (1..15).each do |i|\n"
"+      script << \"insert #{i} user#{i} person#{i}@example.com\"\n"
"+    end\n"
"+    script << \"select\"\n"
"+    script << \".exit\"\n"
"+    result = run_script(script)\n"
"+\n"
"+    expect(result[15...result.length]).to match_array([\n"
"+      \"db > (1, user1, person1@example.com)\",\n"
"+      \"(2, user2, person2@example.com)\",\n"
"+      \"(3, user3, person3@example.com)\",\n"
"+      \"(4, user4, person4@example.com)\",\n"
"+      \"(5, user5, person5@example.com)\",\n"
"+      \"(6, user6, person6@example.com)\",\n"
"+      \"(7, user7, person7@example.com)\",\n"
"+      \"(8, user8, person8@example.com)\",\n"
"+      \"(9, user9, person9@example.com)\",\n"
"+      \"(10, user10, person10@example.com)\",\n"
"+      \"(11, user11, person11@example.com)\",\n"
"+      \"(12, user12, person12@example.com)\",\n"
"+      \"(13, user13, person13@example.com)\",\n"
"+      \"(14, user14, person14@example.com)\",\n"
"+      \"(15, user15, person15@example.com)\",\n"
"+      \"Executed.\", \"db > \",\n"
"+    ])\n"
"+  end\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+  it 'prints an error message if there is a duplicate id' do\n"
"+    script = [\n"
"+      \"insert 1 user1 person1@example.com\",\n"
"+      \"insert 1 user1 person1@example.com\",\n"
"+      \"select\",\n"
"+      \".exit\",\n"
"+    ]\n"
"+    result = run_script(script)\n"
"+    expect(result).to match_array([\n"
"+      \"db > Executed.\",\n"
"+      \"db > Error: Duplicate key.\",\n"
"+      \"db > (1, user1, person1@example.com)\",\n"
"+      \"Executed.\",\n"
"+      \"db > \",\n"
"+    ])\n"
"+  end\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+  uint32_t child_num = *internal_node_child(node, min_index);\n"
"+  void* child = get_page(table->pager, child_num);\n"
"+  switch (get_node_type(child)) {\n"
"+    case NODE_LEAF:\n"
"+      return leaf_node_find(table, child_num, key);\n"
"+    case NODE_INTERNAL:\n"
"+      return internal_node_find(table, child_num, key);\n"
"+  }\n"
"+}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+ Table* new_table() {\n"
"+  Table* table = malloc(sizeof(Table));\n"
"+  table->num_rows = 0;\n"
"+  for (uint32_t i = 0; i < TABLE_MAX_PAGES; i++) {\n"
"+     table->pages[i] = NULL;\n"
"+  }\n"
"+  return table;\n"
"+}\n"
"+\n"
"+void free_table(Table* table) {\n"
"+    for (int i = 0; table->pages[i]; i++) {\n"
"+\tfree(table->pages[i]);\n"
"+    }\n"
"+    free(table);\n"
"+}\n"
"```\n"
"```diff\n"
" int main(int argc, char* argv[]) {\n"
"+  Table* table = new_table();\n"
"   InputBuffer* input_buffer = new_input_buffer();\n"
"   while (true) {\n"
"     print_prompt();\n"
"@@ -105,13 +203,22 @@ int main(int argc, char* argv[]) {\n"
"     switch (prepare_statement(input_buffer, &statement)) {\n"
"       case (PREPARE_SUCCESS):\n"
"         break;\n"
"+      case (PREPARE_SYNTAX_ERROR):\n"
"+        printf(\"Syntax error. Could not parse statement.\n"
"\");\n"
"+        continue;\n"
"       case (PREPARE_UNRECOGNIZED_STATEMENT):\n"
"         printf(\"Unrecognized keyword at start of '%s'.\n"
"\",\n"
"                input_buffer->buffer);\n"
"         continue;\n"
"     }"
msgstr ""

msgid ""
"```diff\n"
"+#define COLUMN_USERNAME_SIZE 32\n"
"+#define COLUMN_EMAIL_SIZE 255\n"
"+typedef struct {\n"
"+  uint32_t id;\n"
"+  char username[COLUMN_USERNAME_SIZE];\n"
"+  char email[COLUMN_EMAIL_SIZE];\n"
"+} Row;\n"
"+\n"
" typedef struct {\n"
"   StatementType type;\n"
"+  Row row_to_insert;  // only used by insert statement\n"
" } Statement;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+/*\n"
"+ * Common Node Header Layout\n"
"+ */\n"
"+const uint32_t NODE_TYPE_SIZE = sizeof(uint8_t);\n"
"+const uint32_t NODE_TYPE_OFFSET = 0;\n"
"+const uint32_t IS_ROOT_SIZE = sizeof(uint8_t);\n"
"+const uint32_t IS_ROOT_OFFSET = NODE_TYPE_SIZE;\n"
"+const uint32_t PARENT_POINTER_SIZE = sizeof(uint32_t);\n"
"+const uint32_t PARENT_POINTER_OFFSET = IS_ROOT_OFFSET + IS_ROOT_SIZE;\n"
"+const uint8_t COMMON_NODE_HEADER_SIZE =\n"
"+    NODE_TYPE_SIZE + IS_ROOT_SIZE + PARENT_POINTER_SIZE;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+/*\n"
"+ * Internal Node Body Layout\n"
"+ */\n"
"+const uint32_t INTERNAL_NODE_KEY_SIZE = sizeof(uint32_t);\n"
"+const uint32_t INTERNAL_NODE_CHILD_SIZE = sizeof(uint32_t);\n"
"+const uint32_t INTERNAL_NODE_CELL_SIZE =\n"
"+    INTERNAL_NODE_CHILD_SIZE + INTERNAL_NODE_KEY_SIZE;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+/*\n"
"+ * Internal Node Header Layout\n"
"+ */\n"
"+const uint32_t INTERNAL_NODE_NUM_KEYS_SIZE = sizeof(uint32_t);\n"
"+const uint32_t INTERNAL_NODE_NUM_KEYS_OFFSET = COMMON_NODE_HEADER_SIZE;\n"
"+const uint32_t INTERNAL_NODE_RIGHT_CHILD_SIZE = sizeof(uint32_t);\n"
"+const uint32_t INTERNAL_NODE_RIGHT_CHILD_OFFSET =\n"
"+    INTERNAL_NODE_NUM_KEYS_OFFSET + INTERNAL_NODE_NUM_KEYS_SIZE;\n"
"+const uint32_t INTERNAL_NODE_HEADER_SIZE = COMMON_NODE_HEADER_SIZE +\n"
"+                                           INTERNAL_NODE_NUM_KEYS_SIZE +\n"
"+                                           INTERNAL_NODE_RIGHT_CHILD_SIZE;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+/*\n"
"+ * Leaf Node Body Layout\n"
"+ */\n"
"+const uint32_t LEAF_NODE_KEY_SIZE = sizeof(uint32_t);\n"
"+const uint32_t LEAF_NODE_KEY_OFFSET = 0;\n"
"+const uint32_t LEAF_NODE_VALUE_SIZE = ROW_SIZE;\n"
"+const uint32_t LEAF_NODE_VALUE_OFFSET =\n"
"+    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;\n"
"+const uint32_t LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZ"
"E;\n"
"+const uint32_t LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;"
"\n"
"+const uint32_t LEAF_NODE_MAX_CELLS =\n"
"+    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+/*\n"
"+ * Leaf Node Header Layout\n"
"+ */\n"
"+const uint32_t LEAF_NODE_NUM_CELLS_SIZE = sizeof(uint32_t);\n"
"+const uint32_t LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;\n"
"+const uint32_t LEAF_NODE_HEADER_SIZE =\n"
"+    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+/*\n"
"+Return the position of the given key.\n"
"+If the key is not present, return the position\n"
"+where it should be inserted\n"
"+*/\n"
"+Cursor* table_find(Table* table, uint32_t key) {\n"
"+  uint32_t root_page_num = table->root_page_num;\n"
"+  void* root_node = get_page(table->pager, root_page_num);\n"
"+\n"
"+  if (get_node_type(root_node) == NODE_LEAF) {\n"
"+    return leaf_node_find(table, root_page_num, key);\n"
"+  } else {\n"
"+    printf(\"Need to implement searching an internal node\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+/*\n"
"+Until we start recycling free pages, new pages will always\n"
"+go onto the end of the database file\n"
"+*/\n"
"+uint32_t get_unused_page_num(Pager* pager) { return pager->num_pages; }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+Cursor* internal_node_find(Table* table, uint32_t page_num, uint32_t key) {\n"
"+  void* node = get_page(table->pager, page_num);\n"
"+  uint32_t num_keys = *internal_node_num_keys(node);\n"
"+\n"
"+  /* Binary search to find index of child to search */\n"
"+  uint32_t min_index = 0;\n"
"+  uint32_t max_index = num_keys; /* there is one more child than key */\n"
"+\n"
"+  while (min_index != max_index) {\n"
"+    uint32_t index = (min_index + max_index) / 2;\n"
"+    uint32_t key_to_right = *internal_node_key(node, index);\n"
"+    if (key_to_right >= key) {\n"
"+      max_index = index;\n"
"+    } else {\n"
"+      min_index = index + 1;\n"
"+    }\n"
"+  }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+Cursor* leaf_node_find(Table* table, uint32_t page_num, uint32_t key) {\n"
"+  void* node = get_page(table->pager, page_num);\n"
"+  uint32_t num_cells = *leaf_node_num_cells(node);\n"
"+\n"
"+  Cursor* cursor = malloc(sizeof(Cursor));\n"
"+  cursor->table = table;\n"
"+  cursor->page_num = page_num;\n"
"+\n"
"+  // Binary search\n"
"+  uint32_t min_index = 0;\n"
"+  uint32_t one_past_max_index = num_cells;\n"
"+  while (one_past_max_index != min_index) {\n"
"+    uint32_t index = (min_index + one_past_max_index) / 2;\n"
"+    uint32_t key_at_index = *leaf_node_key(node, index);\n"
"+    if (key == key_at_index) {\n"
"+      cursor->cell_num = index;\n"
"+      return cursor;\n"
"+    }\n"
"+    if (key < key_at_index) {\n"
"+      one_past_max_index = index;\n"
"+    } else {\n"
"+      min_index = index + 1;\n"
"+    }\n"
"+  }\n"
"+\n"
"+  cursor->cell_num = min_index;\n"
"+  return cursor;\n"
"+}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+Cursor* table_start(Table* table) {\n"
"+  Cursor* cursor =  table_find(table, 0);\n"
"+\n"
"+  void* node = get_page(table->pager, cursor->page_num);\n"
"+  uint32_t num_cells = *leaf_node_num_cells(node);\n"
"+  cursor->end_of_table = (num_cells == 0);\n"
"+\n"
"+  return cursor;\n"
"+}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+Cursor* table_start(Table* table) {\n"
"+  Cursor* cursor = malloc(sizeof(Cursor));\n"
"+  cursor->table = table;\n"
"+  cursor->row_num = 0;\n"
"+  cursor->end_of_table = (table->num_rows == 0);\n"
"+\n"
"+  return cursor;\n"
"+}\n"
"+\n"
"+Cursor* table_end(Table* table) {\n"
"+  Cursor* cursor = malloc(sizeof(Cursor));\n"
"+  cursor->table = table;\n"
"+  cursor->row_num = table->num_rows;\n"
"+  cursor->end_of_table = true;\n"
"+\n"
"+  return cursor;\n"
"+}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+NodeType get_node_type(void* node) {\n"
"+  uint8_t value = *((uint8_t*)(node + NODE_TYPE_OFFSET));\n"
"+  return (NodeType)value;\n"
"+}\n"
"+\n"
"+void set_node_type(void* node, NodeType type) {\n"
"+  uint8_t value = type;\n"
"+  *((uint8_t*)(node + NODE_TYPE_OFFSET)) = value;\n"
"+}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+Pager* pager_open(const char* filename) {\n"
"+  int fd = open(filename,\n"
"+                O_RDWR |      // Read/Write mode\n"
"+                    O_CREAT,  // Create file if it does not exist\n"
"+                S_IWUSR |     // User write permission\n"
"+                    S_IRUSR   // User read permission\n"
"+                );\n"
"+\n"
"+  if (fd == -1) {\n"
"+    printf(\"Unable to open file\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  off_t file_length = lseek(fd, 0, SEEK_END);\n"
"+\n"
"+  Pager* pager = malloc(sizeof(Pager));\n"
"+  pager->file_descriptor = fd;\n"
"+  pager->file_length = file_length;\n"
"+\n"
"+  for (uint32_t i = 0; i < TABLE_MAX_PAGES; i++) {\n"
"+    pager->pages[i] = NULL;\n"
"+  }\n"
"+\n"
"+  return pager;\n"
"+}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+PrepareResult prepare_insert(InputBuffer* input_buffer, Statement* statement)"
" {\n"
"+  statement->type = STATEMENT_INSERT;\n"
"+\n"
"+  char* keyword = strtok(input_buffer->buffer, \" \");\n"
"+  char* id_string = strtok(NULL, \" \");\n"
"+  char* username = strtok(NULL, \" \");\n"
"+  char* email = strtok(NULL, \" \");\n"
"+\n"
"+  if (id_string == NULL || username == NULL || email == NULL) {\n"
"+    return PREPARE_SYNTAX_ERROR;\n"
"+  }\n"
"+\n"
"+  int id = atoi(id_string);\n"
"+  if (strlen(username) > COLUMN_USERNAME_SIZE) {\n"
"+    return PREPARE_STRING_TOO_LONG;\n"
"+  }\n"
"+  if (strlen(email) > COLUMN_EMAIL_SIZE) {\n"
"+    return PREPARE_STRING_TOO_LONG;\n"
"+  }\n"
"+\n"
"+  statement->row_to_insert.id = id;\n"
"+  strcpy(statement->row_to_insert.username, username);\n"
"+  strcpy(statement->row_to_insert.email, email);\n"
"+\n"
"+  return PREPARE_SUCCESS;\n"
"+}\n"
"+\n"
" PrepareResult prepare_statement(InputBuffer* input_buffer,\n"
"                                 Statement* statement) {\n"
"   if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n"
"+    return prepare_insert(input_buffer, statement);\n"
"-    statement->type = STATEMENT_INSERT;\n"
"-    int args_assigned = sscanf(\n"
"-        input_buffer->buffer, \"insert %d %s %s\", &(statement->row_to_insert.i"
"d),\n"
"-        statement->row_to_insert.username, statement->row_to_insert.email);\n"
"-    if (args_assigned < 3) {\n"
"-      return PREPARE_SYNTAX_ERROR;\n"
"-    }\n"
"-    return PREPARE_SUCCESS;\n"
"   }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+bool is_node_root(void* node) {\n"
"+  uint8_t value = *((uint8_t*)(node + IS_ROOT_OFFSET));\n"
"+  return (bool)value;\n"
"+}\n"
"+\n"
"+void set_node_root(void* node, bool is_root) {\n"
"+  uint8_t value = is_root;\n"
"+  *((uint8_t*)(node + IS_ROOT_OFFSET)) = value;\n"
"+}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+const uint32_t LEAF_NODE_RIGHT_SPLIT_COUNT = (LEAF_NODE_MAX_CELLS + 1) / 2;\n"
"+const uint32_t LEAF_NODE_LEFT_SPLIT_COUNT =\n"
"+    (LEAF_NODE_MAX_CELLS + 1) - LEAF_NODE_RIGHT_SPLIT_COUNT;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+typedef enum { NODE_INTERNAL, NODE_LEAF } NodeType;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+typedef struct {\n"
"+  Table* table;\n"
"+  uint32_t row_num;\n"
"+  bool end_of_table;  // Indicates a position one past the last element\n"
"+} Cursor;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+typedef struct {\n"
"+  int file_descriptor;\n"
"+  uint32_t file_length;\n"
"+  void* pages[TABLE_MAX_PAGES];\n"
"+} Pager;\n"
"+\n"
" typedef struct {\n"
"-  void* pages[TABLE_MAX_PAGES];\n"
"+  Pager* pager;\n"
"   uint32_t num_rows;\n"
" } Table;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+uint32_t get_node_max_key(void* node) {\n"
"+  switch (get_node_type(node)) {\n"
"+    case NODE_INTERNAL:\n"
"+      return *internal_node_key(node, *internal_node_num_keys(node) - 1);\n"
"+    case NODE_LEAF:\n"
"+      return *leaf_node_key(node, *leaf_node_num_cells(node) - 1);\n"
"+  }\n"
"+}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+uint32_t* internal_node_num_keys(void* node) {\n"
"+  return node + INTERNAL_NODE_NUM_KEYS_OFFSET;\n"
"+}\n"
"+\n"
"+uint32_t* internal_node_right_child(void* node) {\n"
"+  return node + INTERNAL_NODE_RIGHT_CHILD_OFFSET;\n"
"+}\n"
"+\n"
"+uint32_t* internal_node_cell(void* node, uint32_t cell_num) {\n"
"+  return node + INTERNAL_NODE_HEADER_SIZE + cell_num * INTERNAL_NODE_CELL_SIZ"
"E;\n"
"+}\n"
"+\n"
"+uint32_t* internal_node_child(void* node, uint32_t child_num) {\n"
"+  uint32_t num_keys = *internal_node_num_keys(node);\n"
"+  if (child_num > num_keys) {\n"
"+    printf(\"Tried to access child_num %d > num_keys %d\n"
"\", child_num, num_keys);\n"
"+    exit(EXIT_FAILURE);\n"
"+  } else if (child_num == num_keys) {\n"
"+    return internal_node_right_child(node);\n"
"+  } else {\n"
"+    return internal_node_cell(node, child_num);\n"
"+  }\n"
"+}\n"
"+\n"
"+uint32_t* internal_node_key(void* node, uint32_t key_num) {\n"
"+  return internal_node_cell(node, key_num) + INTERNAL_NODE_CHILD_SIZE;\n"
"+}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+uint32_t* leaf_node_num_cells(void* node) {\n"
"+  return node + LEAF_NODE_NUM_CELLS_OFFSET;\n"
"+}\n"
"+\n"
"+void* leaf_node_cell(void* node, uint32_t cell_num) {\n"
"+  return node + LEAF_NODE_HEADER_SIZE + cell_num * LEAF_NODE_CELL_SIZE;\n"
"+}\n"
"+\n"
"+uint32_t* leaf_node_key(void* node, uint32_t cell_num) {\n"
"+  return leaf_node_cell(node, cell_num);\n"
"+}\n"
"+\n"
"+void* leaf_node_value(void* node, uint32_t cell_num) {\n"
"+  return leaf_node_cell(node, cell_num) + LEAF_NODE_KEY_SIZE;\n"
"+}\n"
"+\n"
"+void initialize_leaf_node(void* node) { *leaf_node_num_cells(node) = 0; }\n"
"+\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+uint32_t* node_parent(void* node) { return node + PARENT_POINTER_OFFSET; }\n"
"```\n"
"```diff\n"
"@@ -660,6 +675,48 @@ void create_new_root(Table* table, uint32_t right_child_p"
"age_num) {\n"
"   uint32_t left_child_max_key = get_node_max_key(left_child);\n"
"   *internal_node_key(root, 0) = left_child_max_key;\n"
"   *internal_node_right_child(root) = right_child_page_num;\n"
"+  *node_parent(left_child) = table->root_page_num;\n"
"+  *node_parent(right_child) = table->root_page_num;\n"
" }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+void create_new_root(Table* table, uint32_t right_child_page_num) {\n"
"+  /*\n"
"+  Handle splitting the root.\n"
"+  Old root copied to new page, becomes left child.\n"
"+  Address of right child passed in.\n"
"+  Re-initialize root page to contain the new root node.\n"
"+  New root node points to two children.\n"
"+  */\n"
"+\n"
"+  void* root = get_page(table->pager, table->root_page_num);\n"
"+  void* right_child = get_page(table->pager, right_child_page_num);\n"
"+  uint32_t left_child_page_num = get_unused_page_num(table->pager);\n"
"+  void* left_child = get_page(table->pager, left_child_page_num);\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+void cursor_advance(Cursor* cursor) {\n"
"+  cursor->row_num += 1;\n"
"+  if (cursor->row_num >= cursor->table->num_rows) {\n"
"+    cursor->end_of_table = true;\n"
"+  }\n"
"+}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+void db_close(Table* table) {\n"
"+  Pager* pager = table->pager;\n"
"+  uint32_t num_full_pages = table->num_rows / ROWS_PER_PAGE;\n"
"+\n"
"+  for (uint32_t i = 0; i < num_full_pages; i++) {\n"
"+    if (pager->pages[i] == NULL) {\n"
"+      continue;\n"
"+    }\n"
"+    pager_flush(pager, i, PAGE_SIZE);\n"
"+    free(pager->pages[i]);\n"
"+    pager->pages[i] = NULL;\n"
"+  }\n"
"+\n"
"+  // There may be a partial page to write to the end of the file\n"
"+  // This should not be needed after we switch to a B-tree\n"
"+  uint32_t num_additional_rows = table->num_rows % ROWS_PER_PAGE;\n"
"+  if (num_additional_rows > 0) {\n"
"+    uint32_t page_num = num_full_pages;\n"
"+    if (pager->pages[page_num] != NULL) {\n"
"+      pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);\n"
"+      free(pager->pages[page_num]);\n"
"+      pager->pages[page_num] = NULL;\n"
"+    }\n"
"+  }\n"
"+\n"
"+  int result = close(pager->file_descriptor);\n"
"+  if (result == -1) {\n"
"+    printf(\"Error closing db file.\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+  for (uint32_t i = 0; i < TABLE_MAX_PAGES; i++) {\n"
"+    void* page = pager->pages[i];\n"
"+    if (page) {\n"
"+      free(page);\n"
"+      pager->pages[i] = NULL;\n"
"+    }\n"
"+  }\n"
"+  free(pager);\n"
"+  free(table);\n"
"+}\n"
"+\n"
"-MetaCommandResult do_meta_command(InputBuffer* input_buffer) {\n"
"+MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table* table) {\n"
"   if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"+    db_close(table);\n"
"     exit(EXIT_SUCCESS);\n"
"   } else {\n"
"     return META_COMMAND_UNRECOGNIZED_COMMAND;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+void indent(uint32_t level) {\n"
"+  for (uint32_t i = 0; i < level; i++) {\n"
"+    printf(\"  \");\n"
"+  }\n"
"+}\n"
"+\n"
"+void print_tree(Pager* pager, uint32_t page_num, uint32_t indentation_level) "
"{\n"
"+  void* node = get_page(pager, page_num);\n"
"+  uint32_t num_keys, child;\n"
"+\n"
"+  switch (get_node_type(node)) {\n"
"+    case (NODE_LEAF):\n"
"+      num_keys = *leaf_node_num_cells(node);\n"
"+      indent(indentation_level);\n"
"+      printf(\"- leaf (size %d)\n"
"\", num_keys);\n"
"+      for (uint32_t i = 0; i < num_keys; i++) {\n"
"+        indent(indentation_level + 1);\n"
"+        printf(\"- %d\n"
"\", *leaf_node_key(node, i));\n"
"+      }\n"
"+      break;\n"
"+    case (NODE_INTERNAL):\n"
"+      num_keys = *internal_node_num_keys(node);\n"
"+      indent(indentation_level);\n"
"+      printf(\"- internal (size %d)\n"
"\", num_keys);\n"
"+      for (uint32_t i = 0; i < num_keys; i++) {\n"
"+        child = *internal_node_child(node, i);\n"
"+        print_tree(pager, child, indentation_level + 1);\n"
"+\n"
"+        indent(indentation_level + 1);\n"
"+        printf(\"- key %d\n"
"\", *internal_node_key(node, i));\n"
"+      }\n"
"+      child = *internal_node_right_child(node);\n"
"+      print_tree(pager, child, indentation_level + 1);\n"
"+      break;\n"
"+  }\n"
"+}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+void internal_node_insert(Table* table, uint32_t parent_page_num,\n"
"+                          uint32_t child_page_num) {\n"
"+  /*\n"
"+  Add a new child/key pair to parent that corresponds to child\n"
"+  */\n"
"+\n"
"+  void* parent = get_page(table->pager, parent_page_num);\n"
"+  void* child = get_page(table->pager, child_page_num);\n"
"+  uint32_t child_max_key = get_node_max_key(child);\n"
"+  uint32_t index = internal_node_find_child(parent, child_max_key);\n"
"+\n"
"+  uint32_t original_num_keys = *internal_node_num_keys(parent);\n"
"+  *internal_node_num_keys(parent) = original_num_keys + 1;\n"
"+\n"
"+  if (original_num_keys >= INTERNAL_NODE_MAX_CELLS) {\n"
"+    printf(\"Need to implement splitting internal node\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+void leaf_node_insert(Cursor* cursor, uint32_t key, Row* value) {\n"
"+  void* node = get_page(cursor->table->pager, cursor->page_num);\n"
"+\n"
"+  uint32_t num_cells = *leaf_node_num_cells(node);\n"
"+  if (num_cells >= LEAF_NODE_MAX_CELLS) {\n"
"+    // Node full\n"
"+    printf(\"Need to implement splitting a leaf node.\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  if (cursor->cell_num < num_cells) {\n"
"+    // Make room for new cell\n"
"+    for (uint32_t i = num_cells; i > cursor->cell_num; i--) {\n"
"+      memcpy(leaf_node_cell(node, i), leaf_node_cell(node, i - 1),\n"
"+             LEAF_NODE_CELL_SIZE);\n"
"+    }\n"
"+  }\n"
"+\n"
"+  *(leaf_node_num_cells(node)) += 1;\n"
"+  *(leaf_node_key(node, cursor->cell_num)) = key;\n"
"+  serialize_row(value, leaf_node_value(node, cursor->cell_num));\n"
"+}\n"
"+\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+void leaf_node_split_and_insert(Cursor* cursor, uint32_t key, Row* value) {\n"
"+  /*\n"
"+  Create a new node and move half the cells over.\n"
"+  Insert the new value in one of the two nodes.\n"
"+  Update parent or create a new parent.\n"
"+  */\n"
"+\n"
"+  void* old_node = get_page(cursor->table->pager, cursor->page_num);\n"
"+  uint32_t new_page_num = get_unused_page_num(cursor->table->pager);\n"
"+  void* new_node = get_page(cursor->table->pager, new_page_num);\n"
"+  initialize_leaf_node(new_node);\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {\n"
"+  if (pager->pages[page_num] == NULL) {\n"
"+    printf(\"Tried to flush null page\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  off_t offset = lseek(pager->file_descriptor, page_num * PAGE_SIZE, SEEK_SET"
");\n"
"+\n"
"+  if (offset == -1) {\n"
"+    printf(\"Error seeking: %d\n"
"\", errno);\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  ssize_t bytes_written =\n"
"+      write(pager->file_descriptor, pager->pages[page_num], size);\n"
"+\n"
"+  if (bytes_written == -1) {\n"
"+    printf(\"Error writing: %d\n"
"\", errno);\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+void print_constants() {\n"
"+  printf(\"ROW_SIZE: %d\n"
"\", ROW_SIZE);\n"
"+  printf(\"COMMON_NODE_HEADER_SIZE: %d\n"
"\", COMMON_NODE_HEADER_SIZE);\n"
"+  printf(\"LEAF_NODE_HEADER_SIZE: %d\n"
"\", LEAF_NODE_HEADER_SIZE);\n"
"+  printf(\"LEAF_NODE_CELL_SIZE: %d\n"
"\", LEAF_NODE_CELL_SIZE);\n"
"+  printf(\"LEAF_NODE_SPACE_FOR_CELLS: %d\n"
"\", LEAF_NODE_SPACE_FOR_CELLS);\n"
"+  printf(\"LEAF_NODE_MAX_CELLS: %d\n"
"\", LEAF_NODE_MAX_CELLS);\n"
"+}\n"
"+\n"
"@@ -294,6 +376,14 @@ MetaCommandResult do_meta_command(InputBuffer* input_buff"
"er, Table* table) {\n"
"   if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"     db_close(table);\n"
"     exit(EXIT_SUCCESS);\n"
"+  } else if (strcmp(input_buffer->buffer, \".constants\") == 0) {\n"
"+    printf(\"Constants:\n"
"\");\n"
"+    print_constants();\n"
"+    return META_COMMAND_SUCCESS;\n"
"   } else {\n"
"     return META_COMMAND_UNRECOGNIZED_COMMAND;\n"
"   }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+void print_leaf_node(void* node) {\n"
"+  uint32_t num_cells = *leaf_node_num_cells(node);\n"
"+  printf(\"leaf (size %d)\n"
"\", num_cells);\n"
"+  for (uint32_t i = 0; i < num_cells; i++) {\n"
"+    uint32_t key = *leaf_node_key(node, i);\n"
"+    printf(\"  - %d : %d\n"
"\", i, key);\n"
"+  }\n"
"+}\n"
"+\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+void update_internal_node_key(void* node, uint32_t old_key, uint32_t new_key)"
" {\n"
"+  uint32_t old_child_index = internal_node_find_child(node, old_key);\n"
"+  *internal_node_key(node, old_child_index) = new_key;\n"
" }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"+void* get_page(Pager* pager, uint32_t page_num) {\n"
"+  if (page_num > TABLE_MAX_PAGES) {\n"
"+    printf(\"Tried to fetch page number out of bounds. %d > %d\n"
"\", page_num,\n"
"+           TABLE_MAX_PAGES);\n"
"+    exit(EXIT_FAILURE);\n"
"+  }\n"
"+\n"
"+  if (pager->pages[page_num] == NULL) {\n"
"+    // Cache miss. Allocate memory and load from file.\n"
"+    void* page = malloc(PAGE_SIZE);\n"
"+    uint32_t num_pages = pager->file_length / PAGE_SIZE;\n"
"+\n"
"+    // We might save a partial page at the end of the file\n"
"+    if (pager->file_length % PAGE_SIZE) {\n"
"+      num_pages += 1;\n"
"+    }\n"
"+\n"
"+    if (page_num <= num_pages) {\n"
"+      lseek(pager->file_descriptor, page_num * PAGE_SIZE, SEEK_SET);\n"
"+      ssize_t bytes_read = read(pager->file_descriptor, page, PAGE_SIZE);\n"
"+      if (bytes_read == -1) {\n"
"+        printf(\"Error reading file: %d\n"
"\", errno);\n"
"+        exit(EXIT_FAILURE);\n"
"+      }\n"
"+    }\n"
"+\n"
"+    pager->pages[page_num] = page;\n"
"+  }\n"
"+\n"
"+  return pager->pages[page_num];\n"
"+}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"-Cursor* internal_node_find(Table* table, uint32_t page_num, uint32_t key) {\n"
"-  void* node = get_page(table->pager, page_num);\n"
"+uint32_t internal_node_find_child(void* node, uint32_t key) {\n"
"+  /*\n"
"+  Return the index of the child which should contain\n"
"+  the given key.\n"
"+  */\n"
"+\n"
"   uint32_t num_keys = *internal_node_num_keys(node);"
msgstr ""

msgid ""
"```diff\n"
"-Cursor* table_end(Table* table) {\n"
"-  Cursor* cursor = malloc(sizeof(Cursor));\n"
"-  cursor->table = table;\n"
"-  cursor->page_num = table->root_page_num;\n"
"-\n"
"-  void* root_node = get_page(table->pager, table->root_page_num);\n"
"-  uint32_t num_cells = *leaf_node_num_cells(root_node);\n"
"-  cursor->cell_num = num_cells;\n"
"-  cursor->end_of_table = true;\n"
"-\n"
"-  return cursor;\n"
"-}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"-Cursor* table_start(Table* table) {\n"
"-  Cursor* cursor = malloc(sizeof(Cursor));\n"
"-  cursor->table = table;\n"
"-  cursor->page_num = table->root_page_num;\n"
"-  cursor->cell_num = 0;\n"
"-\n"
"-  void* root_node = get_page(table->pager, table->root_page_num);\n"
"-  uint32_t num_cells = *leaf_node_num_cells(root_node);\n"
"-  cursor->end_of_table = (num_cells == 0);\n"
"-\n"
"-  return cursor;\n"
"-}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"-Table* new_table() {\n"
"+Table* db_open(const char* filename) {\n"
"+  Pager* pager = pager_open(filename);\n"
"+  uint32_t num_rows = pager->file_length / ROW_SIZE;\n"
"+\n"
"   Table* table = malloc(sizeof(Table));\n"
"-  table->num_rows = 0;\n"
"+  table->pager = pager;\n"
"+  table->num_rows = num_rows;"
msgstr ""

msgid ""
"```diff\n"
"-enum ExecuteResult_t { EXECUTE_SUCCESS, EXECUTE_TABLE_FULL };\n"
"+enum ExecuteResult_t {\n"
"+  EXECUTE_SUCCESS,\n"
"+  EXECUTE_DUPLICATE_KEY,\n"
"+  EXECUTE_TABLE_FULL\n"
"+};\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"-void initialize_leaf_node(void* node) { *leaf_node_num_cells(node) = 0; }\n"
"+void initialize_leaf_node(void* node) {\n"
"+  set_node_type(node, NODE_LEAF);\n"
"+  *leaf_node_num_cells(node) = 0;\n"
"+}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"-void print_leaf_node(void* node) {\n"
"-  uint32_t num_cells = *leaf_node_num_cells(node);\n"
"-  printf(\"leaf (size %d)\n"
"\", num_cells);\n"
"-  for (uint32_t i = 0; i < num_cells; i++) {\n"
"-    uint32_t key = *leaf_node_key(node, i);\n"
"-    printf(\"  - %d : %d\n"
"\", i, key);\n"
"-  }\n"
"-}\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"-void* row_slot(Table* table, uint32_t row_num) {\n"
"+void* cursor_value(Cursor* cursor) {\n"
"+  uint32_t row_num = cursor->row_num;\n"
"   uint32_t page_num = row_num / ROWS_PER_PAGE;\n"
"-  void* page = get_page(table->pager, page_num);\n"
"+  void* page = get_page(cursor->table->pager, page_num);\n"
"   uint32_t row_offset = row_num % ROWS_PER_PAGE;\n"
"   uint32_t byte_offset = row_offset * ROW_SIZE;\n"
"   return page + byte_offset;\n"
" }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"@@ -10,6 +10,23 @@ struct InputBuffer_t {\n"
" } InputBuffer;"
msgstr ""

msgid ""
"```diff\n"
"@@ -126,6 +126,8 @@ const uint32_t INTERNAL_NODE_KEY_SIZE = sizeof(uint32_t);\n"
" const uint32_t INTERNAL_NODE_CHILD_SIZE = sizeof(uint32_t);\n"
" const uint32_t INTERNAL_NODE_CELL_SIZE =\n"
"     INTERNAL_NODE_CHILD_SIZE + INTERNAL_NODE_KEY_SIZE;\n"
"+/* Keep this small for testing */\n"
"+const uint32_t INTERNAL_NODE_MAX_CELLS = 3;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"@@ -127,6 +200,10 @@ void* get_page(Pager* pager, uint32_t page_num) {\n"
"     }"
msgstr ""

msgid ""
"```diff\n"
"@@ -184,6 +269,12 @@ Pager* pager_open(const char* filename) {\n"
"   Pager* pager = malloc(sizeof(Pager));\n"
"   pager->file_descriptor = fd;\n"
"   pager->file_length = file_length;\n"
"+  pager->num_pages = (file_length / PAGE_SIZE);\n"
"+\n"
"+  if (file_length % PAGE_SIZE != 0) {\n"
"+    printf(\"Db file is not a whole number of pages. Corrupt file.\n"
"\");\n"
"+    exit(EXIT_FAILURE);\n"
"+  }"
msgstr ""

msgid ""
"```diff\n"
"@@ -294,6 +376,14 @@ MetaCommandResult do_meta_command(InputBuffer* input_buff"
"er, Table* table) {\n"
"   if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"     db_close(table);\n"
"     exit(EXIT_SUCCESS);\n"
"+  } else if (strcmp(input_buffer->buffer, \".btree\") == 0) {\n"
"+    printf(\"Tree:\n"
"\");\n"
"+    print_leaf_node(get_page(table->pager, 0));\n"
"+    return META_COMMAND_SUCCESS;\n"
"   } else if (strcmp(input_buffer->buffer, \".constants\") == 0) {\n"
"     printf(\"Constants:\n"
"\");\n"
"     print_constants();\n"
"     return META_COMMAND_SUCCESS;\n"
"   } else {\n"
"     return META_COMMAND_UNRECOGNIZED_COMMAND;\n"
"   }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"@@ -322,6 +330,7 @@ void initialize_leaf_node(void* node) {\n"
"   set_node_type(node, NODE_LEAF);\n"
"   set_node_root(node, false);\n"
"   *leaf_node_num_cells(node) = 0;\n"
"+  *leaf_node_next_leaf(node) = 0;  // 0 represents no sibling\n"
" }\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"@@ -428,7 +432,15 @@ void cursor_advance(Cursor* cursor) {"
msgstr ""

msgid ""
"```diff\n"
"@@ -62,29 +62,101 @@ const uint32_t ROW_SIZE = ID_SIZE + USERNAME_SIZE + EMAIL"
"_SIZE;"
msgstr ""

msgid ""
"```diff\n"
"@@ -65,7 +65,7 @@ describe 'database' do\n"
"     result = run_script(script)\n"
"     expect(result.last(2)).to match_array([\n"
"       \"db > Executed.\",\n"
"-      \"db > Need to implement updating parent after split\",\n"
"+      \"db > Need to implement splitting internal node\",\n"
"     ])\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"@@ -659,6 +671,8 @@ void leaf_node_split_and_insert(Cursor* cursor, uint32_t k"
"ey, Row* value) {\n"
"   uint32_t new_page_num = get_unused_page_num(cursor->table->pager);\n"
"   void* new_node = get_page(cursor->table->pager, new_page_num);\n"
"   initialize_leaf_node(new_node);\n"
"+  *leaf_node_next_leaf(new_node) = *leaf_node_next_leaf(old_node);\n"
"+  *leaf_node_next_leaf(old_node) = new_page_num;\n"
"```"
msgstr ""

msgid ""
"```diff\n"
"@@ -670,9 +725,11 @@ void leaf_node_split_and_insert(Cursor* cursor, uint32_t "
"key, Row* value) {\n"
"   */"
msgstr ""

msgid ""
"```diff\n"
"@@ -676,7 +690,9 @@ void leaf_node_split_and_insert(Cursor* cursor, uint32_t k"
"ey, Row* value) {\n"
"     void* destination = leaf_node_cell(destination_node, index_within_node);"
msgstr ""

msgid ""
"```diff\n"
"ExecuteResult execute_insert(Statement* statement, Table* table) {\n"
"   void* node = get_page(table->pager, table->root_page_num);\n"
"   uint32_t num_cells = (*leaf_node_num_cells(node));\n"
"-  if (num_cells >= LEAF_NODE_MAX_CELLS) {\n"
"-    return EXECUTE_TABLE_FULL;\n"
"-  }"
msgstr ""

msgid ""
"```diff\n"
"ExecuteResult execute_insert(Statement* statement, Table* table) {\n"
"   void* node = get_page(table->pager, table->root_page_num);\n"
"-  if ((*leaf_node_num_cells(node) >= LEAF_NODE_MAX_CELLS)) {\n"
"+  uint32_t num_cells = (*leaf_node_num_cells(node));\n"
"+  if (num_cells >= LEAF_NODE_MAX_CELLS) {\n"
"     return EXECUTE_TABLE_FULL;\n"
"   }"
msgstr ""

msgid ""
"```ruby\n"
"describe 'database' do\n"
"  def run_script(commands)\n"
"    raw_output = nil\n"
"    IO.popen(\"./db\", \"r+\") do |pipe|\n"
"      commands.each do |command|\n"
"        pipe.puts command\n"
"      end"
msgstr ""

msgid ""
"```ruby\n"
"it 'keeps data after closing connection' do\n"
"  result1 = run_script([\n"
"    \"insert 1 user1 person1@example.com\",\n"
"    \".exit\",\n"
"  ])\n"
"  expect(result1).to match_array([\n"
"    \"db > Executed.\",\n"
"    \"db > \",\n"
"  ])\n"
"  result2 = run_script([\n"
"    \"select\",\n"
"    \".exit\",\n"
"  ])\n"
"  expect(result2).to match_array([\n"
"    \"db > (1, user1, person1@example.com)\",\n"
"    \"Executed.\",\n"
"    \"db > \",\n"
"  ])\n"
"end\n"
"```"
msgstr ""

msgid ""
"```shell\n"
"~ sqlite3\n"
"SQLite version 3.16.0 2016-11-04 19:09:39\n"
"Enter \".help\" for usage hints.\n"
"Connected to a transient in-memory database.\n"
"Use \".open FILENAME\" to reopen on a persistent database.\n"
"sqlite> create table users (id int, username varchar(255), email varchar(255))"
";\n"
"sqlite> .tables\n"
"users\n"
"sqlite> .exit\n"
"~\n"
"```"
msgstr ""

msgid ""
"`buffer` starts as null, so `getline` allocates enough memory to hold the line"
" of input and makes `buffer` point to it."
msgstr "`buffer`はNULLで始まるため、`getline`は、入力したものを保存するために必要なメモリを割り当てて、`buffer`がそれを指し示します。"

msgid "`buffer`はNULLで始まるため、`getline`は、入力したものを保存するために必要なメモリを割り当てて、`buffer`がそれを指し示します。"
msgstr ""

msgid ""
"`db_open()` in turn calls `pager_open()`, which opens the database file and ke"
"eps track of its size. It also initializes the page cache to all `NULL`s."
msgstr ""

msgid ""
"`do_meta_command` is just a wrapper for existing functionality that leaves roo"
"m for more commands:"
msgstr ""

msgid ""
"`getline`は読み込んだ行を`input_buffer->buffer`保存し、割り当てられたバッファのサイズを`input_buffer->buff"
"er_length`に保存します。戻り値を`input_buffer->input_length`に保存します。"
msgstr ""

msgid "`insert` statements are now going to look like this:"
msgstr ""

msgid "`n` : a pointer to the variable we use to save the size of allocated buffer."
msgstr "`n` : 割り当てられたバッファサイズを保存するポインタ変数です。"

msgid "`n` : 割り当てられたバッファサイズを保存するポインタ変数です。"
msgstr ""

msgid ""
"`prepare_statement` (our \"SQL Compiler\") does not understand SQL right now. In"
" fact, it only understands two words:\n"
"```c\n"
"PrepareResult prepare_statement(InputBuffer* input_buffer,\n"
"                                Statement* statement) {\n"
"  if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n"
"    statement->type = STATEMENT_INSERT;\n"
"    return PREPARE_SUCCESS;\n"
"  }\n"
"  if (strcmp(input_buffer->buffer, \"select\") == 0) {\n"
"    statement->type = STATEMENT_SELECT;\n"
"    return PREPARE_SUCCESS;\n"
"  }"
msgstr ""

msgid ""
"`return value` : the number of bytes read, which may be less than the size of "
"the buffer."
msgstr "`return value` : これの戻り値は読み込んだバイト数を表していて、バッファのサイズより小さいときもあります。"

msgid "`return value` : これの戻り値は読み込んだバイト数を表していて、バッファのサイズより小さいときもあります。"
msgstr ""

msgid ""
"`stream` : the input stream to read from. We'll be reading from standard input"
"."
msgstr "`stream` : 入力ストリームから読み込んだ変数を表しています。標準入力から読み込まれます。"

msgid "`stream` : 入力ストリームから読み込んだ変数を表しています。標準入力から読み込まれます。"
msgstr ""

msgid "`table_start()` and `table_end()` create new cursors:"
msgstr ""

msgid ""
"int main(int argc, char* argv[]) {\n"
"  InputBuffer* input_buffer = new_input_buffer();\n"
"  while (true) {\n"
"    print_prompt();\n"
"    read_input(input_buffer);"
msgstr ""
"int main(int argc, char* argv[]) {\n"
"  InputBuffer* input_buffer = new_input_buffer();\n"
"  while (true) {\n"
"    print_prompt();\n"
"    read_input(input_buffer);"

msgid "to this:"
msgstr ""

msgid ""
"typedef enum { PREPARE_SUCCESS, PREPARE_UNRECOGNIZED_STATEMENT } PrepareResult"
";\n"
"```"
msgstr ""

msgid ""
"typedef struct {\n"
"  StatementType type;\n"
"} Statement;\n"
"```"
msgstr ""

msgid ""
"typedef struct {\n"
"  char* buffer;\n"
"  size_t buffer_length;\n"
"  ssize_t input_length;\n"
"} InputBuffer;"
msgstr ""
"typedef struct {\n"
"  char* buffer;\n"
"  size_t buffer_length;\n"
"  ssize_t input_length;\n"
"} InputBuffer;"

msgid ""
"void close_input_buffer(InputBuffer* input_buffer) {\n"
"    free(input_buffer->buffer);\n"
"    free(input_buffer);\n"
"}"
msgstr ""
"void close_input_buffer(InputBuffer* input_buffer) {\n"
"    free(input_buffer->buffer);\n"
"    free(input_buffer);\n"
"}"

msgid "void print_prompt() { printf(\"db > \"); }"
msgstr "void print_prompt() { printf(\"db > \"); }"

msgid ""
"void read_input(InputBuffer* input_buffer) {\n"
"  ssize_t bytes_read =\n"
"      getline(&(input_buffer->buffer), &(input_buffer->buffer_length), stdin);"
msgstr ""
"void read_input(InputBuffer* input_buffer) {\n"
"  ssize_t bytes_read =\n"
"      getline(&(input_buffer->buffer), &(input_buffer->buffer_length), stdin);"

msgid ""
"web開発者として、[私](https://github.com/cstack)はデータベースを毎日使います。しかしデータベースの中身がブラックボックスのよ"
"うに感じます。いくつか不思議に思っていることがあります。:\n"
"- データは(メモリと外部記憶装置などにおいて)どのようにして保存されるのでしょうか?\n"
"- いつデータはメモリから外部記憶装置に移されるのでしょうか?\n"
"- なぜテーブルごとのキーは一意なのでしょうか?\n"
"- トランザクションのローリングバックの仕組みはどのようなものなのでしょうか?\n"
"- インデックスのフォーマットの仕組みはどのようなものでしょうか?\n"
"- いつ、どんな感じで、テーブルが満タンになったとき何が起きるのでしょうか?\n"
"- プリペアドステートメントはどのようなフォーマットで保存されるのでしょうか?"
msgstr ""

msgid ""
"with a new recursive function that takes any node, then prints it and its chil"
"dren. It takes an indentation level as a parameter, which increases with each "
"recursive call. I'm also adding a tiny helper function to indent."
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/B-tree.png\" description=\"example B-Tr"
"ee (https://en.wikipedia.org/wiki/File:B-tree.svg)\" %}"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/arch-part5.gif\" description=\"How our "
"program matches up with SQLite architecture\" %}"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/arch1.gif\" description=\"sqlite archit"
"ecture (https://www.sqlite.org/zipvfs/doc/trunk/www/howitworks.wiki)\" %}"
msgstr ""
"{% include image.html url=\"assets/images/arch1.gif\" description=\"sqliteの構造(htt"
"ps://www.sqlite.org/zipvfs/doc/trunk/www/howitworks.wiki)\" %}"

msgid ""
"{% include image.html url=\"assets/images/arch1.gif\" description=\"sqliteの構造(htt"
"ps://www.sqlite.org/zipvfs/doc/trunk/www/howitworks.wiki)\" %}"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/arch2.gif\" description=\"SQLite Archit"
"ecture (https://www.sqlite.org/arch.html)\" %}"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/btree1.png\" description=\"empty btree\""
" %}"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/btree2.png\" description=\"one-node btr"
"ee\" %}"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/btree3.png\" description=\"structure of"
" our btree\" %}"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/btree3.png\" description=\"two-level bt"
"ree\" %}"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/btree4.png\" description=\"four-node bt"
"ree\" %}"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/btree5.png\" description=\"no room in i"
"nternal node\" %}"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/btree6.png\" description=\"three-level "
"btree\" %}"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/internal-node-format.png\" description"
"=\"Our internal node format\" %}"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/leaf-node-format.png\" description=\"Or"
"iginal leaf node format\" %}"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/leaf-node-format.png\" description=\"Ou"
"r leaf node format\" %}"
msgstr ""

msgid ""
"{% include image.html url=\"assets/images/updating-internal-node.png\" descripti"
"on=\"Example of updating internal node\" %}"
msgstr ""

msgid "{% seo %}"
msgstr ""

msgid ""
"|                               | B-tree         | B+ tree             |\n"
"|-------------------------------|----------------|---------------------|\n"
"| Pronounced                    | \"Bee Tree\"     | \"Bee Plus Tree\"     |\n"
"| Used to store                 | Indexes        | Tables              |\n"
"| Internal nodes store keys     | Yes            | Yes                 |\n"
"| Internal nodes store values   | Yes            | No                  |\n"
"| Number of children per node   | Less           | More                |\n"
"| Internal nodes vs. leaf nodes | Same structure | Different structure |"
msgstr ""

msgid ""
"|               | Unsorted Array of rows | Sorted Array of rows | Tree of node"
"s |\n"
"|---------------|------------------------|----------------------|-------------"
"--|\n"
"| Pages contain | only data              | only data            | metadata, pr"
"imary keys, and data              |\n"
"| Rows per page | more                   | more                 | fewer       "
"  |\n"
"| Insertion     | O(1)                   | O(n)                 | O(log(n))   "
"  |\n"
"| Deletion      | O(n)                   | O(n)                 | O(log(n))   "
"  |\n"
"| Lookup by id  | O(n)                   | O(log(n))            | O(log(n))   "
"  |"
msgstr ""

msgid ""
"| # internal node layers | max # leaf nodes    | Size of all leaf nodes |\n"
"|------------------------|---------------------|------------------------|\n"
"| 0                      | 511^0 = 1           | 4 KB                   |\n"
"| 1                      | 511^1 = 512         | ~2 MB                   |\n"
"| 2                      | 511^2 = 261,121     | ~1 GB                   |\n"
"| 3                      | 511^3 = 133,432,831 | ~550 GB                 |"
msgstr ""

msgid ""
"| For an order-m tree... | Internal Node                 | Leaf Node          "
" |\n"
"|------------------------|-------------------------------|--------------------"
"-|\n"
"| Stores                 | keys and pointers to children | keys and values    "
" |\n"
"| Number of keys         | up to m-1                     | as many as will fit"
" |\n"
"| Number of pointers     | number of keys + 1            | none               "
" |\n"
"| Number of values       | none                          | number of keys     "
" |\n"
"| Key purpose            | used for routing              | paired with value  "
" |\n"
"| Stores values?         | No                            | Yes                "
" |"
msgstr ""

msgid ""
"| column   | size (bytes) | offset       |\n"
"|----------|--------------|--------------|\n"
"| id       | 4            | 0            |\n"
"| username | 32           | 4            |\n"
"| email    | 255          | 36           |\n"
"| total    | 291          |              |"
msgstr ""

msgid ""
"| column   | type         |\n"
"|----------|--------------|\n"
"| id       | integer      |\n"
"| username | varchar(32)  |\n"
"| email    | varchar(255) |"
msgstr ""

msgid ""
"ここで、`InputBuffer *`のインスタンス変数と`buffer`の要素のメモリを\n"
"解放する関数が必要です。\n"
"(`getline`は`read_input`の中の`input_buffer->buffer`へメモリを割り当てます。\n"
")。"
msgstr ""

msgid "このような処理を行うため、メイン関数は、プロンプトを表示して、入力を読み込み、それを処理する無限ループへ入ります。:"
msgstr ""

msgid ""
"これらの謎を解くために、私はデータベースをフルスクラッチで作っています。MySQLやPostgreSQLといったものよりも軽量で、機能も少ないためsqlit"
"eをモデルにしました。なので、データベースをより理解しやすくなったと思っています。実はデータベースは一つのファイルに、保存されているのです!"
msgstr ""

msgid "さて、動作できるREPLを完成させました!次のパートでは、オリジナルのコマンドライン言語を開発します。さて、今まで作成したプログラムの全体図を示します。:"
msgstr ""

msgid ""
"クエリは以下のような手順で、取得や変更したデータを解析しています。**フロントエンド** はこれらの要素から構成されています。:\n"
"- 字句解析(tokenizer)\n"
"- パーサー(parser)\n"
"- コード生成"
msgstr ""

msgid ""
"ローカルで実行する方法:\n"
"```\n"
"bundle exec jekyll serve\n"
"```"
msgstr ""

msgid ""
"入力されたものを読み込むため、[getline()](https://manpages.debian.org/unstable/manpages-ja-de"
"v/getline.3.ja.html)関数を使います。:\n"
"```c\n"
"ssize_t getline(char **lineptr, size_t *n, FILE *stream);\n"
"```\n"
"`lineptr` : は読み込んだものを保存しているバッファを指し示すポインタ変数です。もし`NULL`が設定されていれば、`getline`によって割り"
"当てられた時、コマンドが失敗したとしても、ユーザーは明示的に解放する必要があります。"
msgstr ""

msgid "手短に言うと、どのようにしてデータベースは**動くのでしょうか?**"
msgstr ""

msgid ""
"最後に、私たちはパースして、コマンドを実行します。たった一つの今すぐ実行できるコマンドがあります。: `.exit`それはプログラムを終了するというコマンド"
"です。さもなければ、私たちはエラーを出力して、ループを継続します。"
msgstr ""

msgid ""
"本プロジェクトの日本語は[jekyll-task-i18n](https://github.com/ruby-gettext/jekyll-task-i18"
"n)を用いて、日本語化しました。  \n"
"ローカルで実行する方法:\n"
"```\n"
"rake\n"
"bundle exec jekyll serve\n"
"```"
msgstr ""

msgid "次に、`print_prompt()`はユーザーにプロンプトを表示する関数です。入力を読み取る前にこれを実行します。"
msgstr ""

msgid ""
"試してみましょう!\n"
"```shell\n"
"~ ./db\n"
"db > .tables\n"
"'.tables'は認識できません\n"
"db > .exit\n"
"~\n"
"```"
msgstr ""
