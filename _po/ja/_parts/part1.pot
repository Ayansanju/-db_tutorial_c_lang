# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-23 11:24+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../_parts/part1.md:1
msgid "---\n"
"title: Part 1 - Introduction and Setting up the REPL\n"
"date: 2017-08-30\n"
"---"
msgstr ""

#: ../../../_parts/part1.md:6
msgid "As a web developer, I use relational databases every day at my job, but they're a black box to me. Some questions I have:\n"
"- What format is data saved in? (in memory and on disk)\n"
"- When does it move from memory to disk?\n"
"- Why can there only be one primary key per table?\n"
"- How does rolling back a transaction work?\n"
"- How are indexes formatted?\n"
"- When and how does a full table scan happen?\n"
"- What format is a prepared statement saved in?"
msgstr ""

#: ../../../_parts/part1.md:15
msgid "In other words, how does a database **work**?"
msgstr ""

#: ../../../_parts/part1.md:17
msgid "To figure things out, I'm writing a database from scratch. It's modeled off sqlite because it is designed to be small with fewer features than MySQL or PostgreSQL, so I have a better hope of understanding it. The entire database is stored in a single file!"
msgstr ""

#: ../../../_parts/part1.md:19
msgid "# Sqlite"
msgstr ""

#: ../../../_parts/part1.md:21
msgid "There's lots of [documentation of sqlite internals](https://www.sqlite.org/arch.html) on their website, plus I've got a copy of [SQLite Database System: Design and Implementation](https://play.google.com/store/books/details?id=9Z6IQQnX1JEC)."
msgstr ""

#: ../../../_parts/part1.md:23
msgid "{% include image.html url=\"assets/images/arch1.gif\" description=\"sqlite architecture (https://www.sqlite.org/zipvfs/doc/trunk/www/howitworks.wiki)\" %}"
msgstr ""

#: ../../../_parts/part1.md:25
msgid "A query goes through a chain of components in order to retrieve or modify data. The **front-end** consists of the:\n"
"- tokenizer\n"
"- parser\n"
"- code generator"
msgstr ""

#: ../../../_parts/part1.md:30
msgid "The input to the front-end is a SQL query. the output is sqlite virtual machine bytecode (essentially a compiled program that can operate on the database)."
msgstr ""

#: ../../../_parts/part1.md:32
msgid "The _back-end_ consists of the:\n"
"- virtual machine\n"
"- B-tree\n"
"- pager\n"
"- os interface"
msgstr ""

#: ../../../_parts/part1.md:38
msgid "The **virtual machine** takes bytecode generated by the front-end as instructions. It can then perform operations on one or more tables or indexes, each of which is stored in a data structure called a B-tree. The VM is essentially a big switch statement on the type of bytecode instruction."
msgstr ""

#: ../../../_parts/part1.md:40
msgid "Each **B-tree** consists of many nodes. Each node is one page in length. The B-tree can retrieve a page from disk or save it back to disk by issuing commands to the pager."
msgstr ""

#: ../../../_parts/part1.md:42
msgid "The **pager** receives commands to read or write pages of data. It is responsible for reading/writing at appropriate offsets in the database file. It also keeps a cache of recently-accessed pages in memory, and determines when those pages need to be written back to disk."
msgstr ""

#: ../../../_parts/part1.md:44
msgid "The **os interface** is the layer that differs depending on which operating system sqlite was compiled for. In this tutorial, I'm not going to support multiple platforms."
msgstr ""

#: ../../../_parts/part1.md:46
msgid "[A journey of a thousand miles begins with a single step](https://en.wiktionary.org/wiki/a_journey_of_a_thousand_miles_begins_with_a_single_step), so let's start with something a little more straightforward: the REPL."
msgstr ""

#: ../../../_parts/part1.md:48
msgid "## Making a Simple REPL"
msgstr ""

#: ../../../_parts/part1.md:50
msgid "Sqlite starts a read-execute-print loop when you start it from the command line:"
msgstr ""

#: ../../../_parts/part1.md:52
msgid "```shell\n"
"~ sqlite3\n"
"SQLite version 3.16.0 2016-11-04 19:09:39\n"
"Enter \".help\" for usage hints.\n"
"Connected to a transient in-memory database.\n"
"Use \".open FILENAME\" to reopen on a persistent database.\n"
"sqlite> create table users (id int, username varchar(255), email varchar(255));\n"
"sqlite> .tables\n"
"users\n"
"sqlite> .exit\n"
"~\n"
"```"
msgstr ""

#: ../../../_parts/part1.md:65
msgid "To do that, our main function will have an infinite loop that prints the prompt, gets a line of input, then processes that line of input:"
msgstr ""

#: ../../../_parts/part1.md:67
msgid "```c\n"
"int main(int argc, char* argv[]) {\n"
"  InputBuffer* input_buffer = new_input_buffer();\n"
"  while (true) {\n"
"    print_prompt();\n"
"    read_input(input_buffer);"
msgstr ""

#: ../../../_parts/part1.md:74
#: ../../../_parts/part1.md:222
msgid "    if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"      close_input_buffer(input_buffer);\n"
"      exit(EXIT_SUCCESS);\n"
"    } else {\n"
"      printf(\"Unrecognized command '%s'.\\n\", input_buffer->buffer);\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: ../../../_parts/part1.md:84
msgid "We'll define `InputBuffer` as a small wrapper around the state we need to store to interact with [getline()](http://man7.org/linux/man-pages/man3/getline.3.html). (More on that in a minute)\n"
"```c\n"
"typedef struct {\n"
"  char* buffer;\n"
"  size_t buffer_length;\n"
"  ssize_t input_length;\n"
"} InputBuffer;"
msgstr ""

#: ../../../_parts/part1.md:92
msgid "InputBuffer* new_input_buffer() {\n"
"  InputBuffer* input_buffer = (InputBuffer*)malloc(sizeof(InputBuffer));\n"
"  input_buffer->buffer = NULL;\n"
"  input_buffer->buffer_length = 0;\n"
"  input_buffer->input_length = 0;"
msgstr ""

#: ../../../_parts/part1.md:98
msgid "  return input_buffer;\n"
"}\n"
"```"
msgstr ""

#: ../../../_parts/part1.md:102
msgid "Next, `print_prompt()` prints a prompt to the user. We do this before reading each line of input."
msgstr ""

#: ../../../_parts/part1.md:104
msgid "```c\n"
"void print_prompt() { printf(\"db > \"); }\n"
"```"
msgstr ""

#: ../../../_parts/part1.md:108
msgid "To read a line of input, use [getline()](http://man7.org/linux/man-pages/man3/getline.3.html):\n"
"```c\n"
"ssize_t getline(char **lineptr, size_t *n, FILE *stream);\n"
"```\n"
"`lineptr` : a pointer to the variable we use to point to the buffer containing the read line. If it set to `NULL` it is mallocatted by `getline` and should thus be freed by the user, even if the command fails."
msgstr ""

#: ../../../_parts/part1.md:114
msgid "`n` : a pointer to the variable we use to save the size of allocated buffer."
msgstr ""

#: ../../../_parts/part1.md:116
msgid "`stream` : the input stream to read from. We'll be reading from standard input."
msgstr ""

#: ../../../_parts/part1.md:118
msgid "`return value` : the number of bytes read, which may be less than the size of the buffer."
msgstr ""

#: ../../../_parts/part1.md:120
msgid "We tell `getline` to store the read line in `input_buffer->buffer` and the size of the allocated buffer in `input_buffer->buffer_length`. We store the return value in `input_buffer->input_length`."
msgstr ""

#: ../../../_parts/part1.md:122
msgid "`buffer` starts as null, so `getline` allocates enough memory to hold the line of input and makes `buffer` point to it."
msgstr ""

#: ../../../_parts/part1.md:124
msgid "```c\n"
"void read_input(InputBuffer* input_buffer) {\n"
"  ssize_t bytes_read =\n"
"      getline(&(input_buffer->buffer), &(input_buffer->buffer_length), stdin);"
msgstr ""

#: ../../../_parts/part1.md:129
#: ../../../_parts/part1.md:201
msgid "  if (bytes_read <= 0) {\n"
"    printf(\"Error reading input\\n\");\n"
"    exit(EXIT_FAILURE);\n"
"  }"
msgstr ""

#: ../../../_parts/part1.md:134
msgid "  // Ignore trailing newline\n"
"  input_buffer->input_length = bytes_read - 1;\n"
"  input_buffer->buffer[bytes_read - 1] = 0;\n"
"}\n"
"```"
msgstr ""

#: ../../../_parts/part1.md:140
msgid "Now it is proper to define a function that frees the memory allocated for an\n"
"instance of `InputBuffer *` and the `buffer` element of the respective\n"
"structure (`getline` allocates memory for `input_buffer->buffer` in\n"
"`read_input`)."
msgstr ""

#: ../../../_parts/part1.md:145
msgid "```c\n"
"void close_input_buffer(InputBuffer* input_buffer) {\n"
"    free(input_buffer->buffer);\n"
"    free(input_buffer);\n"
"}\n"
"```"
msgstr ""

#: ../../../_parts/part1.md:152
msgid "Finally, we parse and execute the command. There is only one recognized command right now : `.exit`, which terminates the program. Otherwise we print an error message and continue the loop."
msgstr ""

#: ../../../_parts/part1.md:154
msgid "```c\n"
"if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n"
"  close_input_buffer(input_buffer);\n"
"  exit(EXIT_SUCCESS);\n"
"} else {\n"
"  printf(\"Unrecognized command '%s'.\\n\", input_buffer->buffer);\n"
"}\n"
"```"
msgstr ""

#: ../../../_parts/part1.md:163
msgid "Let's try it out!\n"
"```shell\n"
"~ ./db\n"
"db > .tables\n"
"Unrecognized command '.tables'.\n"
"db > .exit\n"
"~\n"
"```"
msgstr ""

#: ../../../_parts/part1.md:172
msgid "Alright, we've got a working REPL. In the next part, we'll start developing our command language. Meanwhile, here's the entire program from this part:"
msgstr ""

#: ../../../_parts/part1.md:174
msgid "```c\n"
"#include <stdbool.h>\n"
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <string.h>"
msgstr ""

#: ../../../_parts/part1.md:180
msgid "typedef struct {\n"
"  char* buffer;\n"
"  size_t buffer_length;\n"
"  ssize_t input_length;\n"
"} InputBuffer;"
msgstr ""

#: ../../../_parts/part1.md:186
msgid "InputBuffer* new_input_buffer() {\n"
"  InputBuffer* input_buffer = malloc(sizeof(InputBuffer));\n"
"  input_buffer->buffer = NULL;\n"
"  input_buffer->buffer_length = 0;\n"
"  input_buffer->input_length = 0;"
msgstr ""

#: ../../../_parts/part1.md:192
msgid "  return input_buffer;\n"
"}"
msgstr ""

#: ../../../_parts/part1.md:195
msgid "void print_prompt() { printf(\"db > \"); }"
msgstr ""

#: ../../../_parts/part1.md:197
msgid "void read_input(InputBuffer* input_buffer) {\n"
"  ssize_t bytes_read =\n"
"      getline(&(input_buffer->buffer), &(input_buffer->buffer_length), stdin);"
msgstr ""

#: ../../../_parts/part1.md:206
msgid "  // Ignore trailing newline\n"
"  input_buffer->input_length = bytes_read - 1;\n"
"  input_buffer->buffer[bytes_read - 1] = 0;\n"
"}"
msgstr ""

#: ../../../_parts/part1.md:211
msgid "void close_input_buffer(InputBuffer* input_buffer) {\n"
"    free(input_buffer->buffer);\n"
"    free(input_buffer);\n"
"}"
msgstr ""

#: ../../../_parts/part1.md:216
msgid "int main(int argc, char* argv[]) {\n"
"  InputBuffer* input_buffer = new_input_buffer();\n"
"  while (true) {\n"
"    print_prompt();\n"
"    read_input(input_buffer);"
msgstr ""

